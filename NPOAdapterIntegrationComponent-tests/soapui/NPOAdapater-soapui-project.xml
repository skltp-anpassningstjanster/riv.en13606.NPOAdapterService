<?xml version="1.0" encoding="UTF-8"?>
<con:soapui-project activeEnvironment="Default" name="NPOAdapater" soapui-version="4.6.0" abortOnError="false" runType="SEQUENTIAL" resourceRoot="" xmlns:con="http://eviware.com/soapui/config"><con:settings/><con:interface xsi:type="con:WsdlInterface" wsaVersion="NONE" name="RIV13606REQUEST_EHR_EXTRACT_Binding" type="wsdl" bindingName="{urn:riv13606:v1.1}RIV13606REQUEST_EHR_EXTRACT_Binding" soapVersion="1_1" anonymous="optional" definition="http://localhost:11000/npoadapter/ehrextract/v11?wsdl" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"><con:settings/><con:definitionCache type="TEXT" rootPart="http://localhost:11000/npoadapter/ehrextract/v11?wsdl"><con:part><con:url>http://localhost:11000/npoadapter/ehrextract/v11?wsdl</con:url><con:content><![CDATA[<wsdl:definitions targetNamespace="urn:riv13606:v1.1" xmlns:http="http://schemas.xmlsoap.org/wsdl/http/" xmlns:mime="http://schemas.xmlsoap.org/wsdl/mime/" xmlns:soap="http://schemas.xmlsoap.org/wsdl/soap/" xmlns:soapenc="http://schemas.xmlsoap.org/soap/encoding/" xmlns:tns="urn:riv13606:v1.1" xmlns:wsdl="http://schemas.xmlsoap.org/wsdl/" xmlns:xs="http://www.w3.org/2001/XMLSchema">
  <wsdl:types>
    <xs:schema targetNamespace="urn:riv13606:v1.1">
      <xs:include schemaLocation="http://localhost:11000/npoadapter/ehrextract/v11?xsd=SE13606RequestEHRExtract.xsd"/>
    </xs:schema>
  </wsdl:types>
  <wsdl:message name="RIV13606REQUEST_EHR_EXTRACT_request">
    <wsdl:part element="tns:RIV13606REQUEST_EHR_EXTRACT_request" name="RIV13606REQUEST_EHR_EXTRACT_request"></wsdl:part>
  </wsdl:message>
  <wsdl:message name="RIV13606REQUEST_EHR_EXTRACT_response">
    <wsdl:part element="tns:RIV13606REQUEST_EHR_EXTRACT_response" name="RIV13606REQUEST_EHR_EXTRACT_response"></wsdl:part>
  </wsdl:message>
  <wsdl:message name="RIV13606REQUEST_EHR_EXTRACT_CONTINUATION_request">
    <wsdl:part element="tns:RIV13606REQUEST_EHR_EXTRACT_CONTINUATION_request" name="RIV13606REQUEST_EHR_EXTRACT_request"></wsdl:part>
  </wsdl:message>
  <wsdl:portType name="RIV13606REQUEST_EHR_EXTRACT_PortType">
    <wsdl:operation name="RIV13606REQUEST_EHR_EXTRACT">
      <wsdl:input message="tns:RIV13606REQUEST_EHR_EXTRACT_request"></wsdl:input>
      <wsdl:output message="tns:RIV13606REQUEST_EHR_EXTRACT_response"></wsdl:output>
    </wsdl:operation>
    <wsdl:operation name="RIV13606REQUEST_EHR_EXTRACT_CONTINUATION">
      <wsdl:input message="tns:RIV13606REQUEST_EHR_EXTRACT_CONTINUATION_request"></wsdl:input>
      <wsdl:output message="tns:RIV13606REQUEST_EHR_EXTRACT_response"></wsdl:output>
    </wsdl:operation>
  </wsdl:portType>
  <wsdl:binding name="RIV13606REQUEST_EHR_EXTRACT_Binding" type="tns:RIV13606REQUEST_EHR_EXTRACT_PortType">
    <soap:binding style="document" transport="http://schemas.xmlsoap.org/soap/http"/>
    <wsdl:operation name="RIV13606REQUEST_EHR_EXTRACT">
      <soap:operation soapAction="urn:riv13606:v1.1:RIV13606REQUEST_EHR_EXTRACT"/>
      <wsdl:input>
        <soap:body use="literal"/>
      </wsdl:input>
      <wsdl:output>
        <soap:body use="literal"/>
      </wsdl:output>
    </wsdl:operation>
    <wsdl:operation name="RIV13606REQUEST_EHR_EXTRACT_CONTINUATION">
      <soap:operation soapAction="urn:riv13606:v1.1:RIV13606REQUEST_EHR_EXTRACT_CONTINUATION"/>
      <wsdl:input>
        <soap:body use="literal"/>
      </wsdl:input>
      <wsdl:output>
        <soap:body use="literal"/>
      </wsdl:output>
    </wsdl:operation>
  </wsdl:binding>
  <wsdl:service name="RIV13606REQUEST_EHR_EXTRACT_Service">
    <wsdl:port binding="tns:RIV13606REQUEST_EHR_EXTRACT_Binding" name="RIV13606REQUEST_EHR_EXTRACT_Port">
      <soap:address location="http://localhost:11000/npoadapter/ehrextract/v11"/>
    </wsdl:port>
  </wsdl:service>
  <xs:annotation>
    <xs:documentation>Rodolfo Garcia
		Torbjorn Dahlin
		Brainpool - Mawell AB
		
		WSDL descriptions for Request_EHR_EXTRACT method from 13606-5.
		The method has extended to support the following functionality:
		
		Continuation
		------------------
		The ability to fetch batches of EHR_EXTRACTS
		rather than all or nothing.
		
		Multiple errors, warnings and/or informational messages
		--------------------------------------------------------------------------------
		This implementationen allows a collection of these types of
		messages to be returned, with or without actual EHR_EXTRACT results.
		
		Generic parameters
		----------------------------
		A collection of generic (name, value) pairs are allowed as inbound
		parameters.
		
		Use of ISO 21090 datatypes
		-----------------------------------------
		The ISO datatypes are used at the parameter level.</xs:documentation>
  </xs:annotation>
</wsdl:definitions>]]></con:content><con:type>http://schemas.xmlsoap.org/wsdl/</con:type></con:part><con:part><con:url>http://localhost:11000/npoadapter/ehrextract/v11?xsd=SE13606RequestEHRExtract.xsd</con:url><con:content><![CDATA[<xs:schema attributeFormDefault="unqualified" elementFormDefault="qualified" targetNamespace="urn:riv13606:v1.1" xmlns="urn:riv13606:v1.1" xmlns:tns="urn:riv13606:v1.1" xmlns:xs="http://www.w3.org/2001/XMLSchema">
  <xs:annotation>
    <xs:documentation>Rodolfo Garcia
		Torbjorn Dahlin
		Brainpool - Mawell AB
		
		XML Schema to support the WSDL schema for Request_EHR_EXTRACT method from 13606-5.
		The 13606-5 functionality has been extended to support the following functionality:
		
		Continuation
		------------------
		The ability to fetch batches of EHR_EXTRACTS
		rather than all or nothing.
		
		Multiple errors, warnings and/or informational messages
		--------------------------------------------------------------------------------
		This implementationen allows a collection of these types of
		messages to be returned, with or without actual EHR_EXTRACT results.
		
		Generic parameters
		----------------------------
		A collection of generic (name, value) pairs are allowed as inbound
		parameters.
		
		Use of ISO 21090 datatypes
		-----------------------------------------
		The ISO datatypes are used at the parameter level.

		-----------------------------------------
                v1.1 2012-11-01. Modified by Bjorn Strihagen Inera (HCT)
                Replaced xmlns=.. with xmlns:tns=.. in header and qualified referred types with tns:
                This is required by svcutil.exe</xs:documentation>
  </xs:annotation>
  <xs:include schemaLocation="http://localhost:11000/npoadapter/ehrextract/v11?xsd=ISO_dt.xsd"/>
  <xs:include schemaLocation="http://localhost:11000/npoadapter/ehrextract/v11?xsd=SE13606-1.xsd"/>
  <xs:element name="RIV13606REQUEST_EHR_EXTRACT_request" type="tns:RIV13606REQUEST_EHR_EXTRACT_request_type"/>
  <xs:element name="RIV13606REQUEST_EHR_EXTRACT_response" type="tns:RIV13606REQUEST_EHR_EXTRACT_response_type"/>
  <xs:element name="RIV13606REQUEST_EHR_EXTRACT_CONTINUATION_request" type="tns:RIV13606REQUEST_EHR_EXTRACT_CONTINUATION_request_type"/>
  <xs:complexType name="RIV13606REQUEST_EHR_EXTRACT_request_type">
    <xs:sequence>
      <xs:element name="subject_of_care_id" type="II"/>
      <xs:element minOccurs="0" name="purpose" type="CD"/>
      <xs:element maxOccurs="unbounded" minOccurs="0" name="rc_ids" type="II"/>
      <xs:element minOccurs="0" name="time_period" type="IVL_TS"/>
      <xs:element minOccurs="0" name="max_sensitivity" type="INT"/>
      <xs:element minOccurs="0" name="all_versions" type="BL"/>
      <xs:element minOccurs="0" name="multimedia_included" type="BL"/>
      <xs:element maxOccurs="unbounded" minOccurs="0" name="archetype_ids" type="II"/>
      <xs:element maxOccurs="unbounded" minOccurs="0" name="meanings" type="CD"/>
      <xs:element minOccurs="0" name="max_records" type="INT"/>
      <xs:element maxOccurs="unbounded" minOccurs="0" name="parameters" type="tns:Parameter_type"/>
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="RIV13606REQUEST_EHR_EXTRACT_CONTINUATION_request_type">
    <xs:sequence>
      <xs:element minOccurs="0" name="max_records" type="INT"/>
      <xs:element minOccurs="0" name="start_record" type="INT"/>
      <xs:element name="continuation_token" type="ST"/>
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="Parameter_type">
    <xs:sequence>
      <xs:element minOccurs="0" name="code" type="CD"/>
      <xs:element name="name" type="ST"/>
      <xs:element name="value" type="ST"/>
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="RIV13606REQUEST_EHR_EXTRACT_response_type">
    <xs:sequence>
      <xs:element maxOccurs="unbounded" minOccurs="0" name="ehr_extract" type="tns:EHR_EXTRACT"/>
      <xs:element minOccurs="0" name="continuation_token" type="ST"/>
      <xs:element maxOccurs="unbounded" minOccurs="0" name="response_detail" type="tns:ResponseDetail_type"/>
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="ResponseDetail_type">
    <xs:sequence>
      <xs:element minOccurs="0" name="code" type="CD"/>
      <xs:element name="text" type="ST"/>
    </xs:sequence>
    <xs:attribute name="type_code" type="tns:responseDetailTypeCodes"/>
  </xs:complexType>
  <xs:simpleType name="responseDetailTypeCodes">
    <xs:restriction base="xs:string">
      <xs:enumeration value="E"/>
      <xs:enumeration value="W"/>
      <xs:enumeration value="I"/>
      <!--Error-->
      <!--Warning-->
      <!--Information-->
    </xs:restriction>
  </xs:simpleType>
</xs:schema>]]></con:content><con:type>http://www.w3.org/2001/XMLSchema</con:type></con:part><con:part><con:url>http://localhost:11000/npoadapter/ehrextract/v11?xsd=ISO_dt.xsd</con:url><con:content><![CDATA[<!--Fel identifierat och åtgärdat i regexp-uttrycket för TS. Schemat innehåller därmed en avvikelse från det schema som specificeras i WGI_N08-012_ISO 21090-ISOv2.pdf.
Felet identifierades inom projektet NPÖ och används nu inom nationella projekt i Sverige.-->
<xsd:schema elementFormDefault="qualified" xmlns:sch="http://www.ascc.net/xml/schematron" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <xsd:annotation>
    <xsd:documentation>From draft ISO 21090 May 2008.</xsd:documentation>
  </xsd:annotation>
  <xsd:simpleType name="NullFlavor">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="NI"/>
      <xsd:enumeration value="INV"/>
      <xsd:enumeration value="OTH"/>
      <xsd:enumeration value="NINF"/>
      <xsd:enumeration value="PINF"/>
      <xsd:enumeration value="UNC"/>
      <xsd:enumeration value="DER"/>
      <xsd:enumeration value="UNK"/>
      <xsd:enumeration value="ASKU"/>
      <xsd:enumeration value="NAV"/>
      <xsd:enumeration value="QS"/>
      <xsd:enumeration value="NASK"/>
      <xsd:enumeration value="TRC"/>
      <xsd:enumeration value="MSK"/>
      <xsd:enumeration value="NA"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="UpdateMode">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="A"/>
      <xsd:enumeration value="AU"/>
      <xsd:enumeration value="U"/>
      <xsd:enumeration value="R"/>
      <xsd:enumeration value="I"/>
      <xsd:enumeration value="D"/>
      <xsd:enumeration value="K"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="Compression">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="DF"/>
      <xsd:enumeration value="GZ"/>
      <xsd:enumeration value="ZL"/>
      <xsd:enumeration value="Z"/>
      <xsd:enumeration value="BZ"/>
      <xsd:enumeration value="Z7"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="IntegrityCheckAlgorithm">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="SHA1"/>
      <xsd:enumeration value="SHA256"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="TelecommunicationAddressUse">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="H"/>
      <xsd:enumeration value="HP"/>
      <xsd:enumeration value="HV"/>
      <xsd:enumeration value="WP"/>
      <xsd:enumeration value="DIR"/>
      <xsd:enumeration value="PUB"/>
      <xsd:enumeration value="BAD"/>
      <xsd:enumeration value="TMP"/>
      <xsd:enumeration value="AS"/>
      <xsd:enumeration value="EC"/>
      <xsd:enumeration value="MC"/>
      <xsd:enumeration value="PG"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="set_TelecommunicationAddressUse">
    <xsd:list itemType="TelecommunicationAddressUse"/>
  </xsd:simpleType>
  <xsd:simpleType name="IdentifierScope">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="BUSN"/>
      <xsd:enumeration value="OBJ"/>
      <xsd:enumeration value="VER"/>
      <xsd:enumeration value="VW"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="IdentifierReliability">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="ISS"/>
      <xsd:enumeration value="VER"/>
      <xsd:enumeration value="UNV"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="AddressPartType">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="AL"/>
      <xsd:enumeration value="ADL"/>
      <xsd:enumeration value="UNID"/>
      <xsd:enumeration value="UNIT"/>
      <xsd:enumeration value="DAL"/>
      <xsd:enumeration value="DINST"/>
      <xsd:enumeration value="DINSTA"/>
      <xsd:enumeration value="DINSTQ"/>
      <xsd:enumeration value="DMOD"/>
      <xsd:enumeration value="DMODID"/>
      <xsd:enumeration value="SAL"/>
      <xsd:enumeration value="BNR"/>
      <xsd:enumeration value="BNN"/>
      <xsd:enumeration value="BNS"/>
      <xsd:enumeration value="STR"/>
      <xsd:enumeration value="STB"/>
      <xsd:enumeration value="STTYP"/>
      <xsd:enumeration value="DIR"/>
      <xsd:enumeration value="INT"/>
      <xsd:enumeration value="CAR"/>
      <xsd:enumeration value="CEN"/>
      <xsd:enumeration value="CNT"/>
      <xsd:enumeration value="CPA"/>
      <xsd:enumeration value="CTY"/>
      <xsd:enumeration value="DEL"/>
      <xsd:enumeration value="POB"/>
      <xsd:enumeration value="PRE"/>
      <xsd:enumeration value="STA"/>
      <xsd:enumeration value="ZIP"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="PostalAddressUse">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="H"/>
      <xsd:enumeration value="HP"/>
      <xsd:enumeration value="HV"/>
      <xsd:enumeration value="WP"/>
      <xsd:enumeration value="DIR"/>
      <xsd:enumeration value="PUB"/>
      <xsd:enumeration value="BAD"/>
      <xsd:enumeration value="TMP"/>
      <xsd:enumeration value="PHYS"/>
      <xsd:enumeration value="PST"/>
      <xsd:enumeration value="ABC"/>
      <xsd:enumeration value="IDE"/>
      <xsd:enumeration value="SYL"/>
      <xsd:enumeration value="SRCH"/>
      <xsd:enumeration value="SNDX"/>
      <xsd:enumeration value="PHON"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="set_PostalAddressUse">
    <xsd:list itemType="PostalAddressUse"/>
  </xsd:simpleType>
  <xsd:simpleType name="EntityNamePartType">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="FAM"/>
      <xsd:enumeration value="GIV"/>
      <xsd:enumeration value="PFX"/>
      <xsd:enumeration value="SFX"/>
      <xsd:enumeration value="DEL"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="EntityNamePartQualifier">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="LS"/>
      <xsd:enumeration value="AC"/>
      <xsd:enumeration value="NB"/>
      <xsd:enumeration value="PR"/>
      <xsd:enumeration value="VV"/>
      <xsd:enumeration value="AD"/>
      <xsd:enumeration value="BR"/>
      <xsd:enumeration value="SP"/>
      <xsd:enumeration value="CL"/>
      <xsd:enumeration value="IN"/>
      <xsd:enumeration value="TITLE"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="set_EntityNamePartQualifier">
    <xsd:list itemType="EntityNamePartQualifier"/>
  </xsd:simpleType>
  <xsd:simpleType name="EntityNameUse">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="C"/>
      <xsd:enumeration value="I"/>
      <xsd:enumeration value="L"/>
      <xsd:enumeration value="P"/>
      <xsd:enumeration value="A"/>
      <xsd:enumeration value="R"/>
      <xsd:enumeration value="OR"/>
      <xsd:enumeration value="SRCH"/>
      <xsd:enumeration value="PHON"/>
      <xsd:enumeration value="SNDX"/>
      <xsd:enumeration value="ABC"/>
      <xsd:enumeration value="SYL"/>
      <xsd:enumeration value="IDE"/>
      <xsd:enumeration value="ASGN"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="set_EntityNameUse">
    <xsd:list itemType="EntityNameUse"/>
  </xsd:simpleType>
  <xsd:simpleType name="CalendarCycle">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="CY"/>
      <xsd:enumeration value="MY"/>
      <xsd:enumeration value="CM"/>
      <xsd:enumeration value="CW"/>
      <xsd:enumeration value="WY"/>
      <xsd:enumeration value="DM"/>
      <xsd:enumeration value="CD"/>
      <xsd:enumeration value="DY"/>
      <xsd:enumeration value="DW"/>
      <xsd:enumeration value="HD"/>
      <xsd:enumeration value="CH"/>
      <xsd:enumeration value="NH"/>
      <xsd:enumeration value="CN"/>
      <xsd:enumeration value="SN"/>
      <xsd:enumeration value="CS"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="TimingEvent">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="HS"/>
      <xsd:enumeration value="AC"/>
      <xsd:enumeration value="ACM"/>
      <xsd:enumeration value="ACD"/>
      <xsd:enumeration value="ACV"/>
      <xsd:enumeration value="IC"/>
      <xsd:enumeration value="ICM"/>
      <xsd:enumeration value="ICD"/>
      <xsd:enumeration value="ICV"/>
      <xsd:enumeration value="PC"/>
      <xsd:enumeration value="PCM"/>
      <xsd:enumeration value="PCD"/>
      <xsd:enumeration value="PCV"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="CodingRationale">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="O"/>
      <xsd:enumeration value="P"/>
      <xsd:enumeration value="R"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="set_CodingRationale">
    <xsd:list itemType="CodingRationale"/>
  </xsd:simpleType>
  <xsd:simpleType name="UncertaintyType">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="U"/>
      <xsd:enumeration value="N"/>
      <xsd:enumeration value="LN"/>
      <xsd:enumeration value="G"/>
      <xsd:enumeration value="E"/>
      <xsd:enumeration value="X2"/>
      <xsd:enumeration value="T"/>
      <xsd:enumeration value="F"/>
      <xsd:enumeration value="B"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:complexType mixed="true" name="StrucDoc.Text">
    <xsd:sequence>
      <xsd:choice maxOccurs="unbounded" minOccurs="0">
        <xsd:element name="footnote" type="StrucDoc.Footnote"/>
        <xsd:element name="footnoteRef" type="StrucDoc.FootnoteRef"/>
        <xsd:element name="linkHtml" type="StrucDoc.LinkHtml"/>
        <xsd:element name="sub" type="StrucDoc.Sub"/>
        <xsd:element name="sup" type="StrucDoc.Sup"/>
        <xsd:element name="content" type="StrucDoc.Content"/>
        <xsd:element name="br" type="StrucDoc.Br"/>
        <xsd:element name="renderMultiMedia" type="StrucDoc.RenderMultiMedia"/>
        <xsd:element name="paragraph" type="StrucDoc.Paragraph"/>
        <xsd:element name="list" type="StrucDoc.List"/>
        <xsd:element name="table" type="StrucDoc.Table"/>
      </xsd:choice>
    </xsd:sequence>
    <xsd:attributeGroup ref="StrucDoc.Base"/>
  </xsd:complexType>
  <xsd:attributeGroup name="StrucDoc.Base">
    <xsd:attribute name="ID" type="xsd:ID" use="optional"/>
    <xsd:attribute name="language" type="Code" use="optional"/>
    <xsd:attribute name="styleCode" type="set_Code" use="optional"/>
  </xsd:attributeGroup>
  <xsd:simpleType name="XmlID">
    <xsd:restriction base="xsd:ID"/>
  </xsd:simpleType>
  <xsd:simpleType name="Code">
    <xsd:restriction base="xsd:string"/>
  </xsd:simpleType>
  <xsd:simpleType name="set_Code">
    <xsd:list itemType="Code"/>
  </xsd:simpleType>
  <xsd:complexType mixed="true" name="StrucDoc.Footnote">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="Some content required">
          <sch:rule abstract="true" id="StrucDoc.Footnote-0">
            <sch:assert test="count(*|text()[normalize-space(.)!=''])!=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:choice maxOccurs="unbounded" minOccurs="0">
        <xsd:element name="footnote" type="StrucDoc.Footnote"/>
        <xsd:element name="footnoteRef" type="StrucDoc.FootnoteRef"/>
        <xsd:element name="linkHtml" type="StrucDoc.LinkHtml"/>
        <xsd:element name="sub" type="StrucDoc.Sub"/>
        <xsd:element name="sup" type="StrucDoc.Sup"/>
        <xsd:element name="content" type="StrucDoc.Content"/>
        <xsd:element name="br" type="StrucDoc.Br"/>
        <xsd:element name="renderMultiMedia" type="StrucDoc.RenderMultiMedia"/>
        <xsd:element name="paragraph" type="StrucDoc.Paragraph"/>
        <xsd:element name="list" type="StrucDoc.List"/>
        <xsd:element name="table" type="StrucDoc.Table"/>
      </xsd:choice>
    </xsd:sequence>
    <xsd:attributeGroup ref="StrucDoc.Base"/>
  </xsd:complexType>
  <xsd:complexType name="StrucDoc.FootnoteRef">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="must have a reference">
          <sch:rule abstract="true" id="StrucDoc.FootnoteRef-0">
            <sch:assert test="@IDREF"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:attribute name="IDREF" type="xsd:IDREF" use="optional"/>
    <xsd:attributeGroup ref="StrucDoc.Base"/>
  </xsd:complexType>
  <xsd:simpleType name="XmlIDREF">
    <xsd:restriction base="xsd:IDREF"/>
  </xsd:simpleType>
  <xsd:complexType mixed="true" name="StrucDoc.LinkHtml">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="must have at least one item">
          <sch:rule abstract="true" id="StrucDoc.LinkHtml-0">
            <sch:assert test="count(*|text()[normalize-space(.)!=''])!=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:choice maxOccurs="unbounded" minOccurs="0">
        <xsd:element name="footnote" type="StrucDoc.Footnote"/>
        <xsd:element name="footnoteRef" type="StrucDoc.FootnoteRef"/>
      </xsd:choice>
    </xsd:sequence>
    <xsd:attribute name="name" type="xsd:string" use="optional"/>
    <xsd:attribute name="href" type="xsd:string" use="optional"/>
    <xsd:attribute name="rel" type="xsd:string" use="optional"/>
    <xsd:attribute name="rev" type="xsd:string" use="optional"/>
    <xsd:attribute name="title" type="xsd:string" use="optional"/>
    <xsd:attributeGroup ref="StrucDoc.Base"/>
  </xsd:complexType>
  <xsd:complexType mixed="true" name="StrucDoc.Sub">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="text must not be empty">
          <sch:rule abstract="true" id="StrucDoc.Sub-0">
            <sch:assert test="string-length(text()) != 0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
  </xsd:complexType>
  <xsd:complexType mixed="true" name="StrucDoc.Sup">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="text must not be empty">
          <sch:rule abstract="true" id="StrucDoc.Sup-0">
            <sch:assert test="string-length(text()) != 0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
  </xsd:complexType>
  <xsd:complexType mixed="true" name="StrucDoc.Content">
    <xsd:sequence>
      <xsd:choice maxOccurs="unbounded" minOccurs="0">
        <xsd:element name="footnote" type="StrucDoc.Footnote"/>
        <xsd:element name="footnoteRef" type="StrucDoc.FootnoteRef"/>
        <xsd:element name="linkHtml" type="StrucDoc.LinkHtml"/>
        <xsd:element name="sub" type="StrucDoc.Sub"/>
        <xsd:element name="sup" type="StrucDoc.Sup"/>
        <xsd:element name="content" type="StrucDoc.Content"/>
        <xsd:element name="br" type="StrucDoc.Br"/>
        <xsd:element name="renderMultiMedia" type="StrucDoc.RenderMultiMedia"/>
      </xsd:choice>
    </xsd:sequence>
    <xsd:attribute name="revised" type="StrucDoc.Revised" use="optional"/>
    <xsd:attributeGroup ref="StrucDoc.Base"/>
  </xsd:complexType>
  <xsd:simpleType name="StrucDoc.Revised">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="insert"/>
      <xsd:enumeration value="delete"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:complexType name="StrucDoc.Br"/>
  <xsd:complexType name="StrucDoc.RenderMultiMedia">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="must have at least one reference">
          <sch:rule abstract="true" id="StrucDoc.RenderMultiMedia-0">
            <sch:assert test="@referencedObject"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element minOccurs="0" name="caption" type="StrucDoc.Caption"/>
    </xsd:sequence>
    <xsd:attribute name="referencedObject" type="set_IDREF" use="optional"/>
    <xsd:attributeGroup ref="StrucDoc.Base"/>
  </xsd:complexType>
  <xsd:complexType mixed="true" name="StrucDoc.Caption">
    <xsd:sequence>
      <xsd:choice maxOccurs="unbounded" minOccurs="0">
        <xsd:element name="footnote" type="StrucDoc.Footnote"/>
        <xsd:element name="footnoteRef" type="StrucDoc.FootnoteRef"/>
        <xsd:element name="linkHtml" type="StrucDoc.LinkHtml"/>
        <xsd:element name="sub" type="StrucDoc.Sub"/>
        <xsd:element name="sup" type="StrucDoc.Sup"/>
      </xsd:choice>
    </xsd:sequence>
    <xsd:attributeGroup ref="StrucDoc.Base"/>
  </xsd:complexType>
  <xsd:simpleType name="set_IDREF">
    <xsd:list itemType="xsd:IDREF"/>
  </xsd:simpleType>
  <xsd:complexType mixed="true" name="StrucDoc.Paragraph">
    <xsd:complexContent mixed="true">
      <xsd:extension base="StrucDoc.Captioned">
        <xsd:sequence>
          <xsd:choice maxOccurs="unbounded" minOccurs="0">
            <xsd:element name="footnote" type="StrucDoc.Footnote"/>
            <xsd:element name="footnoteRef" type="StrucDoc.FootnoteRef"/>
            <xsd:element name="linkHtml" type="StrucDoc.LinkHtml"/>
            <xsd:element name="sub" type="StrucDoc.Sub"/>
            <xsd:element name="sup" type="StrucDoc.Sup"/>
            <xsd:element name="content" type="StrucDoc.Content"/>
            <xsd:element name="br" type="StrucDoc.Br"/>
            <xsd:element name="renderMultiMedia" type="StrucDoc.RenderMultiMedia"/>
          </xsd:choice>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType mixed="true" name="StrucDoc.Captioned">
    <xsd:sequence>
      <xsd:element minOccurs="0" name="caption" type="StrucDoc.Caption"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="StrucDoc.Base"/>
  </xsd:complexType>
  <xsd:complexType mixed="true" name="StrucDoc.List">
    <xsd:complexContent mixed="true">
      <xsd:extension base="StrucDoc.Captioned">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="StrucDoc.Item"/>
        </xsd:sequence>
        <xsd:attribute name="listType" type="StrucDoc.ListType" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:simpleType name="StrucDoc.ListType">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="ordered_"/>
      <xsd:enumeration value="unordered_"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:complexType mixed="true" name="StrucDoc.Item">
    <xsd:complexContent mixed="true">
      <xsd:extension base="StrucDoc.Captioned">
        <xsd:sequence>
          <xsd:choice maxOccurs="unbounded" minOccurs="0">
            <xsd:element name="footnote" type="StrucDoc.Footnote"/>
            <xsd:element name="footnoteRef" type="StrucDoc.FootnoteRef"/>
            <xsd:element name="linkHtml" type="StrucDoc.LinkHtml"/>
            <xsd:element name="sub" type="StrucDoc.Sub"/>
            <xsd:element name="sup" type="StrucDoc.Sup"/>
            <xsd:element name="content" type="StrucDoc.Content"/>
            <xsd:element name="br" type="StrucDoc.Br"/>
            <xsd:element name="renderMultiMedia" type="StrucDoc.RenderMultiMedia"/>
            <xsd:element name="paragraph" type="StrucDoc.Paragraph"/>
            <xsd:element name="list" type="StrucDoc.List"/>
            <xsd:element name="table" type="StrucDoc.Table"/>
          </xsd:choice>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType mixed="true" name="StrucDoc.Table">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="columns">
          <sch:rule abstract="true" id="StrucDoc.Table-0">
            <sch:assert test="not(col) or not(column)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent mixed="true">
      <xsd:extension base="StrucDoc.Captioned">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="col" type="StrucDoc.Col"/>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="colgroup" type="StrucDoc.ColGroup"/>
          <xsd:element minOccurs="0" name="thead" type="StrucDoc.TRowGroup"/>
          <xsd:element minOccurs="0" name="tfoot" type="StrucDoc.TRowGroup"/>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="tbody" type="StrucDoc.TRowGroup"/>
        </xsd:sequence>
        <xsd:attribute name="summary" type="xsd:string" use="optional"/>
        <xsd:attribute name="width" type="StrucDoc.Length" use="optional"/>
        <xsd:attribute name="border" type="StrucDoc.Length" use="optional"/>
        <xsd:attribute name="frame" type="StrucDoc.Frame" use="optional"/>
        <xsd:attribute name="rules" type="StrucDoc.Rules" use="optional"/>
        <xsd:attribute name="cellspacing" type="StrucDoc.Length" use="optional"/>
        <xsd:attribute name="cellpadding" type="StrucDoc.Length" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="StrucDoc.Col">
    <xsd:complexContent>
      <xsd:extension base="StrucDoc.ColItem"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="StrucDoc.ColItem">
    <xsd:complexContent>
      <xsd:extension base="StrucDoc.TableItem">
        <xsd:attribute default="1" name="span" type="xsd:int" use="optional"/>
        <xsd:attribute name="width" type="StrucDoc.Length" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="StrucDoc.TableItem">
    <xsd:attribute name="align" type="StrucDoc.Align" use="optional"/>
    <xsd:attribute name="char" type="xsd:string" use="optional"/>
    <xsd:attribute name="charoff" type="StrucDoc.Length" use="optional"/>
    <xsd:attribute name="valign" type="StrucDoc.VAlign" use="optional"/>
    <xsd:attributeGroup ref="StrucDoc.Base"/>
  </xsd:complexType>
  <xsd:simpleType name="StrucDoc.Align">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="left"/>
      <xsd:enumeration value="center"/>
      <xsd:enumeration value="right"/>
      <xsd:enumeration value="justify"/>
      <xsd:enumeration value="char"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="StrucDoc.Length">
    <xsd:restriction base="xsd:string"/>
  </xsd:simpleType>
  <xsd:simpleType name="StrucDoc.VAlign">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="top"/>
      <xsd:enumeration value="middle"/>
      <xsd:enumeration value="bottom"/>
      <xsd:enumeration value="baseline"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:complexType name="StrucDoc.ColGroup">
    <xsd:complexContent>
      <xsd:extension base="StrucDoc.ColItem">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="col" type="StrucDoc.Col"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="StrucDoc.TRowGroup">
    <xsd:complexContent>
      <xsd:extension base="StrucDoc.TableItem">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="tr" type="StrucDoc.TRow"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="StrucDoc.TRow">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="cells">
          <sch:rule abstract="true" id="StrucDoc.TRow-0">
            <sch:assert test="th|td"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="StrucDoc.TableItem">
        <xsd:sequence>
          <xsd:choice maxOccurs="unbounded" minOccurs="0">
            <xsd:element name="th" type="StrucDoc.TCell"/>
            <xsd:element name="td" type="StrucDoc.TCell"/>
          </xsd:choice>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType mixed="true" name="StrucDoc.TCell">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="no nested tables">
          <sch:rule abstract="true" id="StrucDoc.TCell-0">
            <sch:assert test="not(@table)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent mixed="true">
      <xsd:extension base="StrucDoc.TableItem">
        <xsd:sequence>
          <xsd:choice maxOccurs="unbounded" minOccurs="0">
            <xsd:element name="footnote" type="StrucDoc.Footnote"/>
            <xsd:element name="footnoteRef" type="StrucDoc.FootnoteRef"/>
            <xsd:element name="linkHtml" type="StrucDoc.LinkHtml"/>
            <xsd:element name="sub" type="StrucDoc.Sub"/>
            <xsd:element name="sup" type="StrucDoc.Sup"/>
            <xsd:element name="content" type="StrucDoc.Content"/>
            <xsd:element name="br" type="StrucDoc.Br"/>
            <xsd:element name="renderMultiMedia" type="StrucDoc.RenderMultiMedia"/>
            <xsd:element name="paragraph" type="StrucDoc.Paragraph"/>
            <xsd:element name="list" type="StrucDoc.List"/>
            <xsd:element name="table" type="StrucDoc.Table"/>
          </xsd:choice>
        </xsd:sequence>
        <xsd:attribute name="abbr" type="xsd:string" use="optional"/>
        <xsd:attribute name="axis" type="xsd:string" use="optional"/>
        <xsd:attribute name="headers" type="set_IDREF" use="optional"/>
        <xsd:attribute name="scope" type="StrucDoc.CellScope" use="optional"/>
        <xsd:attribute default="1" name="rowspan" type="xsd:int" use="optional"/>
        <xsd:attribute default="1" name="colspan" type="xsd:int" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:simpleType name="StrucDoc.CellScope">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="row"/>
      <xsd:enumeration value="col"/>
      <xsd:enumeration value="rowgroup"/>
      <xsd:enumeration value="colgroup"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="StrucDoc.Frame">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="void"/>
      <xsd:enumeration value="above"/>
      <xsd:enumeration value="below"/>
      <xsd:enumeration value="hsides"/>
      <xsd:enumeration value="lhs"/>
      <xsd:enumeration value="rhs"/>
      <xsd:enumeration value="vsides"/>
      <xsd:enumeration value="box"/>
      <xsd:enumeration value="border"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="StrucDoc.Rules">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="none"/>
      <xsd:enumeration value="groups"/>
      <xsd:enumeration value="rows"/>
      <xsd:enumeration value="cols"/>
      <xsd:enumeration value="all"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="Uid">
    <xsd:restriction base="xsd:string"/>
  </xsd:simpleType>
  <xsd:simpleType name="Uri">
    <xsd:restriction base="xsd:anyURI"/>
  </xsd:simpleType>
  <xsd:complexType name="BL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="value if not null">
          <sch:rule abstract="true" id="BL-0">
            <sch:assert test="@nullFlavor or (not(@nullFlavor) and @value)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:attribute name="value" type="xsd:boolean" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ANY">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="no ANY unless null">
          <sch:rule abstract="true" id="ANY-0">
            <sch:assert test="todo"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="HXIT">
        <xsd:attribute name="nullFlavor" type="NullFlavor" use="optional"/>
        <xsd:attribute name="flavorId" type="xsd:string" use="optional"/>
        <xsd:attribute name="updateMode" type="UpdateMode" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="HXIT">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="extension requires root">
          <sch:rule abstract="true" id="HXIT-0">
            <sch:assert test="not(@controlActExtension) or @controlActRoot"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:attribute name="validTimeLow" type="xsd:string" use="optional"/>
    <xsd:attribute name="validTimeHigh" type="xsd:string" use="optional"/>
    <xsd:attribute name="controlActRoot" type="Uid" use="optional"/>
    <xsd:attribute name="controlActExtension" type="xsd:string" use="optional"/>
  </xsd:complexType>
  <xsd:complexType name="BL.NONNULL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="BL.NONNULL cannot be null">
          <sch:rule abstract="true" id="BL.NONNULL-0">
            <sch:assert test="not(@nullFlavor)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="BL">
        <xsd:attribute name="nullFlavor" type="NullFlavor" use="prohibited"/>
        <xsd:attribute name="value" type="xsd:boolean" use="required"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ED">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="content is required if not null">
          <sch:rule abstract="true" id="ED-0">
            <sch:assert test="@nullFlavor or @value or xml or data"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="only one of value, data, xml">
          <sch:rule abstract="true" id="ED-1">
            <sch:assert test="count(*[self::value or self::xml or self::data])&lt;=1"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="integrityCheckAlgorithm required">
          <sch:rule abstract="true" id="ED-2">
            <sch:assert test="not(integrityCheck) or @integrityCheckAlgorithm"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="thumbnails do not use reference">
          <sch:rule abstract="true" id="ED-3">
            <sch:assert test="not(thumbnail) or thumbnail[not(@nullFlavor and reference)]"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="thumbnails do not have thumbnails">
          <sch:rule abstract="true" id="ED-4">
            <sch:assert test="not(thumbnail) or thumbnail[not(thumbnail)]"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="compression only on binary">
          <sch:rule abstract="true" id="ED-5">
            <sch:assert test="(@compression and data) or not(@compression or data)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="mediaType cannot be null">
          <sch:rule abstract="true" id="ED-6">
            <sch:assert test="@mediaType"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="value implies mediaType is text/plain">
          <sch:rule abstract="true" id="ED-7">
            <sch:assert test="not(@value) or (@value and (not(@mediaType) or @mediaType='text/plain'))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no charset for value or xml">
          <sch:rule abstract="true" id="ED-8">
            <sch:assert test="not(@value or xml) or not(@charset)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="ED-9">
            <sch:assert test="count(*[self::reference or self::thumbnail][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no nested translations">
          <sch:rule abstract="true" id="ED-10">
            <sch:assert test="not(translation) or thumbnail[not(translation)]"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no value if null">
          <sch:rule abstract="true" id="ED-11">
            <sch:assert test="not(@nullFlavor) or (@nullFlavor and not(@value))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no data if null">
          <sch:rule abstract="true" id="ED-12">
            <sch:assert test="not(@nullFlavor) or (@nullFlavor and not(@data))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no xml if null">
          <sch:rule abstract="true" id="ED-13">
            <sch:assert test="not(@nullFlavor) or (@nullFlavor and not(@xml))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no reference if null">
          <sch:rule abstract="true" id="ED-14">
            <sch:assert test="not(@nullFlavor) or (@nullFlavor and not(@reference))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no mediaType if null">
          <sch:rule abstract="true" id="ED-15">
            <sch:assert test="not(@nullFlavor) or (@nullFlavor and not(@mediaType))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no charset if null">
          <sch:rule abstract="true" id="ED-16">
            <sch:assert test="not(@nullFlavor) or (@nullFlavor and not(@charset))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no language if null">
          <sch:rule abstract="true" id="ED-17">
            <sch:assert test="not(@nullFlavor) or (@nullFlavor and not(@language))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no compression if null">
          <sch:rule abstract="true" id="ED-18">
            <sch:assert test="not(@nullFlavor) or (@nullFlavor and not(@compression))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no integrityCheck if null">
          <sch:rule abstract="true" id="ED-19">
            <sch:assert test="not(@nullFlavor) or (@nullFlavor and not(@integrityCheck))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no integrityCheckAlgorithm if null">
          <sch:rule abstract="true" id="ED-20">
            <sch:assert test="not(@nullFlavor) or (@nullFlavor and not(@integrityCheckAlgorithm))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no thumbnail if null">
          <sch:rule abstract="true" id="ED-21">
            <sch:assert test="not(@nullFlavor) or (not(thumbnail) or thumbnail\@nullFlavor)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no translation if null">
          <sch:rule abstract="true" id="ED-22">
            <sch:assert test="not(@nullFlavor) or (@nullFlavor and not(@translation))"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="data" type="xsd:base64Binary"/>
          <xsd:element minOccurs="0" name="xml" type="xsd:anyType"/>
          <xsd:element minOccurs="0" name="reference" type="TEL.URL"/>
          <xsd:element minOccurs="0" name="integrityCheck" type="xsd:base64Binary"/>
          <xsd:element minOccurs="0" name="thumbnail" type="ED"/>
          <xsd:element minOccurs="0" name="description" type="ST"/>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="translation" type="ED"/>
        </xsd:sequence>
        <xsd:attribute name="value" type="xsd:string" use="optional"/>
        <xsd:attribute default="text/plain" name="mediaType" type="xsd:string" use="optional"/>
        <xsd:attribute name="charset" type="Code" use="optional"/>
        <xsd:attribute name="language" type="Code" use="optional"/>
        <xsd:attribute name="compression" type="Compression" use="optional"/>
        <xsd:attribute name="integrityCheckAlgorithm" type="IntegrityCheckAlgorithm" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="TEL.URL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="no use">
          <sch:rule abstract="true" id="TEL.URL-0">
            <sch:assert test="not(use)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="schemes">
          <sch:rule abstract="true" id="TEL.URL-1">
            <sch:assert test="(starts-with(@value, &quot;file&quot;) or starts-with(@value, &quot;ftp&quot;) or starts-with(@value, &quot;http&quot;) or starts-with(@value, &quot;https&quot;) or starts-with(@value, &quot;nfs&quot;))"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="TEL">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="useablePeriod" type="QSET_TS"/>
        </xsd:sequence>
        <xsd:attribute name="use" type="TelecommunicationAddressUse" use="prohibited"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="TEL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="value is required">
          <sch:rule abstract="true" id="TEL-0">
            <sch:assert test="@nullFlavor or (not(@nullFlavor) and @value)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no value if null">
          <sch:rule abstract="true" id="TEL-1">
            <sch:assert test="not(@nullFlavor) or (@nullFlavor and not(@value))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no use if null">
          <sch:rule abstract="true" id="TEL-2">
            <sch:assert test="not(@nullFlavor) or (@nullFlavor and not(@use))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no useablePeriod if null">
          <sch:rule abstract="true" id="TEL-3">
            <sch:assert test="not(@nullFlavor) or (not(thumbnail) or useablePeriod\@nullFlavor)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on TEL attributes">
          <sch:rule abstract="true" id="TEL-4">
            <sch:assert test="count(*[self::useablePeriod][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="useablePeriod" type="QSET_TS"/>
        </xsd:sequence>
        <xsd:attribute name="value" type="xsd:anyURI" use="optional"/>
        <xsd:attribute name="use" type="set_TelecommunicationAddressUse" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="QSET_TS">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="QSET_TS-0">
            <sch:assert test="count(*[self::originalText][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ED.TEXT">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="text only">
          <sch:rule abstract="true" id="ED.TEXT-0">
            <sch:assert test="@mediaType = &quot;'text/plain'&quot;"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no xml">
          <sch:rule abstract="true" id="ED.TEXT-1">
            <sch:assert test="not(xml)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no data">
          <sch:rule abstract="true" id="ED.TEXT-2">
            <sch:assert test="not(data)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no integrityCheck">
          <sch:rule abstract="true" id="ED.TEXT-3">
            <sch:assert test="not(integrityCheck)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no thumbnail">
          <sch:rule abstract="true" id="ED.TEXT-4">
            <sch:assert test="not(thumbnail)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no compression">
          <sch:rule abstract="true" id="ED.TEXT-5">
            <sch:assert test="not(@compression)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no translations">
          <sch:rule abstract="true" id="ED.TEXT-6">
            <sch:assert test="not(translation)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="ED">
        <xsd:sequence>
          <xsd:element maxOccurs="0" minOccurs="0" name="data" type="xsd:base64Binary"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="xml" type="xsd:anyType"/>
          <xsd:element minOccurs="0" name="reference" type="TEL.URL"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="integrityCheck" type="xsd:base64Binary"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="thumbnail" type="ED"/>
          <xsd:element minOccurs="0" name="description" type="ST"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="translation" type="ED"/>
        </xsd:sequence>
        <xsd:attribute fixed="text/plain" name="mediaType" type="xsd:string" use="required"/>
        <xsd:attribute name="compression" type="Compression" use="prohibited"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ST">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="no nested translations">
          <sch:rule abstract="true" id="ST-0">
            <sch:assert test="not(translation) or thumbnail[not(translation)]"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="null or content">
          <sch:rule abstract="true" id="ST-1">
            <sch:assert test="(@nullFlavor or (@value and string-length(@value)&amp;gt;0)) and not(@nullFlavor and @value)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="translation" type="ST.NT"/>
        </xsd:sequence>
        <xsd:attribute name="value" type="xsd:string" use="optional"/>
        <xsd:attribute name="language" type="Code" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ST.NT">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="no translations">
          <sch:rule abstract="true" id="ST.NT-0">
            <sch:assert test="not(translation)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="ST">
        <xsd:sequence>
          <xsd:element maxOccurs="0" minOccurs="0" name="translation" type="ST.NT"/>
        </xsd:sequence>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ED.IMAGE">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="fixed to image">
          <sch:rule abstract="true" id="ED.IMAGE-0">
            <sch:assert test="starts-with(@mediaType, &quot;image/&quot;)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no text">
          <sch:rule abstract="true" id="ED.IMAGE-1">
            <sch:assert test="not(@value)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no xml">
          <sch:rule abstract="true" id="ED.IMAGE-2">
            <sch:assert test="not(xml)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="ED">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="data" type="xsd:base64Binary"/>
          <xsd:element minOccurs="0" name="xml" type="xsd:anyType"/>
          <xsd:element minOccurs="0" name="reference" type="TEL.URL"/>
          <xsd:element minOccurs="0" name="integrityCheck" type="xsd:base64Binary"/>
          <xsd:element minOccurs="0" name="thumbnail" type="ED"/>
          <xsd:element minOccurs="0" name="description" type="ST"/>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="translation" type="ED"/>
        </xsd:sequence>
        <xsd:attribute name="value" type="xsd:string" use="prohibited"/>
        <xsd:attribute name="mediaType" type="xsd:string" use="required"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ED.DOC">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="mediaType">
          <sch:rule abstract="true" id="ED.DOC-0">
            <sch:assert test="mediaType = &quot;text/plain&quot; or mediaType = &quot;text/html&quot; or mediaType = &quot;text/xml&quot; or mediaType = &quot;application/pdf&quot;"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="ED">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="data" type="xsd:base64Binary"/>
          <xsd:element minOccurs="0" name="xml" type="xsd:anyType"/>
          <xsd:element minOccurs="0" name="reference" type="TEL.URL"/>
          <xsd:element minOccurs="0" name="integrityCheck" type="xsd:base64Binary"/>
          <xsd:element minOccurs="0" name="thumbnail" type="ED"/>
          <xsd:element minOccurs="0" name="description" type="ST"/>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="translation" type="ED"/>
        </xsd:sequence>
        <xsd:attribute name="mediaType" type="xsd:string" use="required"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ED.DOC.REF">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="reference required">
          <sch:rule abstract="true" id="ED.DOC.REF-0">
            <sch:assert test="not(@nullFlavor) or (reference and not(reference/@nullFlavor))"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="ED.DOC">
        <xsd:sequence>
          <xsd:element maxOccurs="0" minOccurs="0" name="data" type="xsd:base64Binary"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="xml" type="xsd:anyType"/>
          <xsd:element minOccurs="0" name="reference" type="TEL.URL"/>
          <xsd:element minOccurs="0" name="integrityCheck" type="xsd:base64Binary"/>
          <xsd:element minOccurs="0" name="thumbnail" type="ED"/>
          <xsd:element minOccurs="0" name="description" type="ST"/>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="translation" type="ED"/>
        </xsd:sequence>
        <xsd:attribute name="value" type="xsd:string" use="prohibited"/>
        <xsd:attribute name="mediaType" type="xsd:string" use="required"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ED.DOC.INLINE">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="no reference">
          <sch:rule abstract="true" id="ED.DOC.INLINE-0">
            <sch:assert test="not(reference)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="ED.DOC">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="data" type="xsd:base64Binary"/>
          <xsd:element minOccurs="0" name="xml" type="xsd:anyType"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="reference" type="TEL.URL"/>
          <xsd:element minOccurs="0" name="integrityCheck" type="xsd:base64Binary"/>
          <xsd:element minOccurs="0" name="thumbnail" type="ED"/>
          <xsd:element minOccurs="0" name="description" type="ST"/>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="translation" type="ED"/>
        </xsd:sequence>
        <xsd:attribute name="mediaType" type="xsd:string" use="required"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ED.SIGNATURE">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="no reference">
          <sch:rule abstract="true" id="ED.SIGNATURE-0">
            <sch:assert test="not(reference)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no value">
          <sch:rule abstract="true" id="ED.SIGNATURE-1">
            <sch:assert test="not(@value)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no data">
          <sch:rule abstract="true" id="ED.SIGNATURE-2">
            <sch:assert test="not(data)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no integrityCheck">
          <sch:rule abstract="true" id="ED.SIGNATURE-3">
            <sch:assert test="not(integrityCheck)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no thumbnail">
          <sch:rule abstract="true" id="ED.SIGNATURE-4">
            <sch:assert test="not(thumbnail)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no compression">
          <sch:rule abstract="true" id="ED.SIGNATURE-5">
            <sch:assert test="not(@compression)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no language">
          <sch:rule abstract="true" id="ED.SIGNATURE-6">
            <sch:assert test="not(@language)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="mediaType">
          <sch:rule abstract="true" id="ED.SIGNATURE-7">
            <sch:assert test="@mediaType = &quot;'text/xml'&quot;"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no translations">
          <sch:rule abstract="true" id="ED.SIGNATURE-8">
            <sch:assert test="not(translation)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="ED">
        <xsd:sequence>
          <xsd:element maxOccurs="0" minOccurs="0" name="data" type="xsd:base64Binary"/>
          <xsd:element minOccurs="0" name="xml" type="xsd:anyType"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="reference" type="TEL.URL"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="integrityCheck" type="xsd:base64Binary"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="thumbnail" type="ED"/>
          <xsd:element minOccurs="0" name="description" type="ST"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="translation" type="ED"/>
        </xsd:sequence>
        <xsd:attribute name="value" type="xsd:string" use="prohibited"/>
        <xsd:attribute fixed="text/xml" name="mediaType" type="xsd:string" use="required"/>
        <xsd:attribute name="language" type="Code" use="prohibited"/>
        <xsd:attribute name="compression" type="Compression" use="prohibited"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ED.STRUCTUREDTEXT">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="mediatype">
          <sch:rule abstract="true" id="ED.STRUCTUREDTEXT-0">
            <sch:assert test="@mediaType = &quot;'text/x-hl7-text+xml'&quot;"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no value">
          <sch:rule abstract="true" id="ED.STRUCTUREDTEXT-1">
            <sch:assert test="not(@value)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no data">
          <sch:rule abstract="true" id="ED.STRUCTUREDTEXT-2">
            <sch:assert test="not(data)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no translations">
          <sch:rule abstract="true" id="ED.STRUCTUREDTEXT-3">
            <sch:assert test="not(translation)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="ED">
        <xsd:sequence>
          <xsd:element maxOccurs="0" minOccurs="0" name="data" type="xsd:base64Binary"/>
          <xsd:element minOccurs="0" name="xml" type="StrucDoc.Text"/>
          <xsd:element minOccurs="0" name="reference" type="TEL.URL"/>
          <xsd:element minOccurs="0" name="integrityCheck" type="xsd:base64Binary"/>
          <xsd:element minOccurs="0" name="thumbnail" type="ED"/>
          <xsd:element minOccurs="0" name="description" type="ST"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="translation" type="ED"/>
        </xsd:sequence>
        <xsd:attribute name="value" type="xsd:string" use="prohibited"/>
        <xsd:attribute fixed="text/x-hl7-text+xml" name="mediaType" type="xsd:string" use="required"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ED.STRUCTUREDTITLE">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="mediatype">
          <sch:rule abstract="true" id="ED.STRUCTUREDTITLE-0">
            <sch:assert test="@mediaType = &quot;'text/x-hl7-text+xml'&quot;"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no value">
          <sch:rule abstract="true" id="ED.STRUCTUREDTITLE-1">
            <sch:assert test="not(@value)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no data">
          <sch:rule abstract="true" id="ED.STRUCTUREDTITLE-2">
            <sch:assert test="not(data)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no translations">
          <sch:rule abstract="true" id="ED.STRUCTUREDTITLE-3">
            <sch:assert test="not(translation)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="ED">
        <xsd:sequence>
          <xsd:element maxOccurs="0" minOccurs="0" name="data" type="xsd:base64Binary"/>
          <xsd:element minOccurs="0" name="xml" type="StrucDoc.Title"/>
          <xsd:element minOccurs="0" name="reference" type="TEL.URL"/>
          <xsd:element minOccurs="0" name="integrityCheck" type="xsd:base64Binary"/>
          <xsd:element minOccurs="0" name="thumbnail" type="ED"/>
          <xsd:element minOccurs="0" name="description" type="ST"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="translation" type="ED"/>
        </xsd:sequence>
        <xsd:attribute name="value" type="xsd:string" use="prohibited"/>
        <xsd:attribute fixed="text/x-hl7-text+xml" name="mediaType" type="xsd:string" use="required"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType mixed="true" name="StrucDoc.Title">
    <xsd:sequence>
      <xsd:choice maxOccurs="unbounded" minOccurs="0">
        <xsd:element name="footnote" type="StrucDoc.TitleFootnote"/>
        <xsd:element name="footnoteRef" type="StrucDoc.FootnoteRef"/>
        <xsd:element name="br" type="StrucDoc.Br"/>
        <xsd:element name="linkHtml" type="StrucDoc.LinkHtml"/>
        <xsd:element name="sub" type="StrucDoc.Sub"/>
        <xsd:element name="sup" type="StrucDoc.Sup"/>
        <xsd:element name="content" type="StrucDoc.CMTitle"/>
      </xsd:choice>
    </xsd:sequence>
    <xsd:attributeGroup ref="StrucDoc.Base"/>
  </xsd:complexType>
  <xsd:complexType mixed="true" name="StrucDoc.TitleFootnote">
    <xsd:sequence>
      <xsd:choice maxOccurs="unbounded" minOccurs="0">
        <xsd:element name="footnote" type="StrucDoc.TitleFootnote"/>
        <xsd:element name="footnoteRef" type="StrucDoc.FootnoteRef"/>
        <xsd:element name="br" type="StrucDoc.Br"/>
        <xsd:element name="linkHtml" type="StrucDoc.LinkHtml"/>
        <xsd:element name="sub" type="StrucDoc.Sub"/>
        <xsd:element name="sup" type="StrucDoc.Sup"/>
        <xsd:element name="content" type="StrucDoc.CMTitle"/>
      </xsd:choice>
    </xsd:sequence>
    <xsd:attributeGroup ref="StrucDoc.Base"/>
  </xsd:complexType>
  <xsd:complexType mixed="true" name="StrucDoc.CMTitle">
    <xsd:sequence>
      <xsd:element minOccurs="0" name="footnote" type="StrucDoc.TitleFootnote"/>
      <xsd:element minOccurs="0" name="footnoteRef" type="StrucDoc.FootnoteRef"/>
      <xsd:element minOccurs="0" name="br" type="StrucDoc.Br"/>
      <xsd:element minOccurs="0" name="linkHtml" type="StrucDoc.LinkHtml"/>
      <xsd:element minOccurs="0" name="sub" type="StrucDoc.Sub"/>
      <xsd:element minOccurs="0" name="sup" type="StrucDoc.Sup"/>
      <xsd:element minOccurs="0" name="content" type="StrucDoc.CMTitle"/>
    </xsd:sequence>
  </xsd:complexType>
  <xsd:complexType name="SC">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="no code if no value">
          <sch:rule abstract="true" id="SC-0">
            <sch:assert test="not(@nullFlavor) or (not(code) or (code/@nullFlavor))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on SC attributes">
          <sch:rule abstract="true" id="SC-1">
            <sch:assert test="count(*[self::code][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no originalText">
          <sch:rule abstract="true" id="SC-2">
            <sch:assert test="(not(originalText) or not(oroginalText/@nullFlavor)) or (not(code) or (code/@nullFlavor))"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ST">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="code" type="CD"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="CD">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or code and/or originalText">
          <sch:rule abstract="true" id="CD-0">
            <sch:assert test="@nullFlavor or @code or (originalText and not(originalText/@nullFlavor) or (originalTextReference and not(originalTextReference/@nullFlavor))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="other requires codeSystem or valueSet">
          <sch:rule abstract="true" id="CD-1">
            <sch:assert test="@nullFlavor != &quot;OTH&quot; or @codeSystem or @valueSet"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="code requires codeSystem">
          <sch:rule abstract="true" id="CD-2">
            <sch:assert test="@codeSystem or not(@code)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="codeSystemName only if codeSystem">
          <sch:rule abstract="true" id="CD-3">
            <sch:assert test="@codeSystem or not(@codeSystemName)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="codeSystemVersion only if codeSystem">
          <sch:rule abstract="true" id="CD-4">
            <sch:assert test="@codeSystem or not(@codeSystemVersion)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="displayName only if code">
          <sch:rule abstract="true" id="CD-5">
            <sch:assert test="@code or not(@displayName)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="valueSet requires valueSetVersion">
          <sch:rule abstract="true" id="CD-6">
            <sch:assert test="not(@valueSet) or (@valueSet and @valueSetVersion)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="No original text on translations">
          <sch:rule abstract="true" id="CD-7">
            <sch:assert test="not translation/originalText"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="Translations cannot have translations">
          <sch:rule abstract="true" id="CD-8">
            <sch:assert test="not translation/translation"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on CD elements">
          <sch:rule abstract="true" id="CD-9">
            <sch:assert test="count(*[self::displayName or self::originalText or self::originalTextReference or self::translation][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no code if null">
          <sch:rule abstract="true" id="CD-10">
            <sch:assert test="not(@nullFlavor) or (not(thumbnail) or code\@nullFlavor)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no displayName if null">
          <sch:rule abstract="true" id="CD-11">
            <sch:assert test="not(@nullFlavor) or (@nullFlavor and not(@displayName))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no source if null">
          <sch:rule abstract="true" id="CD-12">
            <sch:assert test="not(@nullFlavor) or (@nullFlavor and not(@source))"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="displayName" type="ST"/>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="translation" type="CD"/>
          <xsd:element minOccurs="0" name="source" type="XReference"/>
        </xsd:sequence>
        <xsd:attribute name="code" type="xsd:string" use="optional"/>
        <xsd:attribute name="codeSystem" type="Uid" use="optional"/>
        <xsd:attribute name="codeSystemName" type="xsd:string" use="optional"/>
        <xsd:attribute name="codeSystemVersion" type="xsd:string" use="optional"/>
        <xsd:attribute name="valueSet" type="xsd:string" use="optional"/>
        <xsd:attribute name="valueSetVersion" type="xsd:string" use="optional"/>
        <xsd:attribute name="codingRationale" type="set_CodingRationale" use="optional"/>
        <xsd:attribute name="id" type="xsd:ID" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="XReference">
    <xsd:attribute name="xref" type="xsd:IDREF" use="required"/>
  </xsd:complexType>
  <xsd:complexType name="SC.NT">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="no translations">
          <sch:rule abstract="true" id="SC.NT-0">
            <sch:assert test="not(translation)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="SC">
        <xsd:sequence>
          <xsd:element maxOccurs="0" minOccurs="0" name="translation" type="ST.NT"/>
          <xsd:element minOccurs="0" name="code" type="CD"/>
        </xsd:sequence>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="TEL.EMAIL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="email only">
          <sch:rule abstract="true" id="TEL.EMAIL-0">
            <sch:assert test="starts-with(@value, &quot;mailto&quot;)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="TEL.PERSON">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="useablePeriod" type="QSET_TS"/>
        </xsd:sequence>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="TEL.PERSON">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="Personal Address">
          <sch:rule abstract="true" id="TEL.PERSON-0">
            <sch:assert test="starts-with(@value, &quot;tel&quot;) or starts-with(@value, &quot;x-text-fax&quot;) or starts-with(@value, &quot;x-text-tel&quot;) or starts-with(@value, &quot;mailto&quot;)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="TEL">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="useablePeriod" type="QSET_TS"/>
        </xsd:sequence>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="TEL.PHONE">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="Phone">
          <sch:rule abstract="true" id="TEL.PHONE-0">
            <sch:assert test="starts-with(@value, &quot;tel&quot;) or starts-with(@value, &quot;x-text-fax&quot;) or starts-with(@value, &quot;x-text-tel&quot;)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="TEL.PERSON">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="useablePeriod" type="QSET_TS"/>
        </xsd:sequence>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="II">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="root is required">
          <sch:rule abstract="true" id="II-0">
            <sch:assert test="@nullFlavor or (not(@nullFlavor) and @root)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no root if null">
          <sch:rule abstract="true" id="II-1">
            <sch:assert test="not(@nullFlavor) or (@nullFlavor and not(@root))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no extension if null">
          <sch:rule abstract="true" id="II-2">
            <sch:assert test="not(@nullFlavor) or (@nullFlavor and not(@extension))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no identifierName if null">
          <sch:rule abstract="true" id="II-3">
            <sch:assert test="not(@nullFlavor) or (@nullFlavor and not(@identifierName))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no displayable if null">
          <sch:rule abstract="true" id="II-4">
            <sch:assert test="not(@nullFlavor) or (@nullFlavor and not(@displayable))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no reliability if null">
          <sch:rule abstract="true" id="II-5">
            <sch:assert test="not(@nullFlavor) or (@nullFlavor and not(@reliability))"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:attribute name="root" type="Uid" use="optional"/>
        <xsd:attribute name="extension" type="xsd:string" use="optional"/>
        <xsd:attribute name="identifierName" type="xsd:string" use="optional"/>
        <xsd:attribute name="displayable" type="xsd:boolean" use="optional"/>
        <xsd:attribute name="scope" type="IdentifierScope" use="optional"/>
        <xsd:attribute name="reliability" type="IdentifierReliability" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="CD.CV">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="no translations">
          <sch:rule abstract="true" id="CD.CV-0">
            <sch:assert test="not(translation)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no source">
          <sch:rule abstract="true" id="CD.CV-1">
            <sch:assert test="not(@source)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="CD">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="displayName" type="ST"/>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="translation" type="CD"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="source" type="XReference"/>
        </xsd:sequence>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="CO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="must have a code or a value">
          <sch:rule abstract="true" id="CO-0">
            <sch:assert test="@nullFlavor or (@value or (code and not(code/@nullFlavor)))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="CO-1">
            <sch:assert test="count(*[self::code][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no value if null">
          <sch:rule abstract="true" id="CO-2">
            <sch:assert test="not(@nullFlavor) or (@nullFlavor and not(@value))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no code if null">
          <sch:rule abstract="true" id="CO-3">
            <sch:assert test="not(@nullFlavor) or (not code or code/@nullFlavor)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QTY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="code" type="CD"/>
        </xsd:sequence>
        <xsd:attribute name="value" type="xsd:double" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="QTY">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="uncertainty">
          <sch:rule abstract="true" id="QTY-0">
            <sch:assert test="not(uncertainty/@expression) and not(uncertainty/@uncertainty) and not(uncertainty/@originalText)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="QTY-1">
            <sch:assert test="count(*[self::originalText or self::uncertainty or self::expression][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="expression" type="ED"/>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element minOccurs="0" name="uncertainty" type="QTY"/>
        </xsd:sequence>
        <xsd:attribute name="uncertaintyType" type="UncertaintyType" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="CS">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="code is required">
          <sch:rule abstract="true" id="CS-0">
            <sch:assert test="@nullFlavor or (not(@nullFlavor) and @code)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no code if null">
          <sch:rule abstract="true" id="CS-1">
            <sch:assert test="not(@nullFlavor) or (@nullFlavor and not(@code))"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:attribute name="code" type="xsd:string" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="AD">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or parts">
          <sch:rule abstract="true" id="AD-0">
            <sch:assert test="(@nullFlavor or part) and not(@nullFlavor and part)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no useablePeriod if null">
          <sch:rule abstract="true" id="AD-1">
            <sch:assert test="not(@nullFlavor) or (not(thumbnail) or useablePeriod\@nullFlavor)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on AD attributes">
          <sch:rule abstract="true" id="AD-2">
            <sch:assert test="count(*[self::useablePeriod][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:choice maxOccurs="unbounded" minOccurs="0">
            <xsd:element name="part" type="ADXP"/>
            <xsd:element name="br" type="ADXP.BR"/>
            <xsd:element name="addressLine" type="ADXP.AL"/>
            <xsd:element name="additionalLocator" type="ADXP.ADL"/>
            <xsd:element name="unitID" type="ADXP.UNID"/>
            <xsd:element name="unitType" type="ADXP.UNIT"/>
            <xsd:element name="deliveryAddressLine" type="ADXP.DAL"/>
            <xsd:element name="deliveryInstallationType" type="ADXP.DINST"/>
            <xsd:element name="deliveryInstallationArea" type="ADXP.DINSTA"/>
            <xsd:element name="deliveryInstallationQualifier" type="ADXP.DINSTQ"/>
            <xsd:element name="deliveryMode" type="ADXP.DMOD"/>
            <xsd:element name="deliveryModeIdentifier" type="ADXP.DMODID"/>
            <xsd:element name="streetAddressLine" type="ADXP.SAL"/>
            <xsd:element name="houseNumber" type="ADXP.BNR"/>
            <xsd:element name="houseNumberNumeric" type="ADXP.BNN"/>
            <xsd:element name="buildingNumberSuffix" type="ADXP.BNS"/>
            <xsd:element name="streetName" type="ADXP.STR"/>
            <xsd:element name="streetNameBase" type="ADXP.STB"/>
            <xsd:element name="streetType" type="ADXP.STTYP"/>
            <xsd:element name="intersection" type="ADXP.INT"/>
            <xsd:element name="direction" type="ADXP.DIR"/>
            <xsd:element name="careOf" type="ADXP.CAR"/>
            <xsd:element name="censusTract" type="ADXP.CEN"/>
            <xsd:element name="country" type="ADXP.CNT"/>
            <xsd:element name="county" type="ADXP.CPA"/>
            <xsd:element name="city" type="ADXP.CTY"/>
            <xsd:element name="postBox" type="ADXP.POB"/>
            <xsd:element name="precinct" type="ADXP.PRE"/>
            <xsd:element name="state" type="ADXP.STA"/>
            <xsd:element name="postalCode" type="ADXP.ZIP"/>
          </xsd:choice>
          <xsd:element minOccurs="0" name="useablePeriod" type="QSET_TS"/>
        </xsd:sequence>
        <xsd:attribute name="use" type="set_PostalAddressUse" use="optional"/>
        <xsd:attribute name="isNotOrdered" type="xsd:boolean" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType mixed="true" name="ADXP">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="value is required">
          <sch:rule abstract="true" id="ADXP-0">
            <sch:assert test="string-length(@value) > 0"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="code requires codeSystem">
          <sch:rule abstract="true" id="ADXP-1">
            <sch:assert test="@codeSystem or not(@code)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="codeSystemVersion only if codeSystem">
          <sch:rule abstract="true" id="ADXP-2">
            <sch:assert test="@codeSystem or not(@codeSystemVersion)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:attribute name="code" type="xsd:string" use="optional"/>
    <xsd:attribute name="codeSystem" type="xsd:string" use="optional"/>
    <xsd:attribute name="codeSystemVersion" type="xsd:string" use="optional"/>
    <xsd:attribute name="language" type="Code" use="optional"/>
    <xsd:attribute name="type" type="AddressPartType" use="optional"/>
  </xsd:complexType>
  <xsd:complexType name="ADXP.BR">
    <xsd:complexContent>
      <xsd:restriction base="ADXP">
        <xsd:attribute fixed="DEL" name="type" type="AddressPartType"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ADXP.AL">
    <xsd:complexContent>
      <xsd:restriction base="ADXP">
        <xsd:attribute fixed="AL" name="type" type="AddressPartType"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ADXP.ADL">
    <xsd:complexContent>
      <xsd:restriction base="ADXP">
        <xsd:attribute fixed="ADL" name="type" type="AddressPartType"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ADXP.UNID">
    <xsd:complexContent>
      <xsd:restriction base="ADXP">
        <xsd:attribute fixed="UNID" name="type" type="AddressPartType"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ADXP.UNIT">
    <xsd:complexContent>
      <xsd:restriction base="ADXP">
        <xsd:attribute fixed="UNIT" name="type" type="AddressPartType"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ADXP.DAL">
    <xsd:complexContent>
      <xsd:restriction base="ADXP">
        <xsd:attribute fixed="DAL" name="type" type="AddressPartType"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ADXP.DINST">
    <xsd:complexContent>
      <xsd:restriction base="ADXP">
        <xsd:attribute fixed="DINST" name="type" type="AddressPartType"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ADXP.DINSTA">
    <xsd:complexContent>
      <xsd:restriction base="ADXP">
        <xsd:attribute fixed="DINSTA" name="type" type="AddressPartType"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ADXP.DINSTQ">
    <xsd:complexContent>
      <xsd:restriction base="ADXP">
        <xsd:attribute fixed="DINSTQ" name="type" type="AddressPartType"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ADXP.DMOD">
    <xsd:complexContent>
      <xsd:restriction base="ADXP">
        <xsd:attribute fixed="DMOD" name="type" type="AddressPartType"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ADXP.DMODID">
    <xsd:complexContent>
      <xsd:restriction base="ADXP">
        <xsd:attribute fixed="DMODID" name="type" type="AddressPartType"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ADXP.SAL">
    <xsd:complexContent>
      <xsd:restriction base="ADXP">
        <xsd:attribute fixed="SAL" name="type" type="AddressPartType"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ADXP.BNR">
    <xsd:complexContent>
      <xsd:restriction base="ADXP">
        <xsd:attribute fixed="BNR" name="type" type="AddressPartType"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ADXP.BNN">
    <xsd:complexContent>
      <xsd:restriction base="ADXP">
        <xsd:attribute fixed="BNN" name="type" type="AddressPartType"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ADXP.BNS">
    <xsd:complexContent>
      <xsd:restriction base="ADXP">
        <xsd:attribute fixed="BNS" name="type" type="AddressPartType"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ADXP.STR">
    <xsd:complexContent>
      <xsd:restriction base="ADXP">
        <xsd:attribute fixed="STR" name="type" type="AddressPartType"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ADXP.STB">
    <xsd:complexContent>
      <xsd:restriction base="ADXP">
        <xsd:attribute fixed="STB" name="type" type="AddressPartType"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ADXP.STTYP">
    <xsd:complexContent>
      <xsd:restriction base="ADXP">
        <xsd:attribute fixed="STTYP" name="type" type="AddressPartType"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ADXP.INT">
    <xsd:complexContent>
      <xsd:restriction base="ADXP">
        <xsd:attribute fixed="INT" name="type" type="AddressPartType"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ADXP.DIR">
    <xsd:complexContent>
      <xsd:restriction base="ADXP">
        <xsd:attribute fixed="DIR" name="type" type="AddressPartType"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ADXP.CAR">
    <xsd:complexContent>
      <xsd:restriction base="ADXP">
        <xsd:attribute fixed="CAR" name="type" type="AddressPartType"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ADXP.CEN">
    <xsd:complexContent>
      <xsd:restriction base="ADXP">
        <xsd:attribute fixed="CEN" name="type" type="AddressPartType"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ADXP.CNT">
    <xsd:complexContent>
      <xsd:restriction base="ADXP">
        <xsd:attribute fixed="CNT" name="type" type="AddressPartType"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ADXP.CPA">
    <xsd:complexContent>
      <xsd:restriction base="ADXP">
        <xsd:attribute fixed="CPA" name="type" type="AddressPartType"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ADXP.CTY">
    <xsd:complexContent>
      <xsd:restriction base="ADXP">
        <xsd:attribute fixed="CTY" name="type" type="AddressPartType"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ADXP.POB">
    <xsd:complexContent>
      <xsd:restriction base="ADXP">
        <xsd:attribute fixed="POB" name="type" type="AddressPartType"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ADXP.PRE">
    <xsd:complexContent>
      <xsd:restriction base="ADXP">
        <xsd:attribute fixed="PRE" name="type" type="AddressPartType"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ADXP.STA">
    <xsd:complexContent>
      <xsd:restriction base="ADXP">
        <xsd:attribute fixed="STA" name="type" type="AddressPartType"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ADXP.ZIP">
    <xsd:complexContent>
      <xsd:restriction base="ADXP">
        <xsd:attribute fixed="ZIP" name="type" type="AddressPartType"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="EN">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or parts">
          <sch:rule abstract="true" id="EN-0">
            <sch:assert test="(@nullFlavor or part) and not(@nullFlavor and part)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="part" type="ENXP"/>
        </xsd:sequence>
        <xsd:attribute name="use" type="set_EntityNameUse" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ENXP">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="value is required">
          <sch:rule abstract="true" id="ENXP-0">
            <sch:assert test="string-length(@value) > 0"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="code requires codeSystem">
          <sch:rule abstract="true" id="ENXP-1">
            <sch:assert test="@codeSystem or not(@code)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="codeSystemVersion only if codeSystem">
          <sch:rule abstract="true" id="ENXP-2">
            © 229
ISO 2008  All rights reserved
            <sch:assert test="@codeSystem or not(@codeSystemVersion)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:attribute name="value" type="xsd:string" use="optional"/>
    <xsd:attribute name="code" type="xsd:string" use="optional"/>
    <xsd:attribute name="codeSystem" type="xsd:string" use="optional"/>
    <xsd:attribute name="codeSystemVersion" type="xsd:string" use="optional"/>
    <xsd:attribute name="language" type="Code" use="optional"/>
    <xsd:attribute name="type" type="EntityNamePartType" use="optional"/>
    <xsd:attribute name="qualifier" type="set_EntityNamePartQualifier" use="optional"/>
  </xsd:complexType>
  <xsd:complexType name="EN.TN">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="only one part with no type">
          <sch:rule abstract="true" id="EN.TN-0">
            <sch:assert test="@nullFlavor or (count(part) = 1 and not part/@type)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="EN"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="EN.PN">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="no parts are qualified by LS">
          <sch:rule abstract="true" id="EN.PN-0">
            <sch:assert test="count(part[contains(@qualifier, 'LS')])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="EN"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="EN.ON">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="no parts are person types">
          <sch:rule abstract="true" id="EN.ON-0">
            <sch:assert test="count(part[type = 'FAM' or type = 'GIV'])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="EN"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="TS">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or value">
          <sch:rule abstract="true" id="TS-0">
            <sch:assert test="(@nullFlavor or @value) and not(@nullFlavor and @value)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QTY">
        <xsd:attribute name="value" use="optional">
          <xsd:simpleType>
            <xsd:restriction base="xsd:string">
              <xsd:pattern value="[1-2][0-9]{3,3}(((0[1-9])|(1[0-2]))(((0[1-9])|([1-2][0-9]|3[0-1]))(([0-1][0-9]|2[0-3])([0-5][0-9]([0-5][0-9](\.[0-9]{1,4})?)?)?)?)?)?([+\-](0[0-9]|1[0-3])([0-5][0-9]))?"/>
              <!--Svensk rättning: Original string<xsd:pattern value="[1-2][0-9]{3,3}(((0[1-9])|(1[0-2]))((0[1-9])|([1-2][0-9]|3[0-1])(([0-1][0-9]|2[0-3])([0-5][0-9]([0-5][0-9](\.[0-9]{1,4})?)?)?)?)?)?([+\-](0[0-9]|1[0-3])([0-5][0-9]))?"/>-->
            </xsd:restriction>
          </xsd:simpleType>
        </xsd:attribute>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="TS.DATE">
    <xsd:complexContent>
      <xsd:restriction base="TS">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="expression" type="ED"/>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element minOccurs="0" name="uncertainty" type="QTY"/>
        </xsd:sequence>
      </xsd:restriction>
      <!--<xsd:attribute name="value" use="optional">
					<xsd:simpleType>
						<xsd:restriction base="xsd:string">
							<xsd:pattern value="[1-2][0-9]{3,3}((0[1-9])|(1[0-2])((0[1-9])|([1-2][0-9]|3[0-1]))?)?"/>
						</xsd:restriction>
					</xsd:simpleType>
				</xsd:attribute>-->
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="TS.DATE.FULL">
    <xsd:complexContent>
      <xsd:restriction base="TS.DATE">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="expression" type="ED"/>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element minOccurs="0" name="uncertainty" type="QTY"/>
        </xsd:sequence>
      </xsd:restriction>
      <!--<xsd:attribute name="value" use="optional">
					<xsd:simpleType>
						<xsd:restriction base="xsd:string">
							<xsd:pattern value="([1-2][0-9]{3,3}(0[1-9])|(1[0-2]))(0[1-9])|([1-2][0-9]|3[0-1])"/>
						</xsd:restriction>
					</xsd:simpleType>
				</xsd:attribute>-->
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="TS.DATETIME">
    <xsd:complexContent>
      <xsd:restriction base="TS">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="expression" type="ED"/>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element minOccurs="0" name="uncertainty" type="QTY"/>
        </xsd:sequence>
      </xsd:restriction>
      <!--<xsd:attribute name="value" use="optional">
					<xsd:simpleType>
						<xsd:restriction base="xsd:string">
							<xsd:pattern value="[1-2][0-9]{3,3}(((0[1-9])|(1[0-2]))((0[1-9])|([1-2][0-9]|3[0-1])(([0-1][0-9]|2[0-3])([0-5][0-9]([0-5][0-9])?)?)?)?)?([+\-](0[0-9]|1[0-3])([0-5][0-9]))?"/>
						</xsd:restriction>
					</xsd:simpleType>
				</xsd:attribute>-->
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="TS.DATETIME.FULL">
    <xsd:complexContent>
      <xsd:restriction base="TS.DATETIME">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="expression" type="ED"/>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element minOccurs="0" name="uncertainty" type="QTY"/>
        </xsd:sequence>
      </xsd:restriction>
      <!--<xsd:attribute name="value" use="optional">
					<xsd:simpleType>
						<xsd:restriction base="xsd:string">
							<xsd:pattern value="[1-2][0-9]{3,3}(0[1-9])|(1[0-2])(0[1-9])|([1-2][0-9]|3[0-1])([0-1][0-9]|2[0-3])[0-5][0-9][0-5][0-9]([+\-](0[0-9]|1[0-3])([0-5][0-9]))?"/>
						</xsd:restriction>
					</xsd:simpleType>
				</xsd:attribute>-->
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="TS.BIRTH">
    <xsd:complexContent>
      <xsd:restriction base="TS">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="expression" type="ED"/>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element minOccurs="0" name="uncertainty" type="QTY"/>
        </xsd:sequence>
      </xsd:restriction>
      <!--<xsd:attribute name="value" use="optional">
					<xsd:simpleType>
						<xsd:restriction base="xsd:string">
							<xsd:pattern value="[1-2][0-9]{3,3}(((0[1-9])|(1[0-2]))(0[1-9])|([1-2][0-9]|3[0-1])(([0-1][0-9]|2[0-3])([0-5][0-9]([0-5][0-9]))[+\-](0[0-9]|1[0-3])([0-5][0-9]))?)?"/>
						</xsd:restriction>
					</xsd:simpleType>
				</xsd:attribute>-->
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="RTO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="numerator and denominator required">
          <sch:rule abstract="true" id="RTO-0">
            <sch:assert test="@nullFlavor or ((numerator and not(numerator/@nullFlavor)) and (numerator and not(numerator/@nullFlavor)))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on RTO Attributes">
          <sch:rule abstract="true" id="RTO-1">
            <sch:assert test="count(*[self::numerator or self::denominator][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no uncertainty">
          <sch:rule abstract="true" id="RTO-2">
            <sch:assert test="not(uncertainty)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QTY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="numerator" type="QTY"/>
          <xsd:element minOccurs="0" name="denominator" type="QTY"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="MO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or value">
          <sch:rule abstract="true" id="MO-0">
            <sch:assert test="(@nullFlavor or @value) and not(@nullFlavor and @value)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="null or currency">
          <sch:rule abstract="true" id="MO-1">
            <sch:assert test="(@nullFlavor or @currency) and not(@nullFlavor and @currency)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no precision if null">
          <sch:rule abstract="true" id="MO-2">
            <sch:assert test="not(@nullFlavor) or (@nullFlavor and not(@precision))"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QTY">
        <xsd:attribute name="value" type="xsd:double" use="optional"/>
        <xsd:attribute name="precision" type="xsd:int" use="optional"/>
        <xsd:attribute name="currency" type="Code" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="PQ">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="no translation if null">
          <sch:rule abstract="true" id="PQ-0">
            <sch:assert test="not(@nullFlavor) or (@nullFlavor and not(@translation))"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="PQV">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="translation" type="PQR"/>
        </xsd:sequence>
        <xsd:attribute name="unit" type="Code" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="PQV">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or value">
          <sch:rule abstract="true" id="PQV-0">
            <sch:assert test="(@nullFlavor or @value) and not(@nullFlavor and @value)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no precision if null">
          <sch:rule abstract="true" id="PQV-1">
            <sch:assert test="not(@nullFlavor) or (@nullFlavor and not(@precision))"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QTY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="source" type="XReference"/>
        </xsd:sequence>
        <xsd:attribute name="value" type="xsd:double" use="optional"/>
        <xsd:attribute default="0" name="precision" type="xsd:int" use="optional"/>
        <xsd:attribute name="codingRationale" type="set_CodingRationale" use="optional"/>
        <xsd:attribute name="id" type="xsd:ID" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="PQR">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or unit">
          <sch:rule abstract="true" id="PQR-0">
            <sch:assert test="todo"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no originalText">
          <sch:rule abstract="true" id="PQR-1">
            <sch:assert test="not(@originalText)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on PQR">
          <sch:rule abstract="true" id="PQR-2">
            <sch:assert test="not(@validTimeLow) and not(@validTimeHigh) and not(@controlActRoot) and not(@controlActExtension) and not(@updateMode)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="PQV">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="unit" type="CD.CV"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="PQ.TIME">
    <xsd:complexContent>
      <xsd:restriction base="PQ">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="expression" type="ED"/>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element minOccurs="0" name="uncertainty" type="QTY"/>
          <xsd:element minOccurs="0" name="source" type="XReference"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="translation" type="PQR"/>
        </xsd:sequence>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="REAL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or value">
          <sch:rule abstract="true" id="REAL-0">
            <sch:assert test="(@nullFlavor or @value) and not(@nullFlavor and @value)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no precision if null">
          <sch:rule abstract="true" id="REAL-1">
            <sch:assert test="not(@nullFlavor) or (@nullFlavor and not(@precision))"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QTY">
        <xsd:attribute name="value" type="xsd:double" use="optional"/>
        <xsd:attribute default="0" name="precision" type="xsd:int" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="INT">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="no uncertainty">
          <sch:rule abstract="true" id="INT-0">
            <sch:assert test="not(uncertainty)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="null or value">
          <sch:rule abstract="true" id="INT-1">
            <sch:assert test="(@nullFlavor or @value) and not(@nullFlavor and @value)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QTY">
        <xsd:attribute name="value" type="xsd:int" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="INT.NONNEG">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not negative">
          <sch:rule abstract="true" id="INT.NONNEG-0">
            <sch:assert test="(@nullFlavor) or (@value >= 0)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="INT">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="expression" type="ED"/>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element minOccurs="0" name="uncertainty" type="QTY"/>
        </xsd:sequence>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="INT.POS">
    <xsd:complexContent>
      <xsd:restriction base="INT.NONNEG">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="expression" type="ED"/>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element minOccurs="0" name="uncertainty" type="QTY"/>
        </xsd:sequence>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="DSET_BL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="DSET_BL-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_BL">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="BL"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="COLL_BL">
    <xsd:complexContent>
      <xsd:extension base="ANY"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="DSET_BL.NONNULL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="DSET_BL.NONNULL-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
        © 235
ISO 2008  All rights reserved
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_BL.NONNULL">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="BL.NONNULL"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="COLL_BL.NONNULL">
    <xsd:complexContent>
      <xsd:extension base="ANY"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="DSET_ED">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="DSET_ED-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_ED">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="ED"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="COLL_ED">
    <xsd:complexContent>
      <xsd:extension base="ANY"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="DSET_ED.IMAGE">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="DSET_ED.IMAGE-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_ED.IMAGE">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="ED.IMAGE"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="COLL_ED.IMAGE">
    <xsd:complexContent>
      <xsd:extension base="ANY"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="DSET_ED.TEXT">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="DSET_ED.TEXT-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_ED.TEXT">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="ED.TEXT"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="COLL_ED.TEXT">
    <xsd:complexContent>
      <xsd:extension base="ANY"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="DSET_ED.DOC">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="DSET_ED.DOC-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_ED.DOC">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="ED.DOC"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="COLL_ED.DOC">
    <xsd:complexContent>
      <xsd:extension base="ANY"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="DSET_ED.DOC.REF">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="DSET_ED.DOC.REF-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_ED.DOC.REF">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="ED.DOC.REF"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="COLL_ED.DOC.REF">
    <xsd:complexContent>
      <xsd:extension base="ANY"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="DSET_ED.DOC.INLINE">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="DSET_ED.DOC.INLINE-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_ED.DOC.INLINE">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="ED.DOC.INLINE"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="COLL_ED.DOC.INLINE">
    <xsd:complexContent>
      <xsd:extension base="ANY"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="DSET_ED.SIGNATURE">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="DSET_ED.SIGNATURE-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_ED.SIGNATURE">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="ED.SIGNATURE"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="COLL_ED.SIGNATURE">
    <xsd:complexContent>
      <xsd:extension base="ANY"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="DSET_ED.STRUCTUREDTEXT">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="DSET_ED.STRUCTUREDTEXT-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_ED.STRUCTUREDTEXT">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="ED.STRUCTUREDTEXT"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="COLL_ED.STRUCTUREDTEXT">
    <xsd:complexContent>
      <xsd:extension base="ANY"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="DSET_ED.STRUCTUREDTITLE">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="DSET_ED.STRUCTUREDTITLE-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_ED.STRUCTUREDTITLE">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="ED.STRUCTUREDTITLE"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="COLL_ED.STRUCTUREDTITLE">
    <xsd:complexContent>
      <xsd:extension base="ANY"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="DSET_ST">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="DSET_ST-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_ST">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="ST"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="COLL_ST">
    <xsd:complexContent>
      <xsd:extension base="ANY"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="DSET_ST.NT">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="DSET_ST.NT-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_ST.NT">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="ST.NT"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="COLL_ST.NT">
    <xsd:complexContent>
      <xsd:extension base="ANY"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="DSET_SC">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="DSET_SC-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_SC">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="SC"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="COLL_SC">
    <xsd:complexContent>
      <xsd:extension base="ANY"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="DSET_SC.NT">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="DSET_SC.NT-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_SC.NT">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="SC.NT"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="COLL_SC.NT">
    <xsd:complexContent>
      <xsd:extension base="ANY"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="DSET_TEL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="DSET_TEL-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_TEL">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="TEL"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="COLL_TEL">
    <xsd:complexContent>
      <xsd:extension base="ANY"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="DSET_TEL.EMAIL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="DSET_TEL.EMAIL-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_TEL.EMAIL">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="TEL.EMAIL"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="COLL_TEL.EMAIL">
    <xsd:complexContent>
      <xsd:extension base="ANY"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="DSET_TEL.PERSON">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="DSET_TEL.PERSON-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_TEL.PERSON">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="TEL.PERSON"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="COLL_TEL.PERSON">
    <xsd:complexContent>
      <xsd:extension base="ANY"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="DSET_TEL.PHONE">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="DSET_TEL.PHONE-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_TEL.PHONE">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="TEL.PHONE"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="COLL_TEL.PHONE">
    <xsd:complexContent>
      <xsd:extension base="ANY"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="DSET_TEL.URL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="DSET_TEL.URL-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_TEL.URL">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="TEL.URL"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="COLL_TEL.URL">
    <xsd:complexContent>
      <xsd:extension base="ANY"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="DSET_II">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="DSET_II-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_II">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="II"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="COLL_II">
    <xsd:complexContent>
      <xsd:extension base="ANY"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="DSET_CD">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="DSET_CD-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_CD">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="CD"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="COLL_CD">
    <xsd:complexContent>
      <xsd:extension base="ANY"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="DSET_CD.CV">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="DSET_CD.CV-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_CD.CV">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="CD.CV"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="COLL_CD.CV">
    <xsd:complexContent>
      <xsd:extension base="ANY"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="DSET_CO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="DSET_CO-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_CO">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="CO"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="COLL_CO">
    <xsd:complexContent>
      <xsd:extension base="ANY"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="DSET_CS">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="DSET_CS-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_CS">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="CS"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="COLL_CS">
    <xsd:complexContent>
      <xsd:extension base="ANY"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="DSET_AD">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="DSET_AD-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_AD">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="AD"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="COLL_AD">
    <xsd:complexContent>
      <xsd:extension base="ANY"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="DSET_EN">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="DSET_EN-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_EN">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="EN"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="COLL_EN">
    <xsd:complexContent>
      <xsd:extension base="ANY"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="DSET_EN.TN">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="DSET_EN.TN-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_EN.TN">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="EN.TN"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="COLL_EN.TN">
    <xsd:complexContent>
      <xsd:extension base="ANY"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="DSET_EN.PN">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="DSET_EN.PN-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_EN.PN">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="EN.PN"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="COLL_EN.PN">
    <xsd:complexContent>
      <xsd:extension base="ANY"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="DSET_EN.ON">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="DSET_EN.ON-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_EN.ON">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="EN.ON"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="COLL_EN.ON">
    <xsd:complexContent>
      <xsd:extension base="ANY"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="DSET_TS">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="DSET_TS-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_TS">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="TS"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="COLL_TS">
    <xsd:complexContent>
      <xsd:extension base="ANY"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="DSET_TS.DATE">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="DSET_TS.DATE-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_TS.DATE">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="TS.DATE"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="COLL_TS.DATE">
    <xsd:complexContent>
      <xsd:extension base="ANY"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="DSET_TS.DATE.FULL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="DSET_TS.DATE.FULL-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_TS.DATE.FULL">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="TS.DATE.FULL"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="COLL_TS.DATE.FULL">
    <xsd:complexContent>
      <xsd:extension base="ANY"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="DSET_TS.DATETIME">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="DSET_TS.DATETIME-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_TS.DATETIME">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="TS.DATETIME"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="COLL_TS.DATETIME">
    <xsd:complexContent>
      <xsd:extension base="ANY"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="DSET_TS.DATETIME.FULL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="DSET_TS.DATETIME.FULL-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_TS.DATETIME.FULL">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="TS.DATETIME.FULL"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="COLL_TS.DATETIME.FULL">
    <xsd:complexContent>
      <xsd:extension base="ANY"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="DSET_TS.BIRTH">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="DSET_TS.BIRTH-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_TS.BIRTH">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="TS.BIRTH"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="COLL_TS.BIRTH">
    <xsd:complexContent>
      <xsd:extension base="ANY"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="DSET_RTO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="DSET_RTO-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_RTO">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="RTO"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="COLL_RTO">
    <xsd:complexContent>
      <xsd:extension base="ANY"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="DSET_MO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="DSET_MO-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_MO">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="MO"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="COLL_MO">
    <xsd:complexContent>
      <xsd:extension base="ANY"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="DSET_PQ">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="DSET_PQ-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_PQ">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="PQ"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="COLL_PQ">
    <xsd:complexContent>
      <xsd:extension base="ANY"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="DSET_PQ.TIME">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="DSET_PQ.TIME-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_PQ.TIME">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="PQ.TIME"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="COLL_PQ.TIME">
    <xsd:complexContent>
      <xsd:extension base="ANY"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="DSET_REAL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="DSET_REAL-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_REAL">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="REAL"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="COLL_REAL">
    <xsd:complexContent>
      <xsd:extension base="ANY"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="DSET_INT">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="DSET_INT-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_INT">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="INT"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="COLL_INT">
    <xsd:complexContent>
      <xsd:extension base="ANY"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="DSET_INT.NONNEG">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="DSET_INT.NONNEG-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_INT.NONNEG">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="INT.NONNEG"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="COLL_INT.NONNEG">
    <xsd:complexContent>
      <xsd:extension base="ANY"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="DSET_INT.POS">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="DSET_INT.POS-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_INT.POS">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="INT.POS"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="COLL_INT.POS">
    <xsd:complexContent>
      <xsd:extension base="ANY"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="BAG_BL">
    <xsd:complexContent>
      <xsd:extension base="COLL_BL">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="BL"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="BAG_BL.NONNULL">
    <xsd:complexContent>
      <xsd:extension base="COLL_BL.NONNULL">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="BL.NONNULL"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="BAG_ED">
    <xsd:complexContent>
      <xsd:extension base="COLL_ED">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="ED"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="BAG_ED.IMAGE">
    <xsd:complexContent>
      <xsd:extension base="COLL_ED.IMAGE">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="ED.IMAGE"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="BAG_ED.TEXT">
    <xsd:complexContent>
      <xsd:extension base="COLL_ED.TEXT">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="ED.TEXT"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="BAG_ED.DOC">
    <xsd:complexContent>
      <xsd:extension base="COLL_ED.DOC">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="ED.DOC"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="BAG_ED.DOC.REF">
    <xsd:complexContent>
      <xsd:extension base="COLL_ED.DOC.REF">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="ED.DOC.REF"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="BAG_ED.DOC.INLINE">
    <xsd:complexContent>
      <xsd:extension base="COLL_ED.DOC.INLINE">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="ED.DOC.INLINE"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="BAG_ED.SIGNATURE">
    <xsd:complexContent>
      <xsd:extension base="COLL_ED.SIGNATURE">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="ED.SIGNATURE"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="BAG_ED.STRUCTUREDTEXT">
    <xsd:complexContent>
      <xsd:extension base="COLL_ED.STRUCTUREDTEXT">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="ED.STRUCTUREDTEXT"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="BAG_ED.STRUCTUREDTITLE">
    <xsd:complexContent>
      <xsd:extension base="COLL_ED.STRUCTUREDTITLE">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="ED.STRUCTUREDTITLE"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="BAG_ST">
    <xsd:complexContent>
      <xsd:extension base="COLL_ST">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="ST"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="BAG_ST.NT">
    <xsd:complexContent>
      <xsd:extension base="COLL_ST.NT">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="ST.NT"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="BAG_SC">
    <xsd:complexContent>
      <xsd:extension base="COLL_SC">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="SC"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="BAG_SC.NT">
    <xsd:complexContent>
      <xsd:extension base="COLL_SC.NT">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="SC.NT"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="BAG_TEL">
    <xsd:complexContent>
      <xsd:extension base="COLL_TEL">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="TEL"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="BAG_TEL.EMAIL">
    <xsd:complexContent>
      <xsd:extension base="COLL_TEL.EMAIL">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="TEL.EMAIL"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="BAG_TEL.PERSON">
    <xsd:complexContent>
      <xsd:extension base="COLL_TEL.PERSON">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="TEL.PERSON"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="BAG_TEL.PHONE">
    <xsd:complexContent>
      <xsd:extension base="COLL_TEL.PHONE">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="TEL.PHONE"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="BAG_TEL.URL">
    <xsd:complexContent>
      <xsd:extension base="COLL_TEL.URL">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="TEL.URL"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="BAG_II">
    <xsd:complexContent>
      <xsd:extension base="COLL_II">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="II"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="BAG_CD">
    <xsd:complexContent>
      <xsd:extension base="COLL_CD">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="CD"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="BAG_CD.CV">
    <xsd:complexContent>
      <xsd:extension base="COLL_CD.CV">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="CD.CV"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="BAG_CO">
    <xsd:complexContent>
      <xsd:extension base="COLL_CO">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="CO"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="BAG_CS">
    <xsd:complexContent>
      <xsd:extension base="COLL_CS">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="CS"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="BAG_AD">
    <xsd:complexContent>
      <xsd:extension base="COLL_AD">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="AD"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="BAG_EN">
    <xsd:complexContent>
      <xsd:extension base="COLL_EN">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="EN"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="BAG_EN.TN">
    <xsd:complexContent>
      <xsd:extension base="COLL_EN.TN">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="EN.TN"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="BAG_EN.PN">
    <xsd:complexContent>
      <xsd:extension base="COLL_EN.PN">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="EN.PN"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="BAG_EN.ON">
    <xsd:complexContent>
      <xsd:extension base="COLL_EN.ON">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="EN.ON"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="BAG_TS">
    <xsd:complexContent>
      <xsd:extension base="COLL_TS">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="TS"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="BAG_TS.DATE">
    <xsd:complexContent>
      <xsd:extension base="COLL_TS.DATE">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="TS.DATE"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="BAG_TS.DATE.FULL">
    <xsd:complexContent>
      <xsd:extension base="COLL_TS.DATE.FULL">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="TS.DATE.FULL"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="BAG_TS.DATETIME">
    <xsd:complexContent>
      <xsd:extension base="COLL_TS.DATETIME">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="TS.DATETIME"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="BAG_TS.DATETIME.FULL">
    <xsd:complexContent>
      <xsd:extension base="COLL_TS.DATETIME.FULL">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="TS.DATETIME.FULL"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="BAG_TS.BIRTH">
    <xsd:complexContent>
      <xsd:extension base="COLL_TS.BIRTH">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="TS.BIRTH"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="BAG_RTO">
    <xsd:complexContent>
      <xsd:extension base="COLL_RTO">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="RTO"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="BAG_MO">
    <xsd:complexContent>
      <xsd:extension base="COLL_MO">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="MO"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="BAG_PQ">
    <xsd:complexContent>
      <xsd:extension base="COLL_PQ">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="PQ"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="BAG_PQ.TIME">
    <xsd:complexContent>
      <xsd:extension base="COLL_PQ.TIME">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="PQ.TIME"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="BAG_REAL">
    <xsd:complexContent>
      <xsd:extension base="COLL_REAL">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="REAL"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="BAG_INT">
    <xsd:complexContent>
      <xsd:extension base="COLL_INT">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="INT"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="BAG_INT.NONNEG">
    <xsd:complexContent>
      <xsd:extension base="COLL_INT.NONNEG">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="INT.NONNEG"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="BAG_INT.POS">
    <xsd:complexContent>
      <xsd:extension base="COLL_INT.POS">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="INT.POS"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="LIST_BL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="LIST_BL-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="BL"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="LIST_BL.NONNULL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="LIST_BL.NONNULL-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="BL.NONNULL"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="LIST_ED">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="LIST_ED-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="ED"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="LIST_ED.IMAGE">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="LIST_ED.IMAGE-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="ED.IMAGE"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="LIST_ED.TEXT">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="LIST_ED.TEXT-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="ED.TEXT"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="LIST_ED.DOC">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="LIST_ED.DOC-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="ED.DOC"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="LIST_ED.DOC.REF">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="LIST_ED.DOC.REF-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="ED.DOC.REF"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="LIST_ED.DOC.INLINE">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="LIST_ED.DOC.INLINE-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="ED.DOC.INLINE"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="LIST_ED.SIGNATURE">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="LIST_ED.SIGNATURE-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="ED.SIGNATURE"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="LIST_ED.STRUCTUREDTEXT">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="LIST_ED.STRUCTUREDTEXT-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="ED.STRUCTUREDTEXT"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="LIST_ED.STRUCTUREDTITLE">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="LIST_ED.STRUCTUREDTITLE-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="ED.STRUCTUREDTITLE"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="LIST_ST">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="LIST_ST-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="ST"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="LIST_ST.NT">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="LIST_ST.NT-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="ST.NT"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="LIST_SC">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="LIST_SC-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="SC"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="LIST_SC.NT">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="LIST_SC.NT-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="SC.NT"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="LIST_TEL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="LIST_TEL-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="TEL"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="LIST_TEL.EMAIL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="LIST_TEL.EMAIL-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="TEL.EMAIL"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="LIST_TEL.PERSON">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="LIST_TEL.PERSON-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="TEL.PERSON"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="LIST_TEL.PHONE">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="LIST_TEL.PHONE-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="TEL.PHONE"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="LIST_TEL.URL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="LIST_TEL.URL-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="TEL.URL"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="LIST_II">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="LIST_II-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="II"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="LIST_CD">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="LIST_CD-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="CD"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="LIST_CD.CV">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="LIST_CD.CV-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="CD.CV"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="LIST_CO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="LIST_CO-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="CO"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="LIST_CS">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="LIST_CS-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="CS"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="LIST_AD">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="LIST_AD-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="AD"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="LIST_EN">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="LIST_EN-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="EN"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="LIST_EN.TN">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="LIST_EN.TN-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="EN.TN"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="LIST_EN.PN">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="LIST_EN.PN-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="EN.PN"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="LIST_EN.ON">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="LIST_EN.ON-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="EN.ON"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="LIST_TS">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="LIST_TS-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="TS"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="LIST_TS.DATE">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="LIST_TS.DATE-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="TS.DATE"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="LIST_TS.DATE.FULL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="LIST_TS.DATE.FULL-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="TS.DATE.FULL"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="LIST_TS.DATETIME">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="LIST_TS.DATETIME-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="TS.DATETIME"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="LIST_TS.DATETIME.FULL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="LIST_TS.DATETIME.FULL-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="TS.DATETIME.FULL"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="LIST_TS.BIRTH">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="LIST_TS.BIRTH-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="TS.BIRTH"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="LIST_RTO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="LIST_RTO-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="RTO"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="LIST_MO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="LIST_MO-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="MO"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="LIST_PQ">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="LIST_PQ-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="PQ"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="LIST_PQ.TIME">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="LIST_PQ.TIME-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="PQ.TIME"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="LIST_REAL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="LIST_REAL-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="REAL"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="LIST_INT">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="LIST_INT-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="INT"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="LIST_INT.NONNEG">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="LIST_INT.NONNEG-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="INT.NONNEG"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="LIST_INT.POS">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="LIST_INT.POS-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="INT.POS"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL_CO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null rules">
          <sch:rule abstract="true" id="IVL_CO-0">
            <sch:assert test="(@nullFlavor and not(any|low|high|width)) or (not(@nullFlavor) and (any|low|high|width))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="co-occurence rules">
          <sch:rule abstract="true" id="IVL_CO-1">
            <sch:assert test="(((any and not(any/@nullFlavor)) and not((low and not(low/@nullFlavor)) or (high and not(high/@nullFlavor)) or (width and not(width/@nullFlavor)))) or (not(any) or any/@nullFlavor)) and ((any and not(any/@nullFlavor)) or (not(any) or any/@nullFlavor) and (((width and not(width/@nullFlavor)) and (not(low) or low/@nullFlavor) and (not(high) or high/@nullFlavor))) or ((not(width) or width/@nullFlavor) and ((low and not(low/@nullFlavor)) or (high and not(high/@nullFlavor))))))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="closed attributes only if limited">
          <sch:rule abstract="true" id="IVL_CO-2">
            <sch:assert test="not(low and @lowClosed) and not(high and @highClosed)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on IVL attributes">
          <sch:rule abstract="true" id="IVL_CO-3">
            <sch:assert test="count(*[self::low or self::high or self::width][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_CO">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="low" type="CO"/>
          <xsd:element minOccurs="0" name="high" type="CO"/>
          <xsd:element minOccurs="0" name="width" type="QTY"/>
          <xsd:element minOccurs="0" name="any" type="CO"/>
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="optional"/>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="QSET_CO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="QSET_CO-0">
            <sch:assert test="count(*[self::originalText][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL_TS">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null rules">
          <sch:rule abstract="true" id="IVL_TS-0">
            <sch:assert test="(@nullFlavor and not(any|low|high|width)) or (not(@nullFlavor) and (any|low|high|width))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="co-occurence rules">
          <sch:rule abstract="true" id="IVL_TS-1">
            <sch:assert test="(((any and not(any/@nullFlavor)) and not((low and not(low/@nullFlavor)) or (high and not(high/@nullFlavor)) or (width and not(width/@nullFlavor)))) or (not(any) or any/@nullFlavor)) and ((any and not(any/@nullFlavor)) or (not(any) or any/@nullFlavor) and (((width and not(width/@nullFlavor)) and (not(low) or low/@nullFlavor) and (not(high) or high/@nullFlavor))) or ((not(width) or width/@nullFlavor) and ((low and not(low/@nullFlavor)) or (high and not(high/@nullFlavor))))))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="closed attributes only if limited">
          <sch:rule abstract="true" id="IVL_TS-2">
            <sch:assert test="not(low and @lowClosed) and not(high and @highClosed)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on IVL attributes">
          <sch:rule abstract="true" id="IVL_TS-3">
            <sch:assert test="count(*[self::low or self::high or self::width][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_TS">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="low" type="TS"/>
          <xsd:element minOccurs="0" name="high" type="TS"/>
          <xsd:element minOccurs="0" name="width" type="QTY"/>
          <xsd:element minOccurs="0" name="any" type="TS"/>
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="optional"/>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL_TS.DATE">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null rules">
          <sch:rule abstract="true" id="IVL_TS.DATE-0">
            <sch:assert test="(@nullFlavor and not(any|low|high|width)) or (not(@nullFlavor) and (any|low|high|width))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="co-occurence rules">
          <sch:rule abstract="true" id="IVL_TS.DATE-1">
            <sch:assert test="(((any and not(any/@nullFlavor)) and not((low and not(low/@nullFlavor)) or (high and not(high/@nullFlavor)) or (width and not(width/@nullFlavor)))) or (not(any) or any/@nullFlavor)) and ((any and not(any/@nullFlavor)) or (not(any) or any/@nullFlavor) and (((width and not(width/@nullFlavor)) and (not(low) or low/@nullFlavor) and (not(high) or high/@nullFlavor))) or ((not(width) or width/@nullFlavor) and ((low and not(low/@nullFlavor)) or (high and not(high/@nullFlavor))))))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="closed attributes only if limited">
          <sch:rule abstract="true" id="IVL_TS.DATE-2">
            <sch:assert test="not(low and @lowClosed) and not(high and @highClosed)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on IVL attributes">
          <sch:rule abstract="true" id="IVL_TS.DATE-3">
            <sch:assert test="count(*[self::low or self::high or self::width][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_TS.DATE">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="low" type="TS.DATE"/>
          <xsd:element minOccurs="0" name="high" type="TS.DATE"/>
          <xsd:element minOccurs="0" name="width" type="QTY"/>
          <xsd:element minOccurs="0" name="any" type="TS.DATE"/>
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="optional"/>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="QSET_TS.DATE">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="QSET_TS.DATE-0">
            <sch:assert test="count(*[self::originalText][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL_TS.DATE.FULL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null rules">
          <sch:rule abstract="true" id="IVL_TS.DATE.FULL-0">
            <sch:assert test="(@nullFlavor and not(any|low|high|width)) or (not(@nullFlavor) and (any|low|high|width))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="co-occurence rules">
          <sch:rule abstract="true" id="IVL_TS.DATE.FULL-1">
            <sch:assert test="(((any and not(any/@nullFlavor)) and not((low and not(low/@nullFlavor)) or (high and not(high/@nullFlavor)) or (width and not(width/@nullFlavor)))) or (not(any) or any/@nullFlavor)) and ((any and not(any/@nullFlavor)) or (not(any) or any/@nullFlavor) and (((width and not(width/@nullFlavor)) and (not(low) or low/@nullFlavor) and (not(high) or high/@nullFlavor))) or ((not(width) or width/@nullFlavor) and ((low and not(low/@nullFlavor)) or (high and not(high/@nullFlavor))))))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="closed attributes only if limited">
          <sch:rule abstract="true" id="IVL_TS.DATE.FULL-2">
            <sch:assert test="not(low and @lowClosed) and not(high and @highClosed)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on IVL attributes">
          <sch:rule abstract="true" id="IVL_TS.DATE.FULL-3">
            <sch:assert test="count(*[self::low or self::high or self::width][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_TS.DATE.FULL">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="low" type="TS.DATE.FULL"/>
          <xsd:element minOccurs="0" name="high" type="TS.DATE.FULL"/>
          <xsd:element minOccurs="0" name="width" type="QTY"/>
          <xsd:element minOccurs="0" name="any" type="TS.DATE.FULL"/>
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="optional"/>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="QSET_TS.DATE.FULL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="QSET_TS.DATE.FULL-0">
            <sch:assert test="count(*[self::originalText][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL_TS.DATETIME">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null rules">
          <sch:rule abstract="true" id="IVL_TS.DATETIME-0">
            <sch:assert test="(@nullFlavor and not(any|low|high|width)) or (not(@nullFlavor) and (any|low|high|width))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="co-occurence rules">
          <sch:rule abstract="true" id="IVL_TS.DATETIME-1">
            © 269
ISO 2008  All rights reserved
            <sch:assert test="(((any and not(any/@nullFlavor)) and not((low and not(low/@nullFlavor)) or (high and not(high/@nullFlavor)) or (width and not(width/@nullFlavor)))) or (not(any) or any/@nullFlavor)) and ((any and not(any/@nullFlavor)) or (not(any) or any/@nullFlavor) and (((width and not(width/@nullFlavor)) and (not(low) or low/@nullFlavor) and (not(high) or high/@nullFlavor))) or ((not(width) or width/@nullFlavor) and ((low and not(low/@nullFlavor)) or (high and not(high/@nullFlavor))))))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="closed attributes only if limited">
          <sch:rule abstract="true" id="IVL_TS.DATETIME-2">
            <sch:assert test="not(low and @lowClosed) and not(high and @highClosed)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on IVL attributes">
          <sch:rule abstract="true" id="IVL_TS.DATETIME-3">
            <sch:assert test="count(*[self::low or self::high or self::width][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_TS.DATETIME">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="low" type="TS.DATETIME"/>
          <xsd:element minOccurs="0" name="high" type="TS.DATETIME"/>
          <xsd:element minOccurs="0" name="width" type="QTY"/>
          <xsd:element minOccurs="0" name="any" type="TS.DATETIME"/>
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="optional"/>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="QSET_TS.DATETIME">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="QSET_TS.DATETIME-0">
            <sch:assert test="count(*[self::originalText][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL_TS.DATETIME.FULL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null rules">
          <sch:rule abstract="true" id="IVL_TS.DATETIME.FULL-0">
            <sch:assert test="(@nullFlavor and not(any|low|high|width)) or (not(@nullFlavor) and (any|low|high|width))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="co-occurence rules">
          <sch:rule abstract="true" id="IVL_TS.DATETIME.FULL-1">
            <sch:assert test="(((any and not(any/@nullFlavor)) and not((low and not(low/@nullFlavor)) or (high and not(high/@nullFlavor)) or (width and not(width/@nullFlavor)))) or (not(any) or any/@nullFlavor)) and ((any and not(any/@nullFlavor)) or (not(any) or any/@nullFlavor) and (((width and not(width/@nullFlavor)) and (not(low) or low/@nullFlavor) and (not(high) or high/@nullFlavor))) or ((not(width) or width/@nullFlavor) and ((low and not(low/@nullFlavor)) or (high and not(high/@nullFlavor))))))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="closed attributes only if limited">
          <sch:rule abstract="true" id="IVL_TS.DATETIME.FULL-2">
            <sch:assert test="not(low and @lowClosed) and not(high and @highClosed)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on IVL attributes">
          <sch:rule abstract="true" id="IVL_TS.DATETIME.FULL-3">
            <sch:assert test="count(*[self::low or self::high or self::width][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_TS.DATETIME.FULL">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="low" type="TS.DATETIME.FULL"/>
          <xsd:element minOccurs="0" name="high" type="TS.DATETIME.FULL"/>
          <xsd:element minOccurs="0" name="width" type="QTY"/>
          <xsd:element minOccurs="0" name="any" type="TS.DATETIME.FULL"/>
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="optional"/>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="QSET_TS.DATETIME.FULL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="QSET_TS.DATETIME.FULL-0">
            <sch:assert test="count(*[self::originalText][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL_TS.BIRTH">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null rules">
          <sch:rule abstract="true" id="IVL_TS.BIRTH-0">
            <sch:assert test="(@nullFlavor and not(any|low|high|width)) or (not(@nullFlavor) and (any|low|high|width))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="co-occurence rules">
          <sch:rule abstract="true" id="IVL_TS.BIRTH-1">
            <sch:assert test="(((any and not(any/@nullFlavor)) and not((low and not(low/@nullFlavor)) or (high and not(high/@nullFlavor)) or (width and not(width/@nullFlavor)))) or (not(any) or any/@nullFlavor)) and ((any and not(any/@nullFlavor)) or (not(any) or any/@nullFlavor) and (((width and not(width/@nullFlavor)) and (not(low) or low/@nullFlavor) and (not(high) or high/@nullFlavor))) or ((not(width) or width/@nullFlavor) and ((low and not(low/@nullFlavor)) or (high and not(high/@nullFlavor))))))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="closed attributes only if limited">
          <sch:rule abstract="true" id="IVL_TS.BIRTH-2">
            <sch:assert test="not(low and @lowClosed) and not(high and @highClosed)"/>
            © 271
ISO 2008  All rights reserved
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on IVL attributes">
          <sch:rule abstract="true" id="IVL_TS.BIRTH-3">
            <sch:assert test="count(*[self::low or self::high or self::width][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_TS.BIRTH">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="low" type="TS.BIRTH"/>
          <xsd:element minOccurs="0" name="high" type="TS.BIRTH"/>
          <xsd:element minOccurs="0" name="width" type="QTY"/>
          <xsd:element minOccurs="0" name="any" type="TS.BIRTH"/>
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="optional"/>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="QSET_TS.BIRTH">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="QSET_TS.BIRTH-0">
            <sch:assert test="count(*[self::originalText][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL_RTO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null rules">
          <sch:rule abstract="true" id="IVL_RTO-0">
            <sch:assert test="(@nullFlavor and not(any|low|high|width)) or (not(@nullFlavor) and (any|low|high|width))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="co-occurence rules">
          <sch:rule abstract="true" id="IVL_RTO-1">
            <sch:assert test="(((any and not(any/@nullFlavor)) and not((low and not(low/@nullFlavor)) or (high and not(high/@nullFlavor)) or (width and not(width/@nullFlavor)))) or (not(any) or any/@nullFlavor)) and ((any and not(any/@nullFlavor)) or (not(any) or any/@nullFlavor) and (((width and not(width/@nullFlavor)) and (not(low) or low/@nullFlavor) and (not(high) or high/@nullFlavor))) or ((not(width) or width/@nullFlavor) and ((low and not(low/@nullFlavor)) or (high and not(high/@nullFlavor))))))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="closed attributes only if limited">
          <sch:rule abstract="true" id="IVL_RTO-2">
            <sch:assert test="not(low and @lowClosed) and not(high and @highClosed)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on IVL attributes">
          <sch:rule abstract="true" id="IVL_RTO-3">
            <sch:assert test="count(*[self::low or self::high or self::width][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_RTO">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="low" type="RTO"/>
          <xsd:element minOccurs="0" name="high" type="RTO"/>
          <xsd:element minOccurs="0" name="width" type="QTY"/>
          <xsd:element minOccurs="0" name="any" type="RTO"/>
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="optional"/>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="QSET_RTO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="QSET_RTO-0">
            <sch:assert test="count(*[self::originalText][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL_MO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null rules">
          <sch:rule abstract="true" id="IVL_MO-0">
            <sch:assert test="(@nullFlavor and not(any|low|high|width)) or (not(@nullFlavor) and (any|low|high|width))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="co-occurence rules">
          <sch:rule abstract="true" id="IVL_MO-1">
            <sch:assert test="(((any and not(any/@nullFlavor)) and not((low and not(low/@nullFlavor)) or (high and not(high/@nullFlavor)) or (width and not(width/@nullFlavor)))) or (not(any) or any/@nullFlavor)) and ((any and not(any/@nullFlavor)) or (not(any) or any/@nullFlavor) and (((width and not(width/@nullFlavor)) and (not(low) or low/@nullFlavor) and (not(high) or high/@nullFlavor))) or ((not(width) or width/@nullFlavor) and ((low and not(low/@nullFlavor)) or (high and not(high/@nullFlavor))))))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="closed attributes only if limited">
          <sch:rule abstract="true" id="IVL_MO-2">
            <sch:assert test="not(low and @lowClosed) and not(high and @highClosed)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on IVL attributes">
          <sch:rule abstract="true" id="IVL_MO-3">
            <sch:assert test="count(*[self::low or self::high or self::width][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_MO">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="low" type="MO"/>
          <xsd:element minOccurs="0" name="high" type="MO"/>
          <xsd:element minOccurs="0" name="width" type="QTY"/>
          <xsd:element minOccurs="0" name="any" type="MO"/>
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="optional"/>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="QSET_MO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="QSET_MO-0">
            <sch:assert test="count(*[self::originalText][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL_PQ">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null rules">
          <sch:rule abstract="true" id="IVL_PQ-0">
            <sch:assert test="(@nullFlavor and not(any|low|high|width)) or (not(@nullFlavor) and (any|low|high|width))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="co-occurence rules">
          <sch:rule abstract="true" id="IVL_PQ-1">
            <sch:assert test="(((any and not(any/@nullFlavor)) and not((low and not(low/@nullFlavor)) or (high and not(high/@nullFlavor)) or (width and not(width/@nullFlavor)))) or (not(any) or any/@nullFlavor)) and ((any and not(any/@nullFlavor)) or (not(any) or any/@nullFlavor) and (((width and not(width/@nullFlavor)) and (not(low) or low/@nullFlavor) and (not(high) or high/@nullFlavor))) or ((not(width) or width/@nullFlavor) and ((low and not(low/@nullFlavor)) or (high and not(high/@nullFlavor))))))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="closed attributes only if limited">
          <sch:rule abstract="true" id="IVL_PQ-2">
            <sch:assert test="not(low and @lowClosed) and not(high and @highClosed)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on IVL attributes">
          <sch:rule abstract="true" id="IVL_PQ-3">
            <sch:assert test="count(*[self::low or self::high or self::width][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_PQ">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="low" type="PQ"/>
          <xsd:element minOccurs="0" name="high" type="PQ"/>
          <xsd:element minOccurs="0" name="width" type="QTY"/>
          <xsd:element minOccurs="0" name="any" type="PQ"/>
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="optional"/>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="QSET_PQ">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="QSET_PQ-0">
            <sch:assert test="count(*[self::originalText][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL_PQ.TIME">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null rules">
          <sch:rule abstract="true" id="IVL_PQ.TIME-0">
            <sch:assert test="(@nullFlavor and not(any|low|high|width)) or (not(@nullFlavor) and (any|low|high|width))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="co-occurence rules">
          <sch:rule abstract="true" id="IVL_PQ.TIME-1">
            <sch:assert test="(((any and not(any/@nullFlavor)) and not((low and not(low/@nullFlavor)) or (high and not(high/@nullFlavor)) or (width and not(width/@nullFlavor)))) or (not(any) or any/@nullFlavor)) and ((any and not(any/@nullFlavor)) or (not(any) or any/@nullFlavor) and (((width and not(width/@nullFlavor)) and (not(low) or low/@nullFlavor) and (not(high) or high/@nullFlavor))) or ((not(width) or width/@nullFlavor) and ((low and not(low/@nullFlavor)) or (high and not(high/@nullFlavor))))))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="closed attributes only if limited">
          <sch:rule abstract="true" id="IVL_PQ.TIME-2">
            <sch:assert test="not(low and @lowClosed) and not(high and @highClosed)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on IVL attributes">
          <sch:rule abstract="true" id="IVL_PQ.TIME-3">
            <sch:assert test="count(*[self::low or self::high or self::width][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_PQ.TIME">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="low" type="PQ.TIME"/>
          <xsd:element minOccurs="0" name="high" type="PQ.TIME"/>
          <xsd:element minOccurs="0" name="width" type="QTY"/>
          <xsd:element minOccurs="0" name="any" type="PQ.TIME"/>
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="optional"/>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="QSET_PQ.TIME">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="QSET_PQ.TIME-0">
            <sch:assert test="count(*[self::originalText][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL_REAL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null rules">
          <sch:rule abstract="true" id="IVL_REAL-0">
            <sch:assert test="(@nullFlavor and not(any|low|high|width)) or (not(@nullFlavor) and (any|low|high|width))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="co-occurence rules">
          <sch:rule abstract="true" id="IVL_REAL-1">
            <sch:assert test="(((any and not(any/@nullFlavor)) and not((low and not(low/@nullFlavor)) or (high and not(high/@nullFlavor)) or (width and not(width/@nullFlavor)))) or (not(any) or any/@nullFlavor)) and ((any and not(any/@nullFlavor)) or (not(any) or any/@nullFlavor) and (((width and not(width/@nullFlavor)) and (not(low) or low/@nullFlavor) and (not(high) or high/@nullFlavor))) or ((not(width) or width/@nullFlavor) and ((low and not(low/@nullFlavor)) or (high and not(high/@nullFlavor))))))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="closed attributes only if limited">
          <sch:rule abstract="true" id="IVL_REAL-2">
            <sch:assert test="not(low and @lowClosed) and not(high and @highClosed)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on IVL attributes">
          <sch:rule abstract="true" id="IVL_REAL-3">
            <sch:assert test="count(*[self::low or self::high or self::width][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_REAL">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="low" type="REAL"/>
          <xsd:element minOccurs="0" name="high" type="REAL"/>
          <xsd:element minOccurs="0" name="width" type="QTY"/>
          <xsd:element minOccurs="0" name="any" type="REAL"/>
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="optional"/>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="QSET_REAL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="QSET_REAL-0">
            <sch:assert test="count(*[self::originalText][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL_INT">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null rules">
          <sch:rule abstract="true" id="IVL_INT-0">
            <sch:assert test="(@nullFlavor and not(any|low|high|width)) or (not(@nullFlavor) and (any|low|high|width))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="co-occurence rules">
          <sch:rule abstract="true" id="IVL_INT-1">
            <sch:assert test="(((any and not(any/@nullFlavor)) and not((low and not(low/@nullFlavor)) or (high and not(high/@nullFlavor)) or (width and not(width/@nullFlavor)))) or (not(any) or any/@nullFlavor)) and ((any and not(any/@nullFlavor)) or (not(any) or any/@nullFlavor) and (((width and not(width/@nullFlavor)) and (not(low) or low/@nullFlavor) and (not(high) or high/@nullFlavor))) or ((not(width) or width/@nullFlavor) and ((low and not(low/@nullFlavor)) or (high and not(high/@nullFlavor))))))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="closed attributes only if limited">
          <sch:rule abstract="true" id="IVL_INT-2">
            <sch:assert test="not(low and @lowClosed) and not(high and @highClosed)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on IVL attributes">
          <sch:rule abstract="true" id="IVL_INT-3">
            <sch:assert test="count(*[self::low or self::high or self::width][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_INT">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="low" type="INT"/>
          <xsd:element minOccurs="0" name="high" type="INT"/>
          <xsd:element minOccurs="0" name="width" type="QTY"/>
          <xsd:element minOccurs="0" name="any" type="INT"/>
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="optional"/>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="QSET_INT">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="QSET_INT-0">
            <sch:assert test="count(*[self::originalText][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL_INT.NONNEG">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null rules">
          <sch:rule abstract="true" id="IVL_INT.NONNEG-0">
            <sch:assert test="(@nullFlavor and not(any|low|high|width)) or (not(@nullFlavor) and (any|low|high|width))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="co-occurence rules">
          <sch:rule abstract="true" id="IVL_INT.NONNEG-1">
            <sch:assert test="(((any and not(any/@nullFlavor)) and not((low and not(low/@nullFlavor)) or (high and not(high/@nullFlavor)) or (width and not(width/@nullFlavor)))) or (not(any) or any/@nullFlavor)) and ((any and not(any/@nullFlavor)) or (not(any) or any/@nullFlavor) and (((width and not(width/@nullFlavor)) and (not(low) or low/@nullFlavor) and (not(high) or high/@nullFlavor))) or ((not(width) or width/@nullFlavor) and ((low and not(low/@nullFlavor)) or (high and not(high/@nullFlavor))))))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="closed attributes only if limited">
          <sch:rule abstract="true" id="IVL_INT.NONNEG-2">
            <sch:assert test="not(low and @lowClosed) and not(high and @highClosed)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on IVL attributes">
          <sch:rule abstract="true" id="IVL_INT.NONNEG-3">
            <sch:assert test="count(*[self::low or self::high or self::width][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_INT.NONNEG">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="low" type="INT.NONNEG"/>
          <xsd:element minOccurs="0" name="high" type="INT.NONNEG"/>
          <xsd:element minOccurs="0" name="width" type="QTY"/>
          <xsd:element minOccurs="0" name="any" type="INT.NONNEG"/>
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="optional"/>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="QSET_INT.NONNEG">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="QSET_INT.NONNEG-0">
            <sch:assert test="count(*[self::originalText][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL_INT.POS">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null rules">
          <sch:rule abstract="true" id="IVL_INT.POS-0">
            <sch:assert test="(@nullFlavor and not(any|low|high|width)) or (not(@nullFlavor) and (any|low|high|width))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="co-occurence rules">
          <sch:rule abstract="true" id="IVL_INT.POS-1">
            <sch:assert test="(((any and not(any/@nullFlavor)) and not((low and not(low/@nullFlavor)) or (high and not(high/@nullFlavor)) or (width and not(width/@nullFlavor)))) or (not(any) or any/@nullFlavor)) and ((any and not(any/@nullFlavor)) or (not(any) or any/@nullFlavor) and (((width and not(width/@nullFlavor)) and (not(low) or low/@nullFlavor) and (not(high) or high/@nullFlavor))) or ((not(width) or width/@nullFlavor) and ((low and not(low/@nullFlavor)) or (high and not(high/@nullFlavor))))))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="closed attributes only if limited">
          <sch:rule abstract="true" id="IVL_INT.POS-2">
            <sch:assert test="not(low and @lowClosed) and not(high and @highClosed)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on IVL attributes">
          <sch:rule abstract="true" id="IVL_INT.POS-3">
            <sch:assert test="count(*[self::low or self::high or self::width][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_INT.POS">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="low" type="INT.POS"/>
          <xsd:element minOccurs="0" name="high" type="INT.POS"/>
          <xsd:element minOccurs="0" name="width" type="QTY"/>
          <xsd:element minOccurs="0" name="any" type="INT.POS"/>
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="optional"/>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="QSET_INT.POS">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="QSET_INT.POS-0">
            <sch:assert test="count(*[self::originalText][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL.LOW_CO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="IVL.LOW_CO-0">
            <sch:assert test="low and not(low\@nullFlavor) and (@lowClosed = &quot;true&quot;)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="high">
          © 279
ISO 2008  All rights reserved
          <sch:rule abstract="true" id="IVL.LOW_CO-1">
            <sch:assert test="not(high) and not(@highClosed)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="IVL_CO">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element minOccurs="0" name="low" type="CO"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="high" type="CO"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="width" type="QTY"/>
          <xsd:element minOccurs="0" name="any" type="CO"/>
        </xsd:sequence>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="prohibited"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL.LOW_TS">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="IVL.LOW_TS-0">
            <sch:assert test="low and not(low\@nullFlavor) and (@lowClosed = &quot;true&quot;)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="IVL.LOW_TS-1">
            <sch:assert test="not(high) and not(@highClosed)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="IVL_TS">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element minOccurs="0" name="low" type="TS"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="high" type="TS"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="width" type="QTY"/>
          <xsd:element minOccurs="0" name="any" type="TS"/>
        </xsd:sequence>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="prohibited"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL.LOW_TS.DATE">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="IVL.LOW_TS.DATE-0">
            <sch:assert test="low and not(low\@nullFlavor) and (@lowClosed = &quot;true&quot;)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="IVL.LOW_TS.DATE-1">
            <sch:assert test="not(high) and not(@highClosed)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="IVL_TS.DATE">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element minOccurs="0" name="low" type="TS.DATE"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="high" type="TS.DATE"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="width" type="QTY"/>
          <xsd:element minOccurs="0" name="any" type="TS.DATE"/>
        </xsd:sequence>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="prohibited"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL.LOW_TS.DATE.FULL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="IVL.LOW_TS.DATE.FULL-0">
            <sch:assert test="low and not(low\@nullFlavor) and (@lowClosed = &quot;true&quot;)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="IVL.LOW_TS.DATE.FULL-1">
            <sch:assert test="not(high) and not(@highClosed)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="IVL_TS.DATE.FULL">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element minOccurs="0" name="low" type="TS.DATE.FULL"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="high" type="TS.DATE.FULL"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="width" type="QTY"/>
          <xsd:element minOccurs="0" name="any" type="TS.DATE.FULL"/>
        </xsd:sequence>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="prohibited"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL.LOW_TS.DATETIME">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="IVL.LOW_TS.DATETIME-0">
            <sch:assert test="low and not(low\@nullFlavor) and (@lowClosed = &quot;true&quot;)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="IVL.LOW_TS.DATETIME-1">
            <sch:assert test="not(high) and not(@highClosed)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="IVL_TS.DATETIME">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element minOccurs="0" name="low" type="TS.DATETIME"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="high" type="TS.DATETIME"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="width" type="QTY"/>
          <xsd:element minOccurs="0" name="any" type="TS.DATETIME"/>
        </xsd:sequence>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="prohibited"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL.LOW_TS.DATETIME.FULL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="IVL.LOW_TS.DATETIME.FULL-0">
            <sch:assert test="low and not(low\@nullFlavor) and (@lowClosed = &quot;true&quot;)"/>
          </sch:rule>
          © 281
ISO 2008  All rights reserved
        </sch:pattern>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="IVL.LOW_TS.DATETIME.FULL-1">
            <sch:assert test="not(high) and not(@highClosed)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="IVL_TS.DATETIME.FULL">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element minOccurs="0" name="low" type="TS.DATETIME.FULL"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="high" type="TS.DATETIME.FULL"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="width" type="QTY"/>
          <xsd:element minOccurs="0" name="any" type="TS.DATETIME.FULL"/>
        </xsd:sequence>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="prohibited"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL.LOW_TS.BIRTH">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="IVL.LOW_TS.BIRTH-0">
            <sch:assert test="low and not(low\@nullFlavor) and (@lowClosed = &quot;true&quot;)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="IVL.LOW_TS.BIRTH-1">
            <sch:assert test="not(high) and not(@highClosed)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="IVL_TS.BIRTH">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element minOccurs="0" name="low" type="TS.BIRTH"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="high" type="TS.BIRTH"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="width" type="QTY"/>
          <xsd:element minOccurs="0" name="any" type="TS.BIRTH"/>
        </xsd:sequence>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="prohibited"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL.LOW_RTO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="IVL.LOW_RTO-0">
            <sch:assert test="low and not(low\@nullFlavor) and (@lowClosed = &quot;true&quot;)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="IVL.LOW_RTO-1">
            <sch:assert test="not(high) and not(@highClosed)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="IVL_RTO">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element minOccurs="0" name="low" type="RTO"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="high" type="RTO"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="width" type="QTY"/>
          <xsd:element minOccurs="0" name="any" type="RTO"/>
        </xsd:sequence>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="prohibited"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL.LOW_MO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="IVL.LOW_MO-0">
            <sch:assert test="low and not(low\@nullFlavor) and (@lowClosed = &quot;true&quot;)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="IVL.LOW_MO-1">
            <sch:assert test="not(high) and not(@highClosed)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="IVL_MO">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element minOccurs="0" name="low" type="MO"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="high" type="MO"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="width" type="QTY"/>
          <xsd:element minOccurs="0" name="any" type="MO"/>
        </xsd:sequence>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="prohibited"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL.LOW_PQ">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="IVL.LOW_PQ-0">
            <sch:assert test="low and not(low\@nullFlavor) and (@lowClosed = &quot;true&quot;)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="IVL.LOW_PQ-1">
            <sch:assert test="not(high) and not(@highClosed)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="IVL_PQ">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element minOccurs="0" name="low" type="PQ"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="high" type="PQ"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="width" type="QTY"/>
          <xsd:element minOccurs="0" name="any" type="PQ"/>
        </xsd:sequence>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="prohibited"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL.LOW_PQ.TIME">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="IVL.LOW_PQ.TIME-0">
            © 283
ISO 2008  All rights reserved
            <sch:assert test="low and not(low\@nullFlavor) and (@lowClosed = &quot;true&quot;)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="IVL.LOW_PQ.TIME-1">
            <sch:assert test="not(high) and not(@highClosed)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="IVL_PQ.TIME">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element minOccurs="0" name="low" type="PQ.TIME"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="high" type="PQ.TIME"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="width" type="QTY"/>
          <xsd:element minOccurs="0" name="any" type="PQ.TIME"/>
        </xsd:sequence>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="prohibited"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL.LOW_REAL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="IVL.LOW_REAL-0">
            <sch:assert test="low and not(low\@nullFlavor) and (@lowClosed = &quot;true&quot;)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="IVL.LOW_REAL-1">
            <sch:assert test="not(high) and not(@highClosed)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="IVL_REAL">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element minOccurs="0" name="low" type="REAL"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="high" type="REAL"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="width" type="QTY"/>
          <xsd:element minOccurs="0" name="any" type="REAL"/>
        </xsd:sequence>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="prohibited"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL.LOW_INT">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="IVL.LOW_INT-0">
            <sch:assert test="low and not(low\@nullFlavor) and (@lowClosed = &quot;true&quot;)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="IVL.LOW_INT-1">
            <sch:assert test="not(high) and not(@highClosed)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="IVL_INT">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element minOccurs="0" name="low" type="INT"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="high" type="INT"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="width" type="QTY"/>
          <xsd:element minOccurs="0" name="any" type="INT"/>
        </xsd:sequence>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="prohibited"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL.LOW_INT.NONNEG">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="IVL.LOW_INT.NONNEG-0">
            <sch:assert test="low and not(low\@nullFlavor) and (@lowClosed = &quot;true&quot;)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="IVL.LOW_INT.NONNEG-1">
            <sch:assert test="not(high) and not(@highClosed)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="IVL_INT.NONNEG">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element minOccurs="0" name="low" type="INT.NONNEG"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="high" type="INT.NONNEG"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="width" type="QTY"/>
          <xsd:element minOccurs="0" name="any" type="INT.NONNEG"/>
        </xsd:sequence>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="prohibited"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL.LOW_INT.POS">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="IVL.LOW_INT.POS-0">
            <sch:assert test="low and not(low\@nullFlavor) and (@lowClosed = &quot;true&quot;)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="IVL.LOW_INT.POS-1">
            <sch:assert test="not(high) and not(@highClosed)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="IVL_INT.POS">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element minOccurs="0" name="low" type="INT.POS"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="high" type="INT.POS"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="width" type="QTY"/>
          <xsd:element minOccurs="0" name="any" type="INT.POS"/>
        </xsd:sequence>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="prohibited"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL.WIDTH_CO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="width">
          <sch:rule abstract="true" id="IVL.WIDTH_CO-0">
            <sch:assert test="width and not(width\@nullFlavor)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="IVL.WIDTH_CO-1">
            <sch:assert test="not(low) and not(@lowClosed)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="IVL.WIDTH_CO-2">
            <sch:assert test="not(high) and not(@highClosed)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="IVL_CO">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="low" type="CO"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="high" type="CO"/>
          <xsd:element minOccurs="0" name="width" type="QTY"/>
          <xsd:element minOccurs="0" name="any" type="CO"/>
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="prohibited"/>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="prohibited"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL.WIDTH_TS">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="width">
          <sch:rule abstract="true" id="IVL.WIDTH_TS-0">
            <sch:assert test="width and not(width\@nullFlavor)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="IVL.WIDTH_TS-1">
            <sch:assert test="not(low) and not(@lowClosed)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="IVL.WIDTH_TS-2">
            <sch:assert test="not(high) and not(@highClosed)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="IVL_TS">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="low" type="TS"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="high" type="TS"/>
          <xsd:element minOccurs="0" name="width" type="QTY"/>
          <xsd:element minOccurs="0" name="any" type="TS"/>
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="prohibited"/>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="prohibited"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL.WIDTH_TS.DATE">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="width">
          <sch:rule abstract="true" id="IVL.WIDTH_TS.DATE-0">
            <sch:assert test="width and not(width\@nullFlavor)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="IVL.WIDTH_TS.DATE-1">
            <sch:assert test="not(low) and not(@lowClosed)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="IVL.WIDTH_TS.DATE-2">
            <sch:assert test="not(high) and not(@highClosed)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="IVL_TS.DATE">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="low" type="TS.DATE"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="high" type="TS.DATE"/>
          <xsd:element minOccurs="0" name="width" type="QTY"/>
          <xsd:element minOccurs="0" name="any" type="TS.DATE"/>
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="prohibited"/>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="prohibited"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL.WIDTH_TS.DATE.FULL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="width">
          <sch:rule abstract="true" id="IVL.WIDTH_TS.DATE.FULL-0">
            <sch:assert test="width and not(width\@nullFlavor)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="IVL.WIDTH_TS.DATE.FULL-1">
            <sch:assert test="not(low) and not(@lowClosed)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="IVL.WIDTH_TS.DATE.FULL-2">
            <sch:assert test="not(high) and not(@highClosed)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="IVL_TS.DATE.FULL">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="low" type="TS.DATE.FULL"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="high" type="TS.DATE.FULL"/>
          <xsd:element minOccurs="0" name="width" type="QTY"/>
          <xsd:element minOccurs="0" name="any" type="TS.DATE.FULL"/>
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="prohibited"/>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="prohibited"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL.WIDTH_TS.DATETIME">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="width">
          <sch:rule abstract="true" id="IVL.WIDTH_TS.DATETIME-0">
            <sch:assert test="width and not(width\@nullFlavor)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="IVL.WIDTH_TS.DATETIME-1">
            <sch:assert test="not(low) and not(@lowClosed)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="IVL.WIDTH_TS.DATETIME-2">
            <sch:assert test="not(high) and not(@highClosed)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="IVL_TS.DATETIME">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="low" type="TS.DATETIME"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="high" type="TS.DATETIME"/>
          <xsd:element minOccurs="0" name="width" type="QTY"/>
          <xsd:element minOccurs="0" name="any" type="TS.DATETIME"/>
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="prohibited"/>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="prohibited"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL.WIDTH_TS.DATETIME.FULL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="width">
          <sch:rule abstract="true" id="IVL.WIDTH_TS.DATETIME.FULL-0">
            <sch:assert test="width and not(width\@nullFlavor)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="IVL.WIDTH_TS.DATETIME.FULL-1">
            <sch:assert test="not(low) and not(@lowClosed)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="IVL.WIDTH_TS.DATETIME.FULL-2">
            <sch:assert test="not(high) and not(@highClosed)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="IVL_TS.DATETIME.FULL">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="low" type="TS.DATETIME.FULL"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="high" type="TS.DATETIME.FULL"/>
          <xsd:element minOccurs="0" name="width" type="QTY"/>
          <xsd:element minOccurs="0" name="any" type="TS.DATETIME.FULL"/>
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="prohibited"/>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="prohibited"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL.WIDTH_TS.BIRTH">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="width">
          <sch:rule abstract="true" id="IVL.WIDTH_TS.BIRTH-0">
            <sch:assert test="width and not(width\@nullFlavor)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="IVL.WIDTH_TS.BIRTH-1">
            <sch:assert test="not(low) and not(@lowClosed)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="IVL.WIDTH_TS.BIRTH-2">
            <sch:assert test="not(high) and not(@highClosed)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="IVL_TS.BIRTH">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="low" type="TS.BIRTH"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="high" type="TS.BIRTH"/>
          <xsd:element minOccurs="0" name="width" type="QTY"/>
          <xsd:element minOccurs="0" name="any" type="TS.BIRTH"/>
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="prohibited"/>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="prohibited"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL.WIDTH_RTO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="width">
          <sch:rule abstract="true" id="IVL.WIDTH_RTO-0">
            <sch:assert test="width and not(width\@nullFlavor)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="IVL.WIDTH_RTO-1">
            <sch:assert test="not(low) and not(@lowClosed)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="IVL.WIDTH_RTO-2">
            <sch:assert test="not(high) and not(@highClosed)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="IVL_RTO">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="low" type="RTO"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="high" type="RTO"/>
          <xsd:element minOccurs="0" name="width" type="QTY"/>
          <xsd:element minOccurs="0" name="any" type="RTO"/>
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="prohibited"/>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="prohibited"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL.WIDTH_MO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="width">
          <sch:rule abstract="true" id="IVL.WIDTH_MO-0">
            <sch:assert test="width and not(width\@nullFlavor)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="IVL.WIDTH_MO-1">
            <sch:assert test="not(low) and not(@lowClosed)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="IVL.WIDTH_MO-2">
            <sch:assert test="not(high) and not(@highClosed)"/>
          </sch:rule>
          © 289
ISO 2008  All rights reserved
          <sch:assert test="width and not(width\@nullFlavor)"/>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="IVL_MO">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="low" type="MO"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="high" type="MO"/>
          <xsd:element minOccurs="0" name="width" type="QTY"/>
          <xsd:element minOccurs="0" name="any" type="MO"/>
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="prohibited"/>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="prohibited"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL.WIDTH_PQ">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="width">
          <sch:rule abstract="true" id="IVL.WIDTH_PQ-0">
            <sch:assert test="width and not(width\@nullFlavor)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="IVL.WIDTH_PQ-1">
            <sch:assert test="not(low) and not(@lowClosed)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="IVL.WIDTH_PQ-2">
            <sch:assert test="not(high) and not(@highClosed)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="IVL_PQ">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="low" type="PQ"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="high" type="PQ"/>
          <xsd:element minOccurs="0" name="width" type="QTY"/>
          <xsd:element minOccurs="0" name="any" type="PQ"/>
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="prohibited"/>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="prohibited"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL.WIDTH_PQ.TIME">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="width">
          <sch:rule abstract="true" id="IVL.WIDTH_PQ.TIME-0"></sch:rule>
        </sch:pattern>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="IVL.WIDTH_PQ.TIME-1">
            <sch:assert test="not(low) and not(@lowClosed)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="IVL.WIDTH_PQ.TIME-2">
            <sch:assert test="not(high) and not(@highClosed)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="IVL_PQ.TIME">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="low" type="PQ.TIME"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="high" type="PQ.TIME"/>
          <xsd:element minOccurs="0" name="width" type="QTY"/>
          <xsd:element minOccurs="0" name="any" type="PQ.TIME"/>
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="prohibited"/>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="prohibited"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL.WIDTH_REAL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="width">
          <sch:rule abstract="true" id="IVL.WIDTH_REAL-0">
            <sch:assert test="width and not(width\@nullFlavor)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="IVL.WIDTH_REAL-1">
            <sch:assert test="not(low) and not(@lowClosed)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="IVL.WIDTH_REAL-2">
            <sch:assert test="not(high) and not(@highClosed)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="IVL_REAL">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="low" type="REAL"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="high" type="REAL"/>
          <xsd:element minOccurs="0" name="width" type="QTY"/>
          <xsd:element minOccurs="0" name="any" type="REAL"/>
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="prohibited"/>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="prohibited"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL.WIDTH_INT">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="width">
          <sch:rule abstract="true" id="IVL.WIDTH_INT-0">
            <sch:assert test="width and not(width\@nullFlavor)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="IVL.WIDTH_INT-1">
            <sch:assert test="not(low) and not(@lowClosed)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="IVL.WIDTH_INT-2">
            <sch:assert test="not(high) and not(@highClosed)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="IVL_INT">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="low" type="INT"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="high" type="INT"/>
          <xsd:element minOccurs="0" name="width" type="QTY"/>
          <xsd:element minOccurs="0" name="any" type="INT"/>
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="prohibited"/>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="prohibited"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL.WIDTH_INT.NONNEG">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="width">
          <sch:rule abstract="true" id="IVL.WIDTH_INT.NONNEG-0">
            <sch:assert test="width and not(width\@nullFlavor)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="IVL.WIDTH_INT.NONNEG-1">
            <sch:assert test="not(low) and not(@lowClosed)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="IVL.WIDTH_INT.NONNEG-2">
            <sch:assert test="not(high) and not(@highClosed)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="IVL_INT.NONNEG">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="low" type="INT.NONNEG"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="high" type="INT.NONNEG"/>
          <xsd:element minOccurs="0" name="width" type="QTY"/>
          <xsd:element minOccurs="0" name="any" type="INT.NONNEG"/>
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="prohibited"/>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="prohibited"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL.WIDTH_INT.POS">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="width">
          <sch:rule abstract="true" id="IVL.WIDTH_INT.POS-0">
            <sch:assert test="width and not(width\@nullFlavor)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="IVL.WIDTH_INT.POS-1">
            <sch:assert test="not(low) and not(@lowClosed)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="IVL.WIDTH_INT.POS-2">
            <sch:assert test="not(high) and not(@highClosed)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="IVL_INT.POS">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="low" type="INT.POS"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="high" type="INT.POS"/>
          <xsd:element minOccurs="0" name="width" type="QTY"/>
          <xsd:element minOccurs="0" name="any" type="INT.POS"/>
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="prohibited"/>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="prohibited"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL.HIGH_CO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="IVL.HIGH_CO-0">
            <sch:assert test="high and not(high\@nullFlavor) and (@highClosed = &quot;true&quot;)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="IVL.HIGH_CO-1">
            <sch:assert test="not(low) and not(@lowClosed)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="IVL_CO">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="low" type="CO"/>
          <xsd:element minOccurs="0" name="high" type="CO"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="width" type="QTY"/>
          <xsd:element minOccurs="0" name="any" type="CO"/>
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="prohibited"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL.HIGH_TS">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="IVL.HIGH_TS-0">
            <sch:assert test="high and not(high\@nullFlavor) and (@highClosed = &quot;true&quot;)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="IVL.HIGH_TS-1">
            <sch:assert test="not(low) and not(@lowClosed)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="IVL_TS">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="low" type="TS"/>
          <xsd:element minOccurs="0" name="high" type="TS"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="width" type="QTY"/>
          <xsd:element minOccurs="0" name="any" type="TS"/>
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="prohibited"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL.HIGH_TS.DATE">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="IVL.HIGH_TS.DATE-0">
            <sch:assert test="high and not(high\@nullFlavor) and (@highClosed = &quot;true&quot;)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="IVL.HIGH_TS.DATE-1">
            <sch:assert test="not(low) and not(@lowClosed)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="IVL_TS.DATE">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="low" type="TS.DATE"/>
          <xsd:element minOccurs="0" name="high" type="TS.DATE"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="width" type="QTY"/>
          <xsd:element minOccurs="0" name="any" type="TS.DATE"/>
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="prohibited"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL.HIGH_TS.DATE.FULL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="IVL.HIGH_TS.DATE.FULL-0">
            <sch:assert test="high and not(high\@nullFlavor) and (@highClosed = &quot;true&quot;)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="IVL.HIGH_TS.DATE.FULL-1">
            <sch:assert test="not(low) and not(@lowClosed)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="IVL_TS.DATE.FULL">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="low" type="TS.DATE.FULL"/>
          <xsd:element minOccurs="0" name="high" type="TS.DATE.FULL"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="width" type="QTY"/>
          <xsd:element minOccurs="0" name="any" type="TS.DATE.FULL"/>
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="prohibited"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL.HIGH_TS.DATETIME">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="IVL.HIGH_TS.DATETIME-0">
            <sch:assert test="high and not(high\@nullFlavor) and (@highClosed = &quot;true&quot;)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="IVL.HIGH_TS.DATETIME-1">
            <sch:assert test="not(low) and not(@lowClosed)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="IVL_TS.DATETIME">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="low" type="TS.DATETIME"/>
          <xsd:element minOccurs="0" name="high" type="TS.DATETIME"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="width" type="QTY"/>
          <xsd:element minOccurs="0" name="any" type="TS.DATETIME"/>
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="prohibited"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL.HIGH_TS.DATETIME.FULL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="IVL.HIGH_TS.DATETIME.FULL-0">
            <sch:assert test="high and not(high\@nullFlavor) and (@highClosed = &quot;true&quot;)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="IVL.HIGH_TS.DATETIME.FULL-1">
            <sch:assert test="not(low) and not(@lowClosed)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="IVL_TS.DATETIME.FULL">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="low" type="TS.DATETIME.FULL"/>
          <xsd:element minOccurs="0" name="high" type="TS.DATETIME.FULL"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="width" type="QTY"/>
          <xsd:element minOccurs="0" name="any" type="TS.DATETIME.FULL"/>
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="prohibited"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL.HIGH_TS.BIRTH">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="IVL.HIGH_TS.BIRTH-0">
            <sch:assert test="high and not(high\@nullFlavor) and (@highClosed = &quot;true&quot;)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="IVL.HIGH_TS.BIRTH-1">
            <sch:assert test="not(low) and not(@lowClosed)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="IVL_TS.BIRTH">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="low" type="TS.BIRTH"/>
          <xsd:element minOccurs="0" name="high" type="TS.BIRTH"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="width" type="QTY"/>
          <xsd:element minOccurs="0" name="any" type="TS.BIRTH"/>
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="prohibited"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL.HIGH_RTO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="IVL.HIGH_RTO-0">
            © 295
ISO 2008  All rights reserved
            <sch:assert test="high and not(high\@nullFlavor) and (@highClosed = &quot;true&quot;)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="IVL.HIGH_RTO-1">
            <sch:assert test="not(low) and not(@lowClosed)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="IVL_RTO">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="low" type="RTO"/>
          <xsd:element minOccurs="0" name="high" type="RTO"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="width" type="QTY"/>
          <xsd:element minOccurs="0" name="any" type="RTO"/>
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="prohibited"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL.HIGH_MO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="IVL.HIGH_MO-0">
            <sch:assert test="high and not(high\@nullFlavor) and (@highClosed = &quot;true&quot;)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="IVL.HIGH_MO-1">
            <sch:assert test="not(low) and not(@lowClosed)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="IVL_MO">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="low" type="MO"/>
          <xsd:element minOccurs="0" name="high" type="MO"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="width" type="QTY"/>
          <xsd:element minOccurs="0" name="any" type="MO"/>
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="prohibited"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL.HIGH_PQ">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="IVL.HIGH_PQ-0">
            <sch:assert test="high and not(high\@nullFlavor) and (@highClosed = &quot;true&quot;)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="IVL.HIGH_PQ-1">
            <sch:assert test="not(low) and not(@lowClosed)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="IVL_PQ">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="low" type="PQ"/>
          <xsd:element minOccurs="0" name="high" type="PQ"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="width" type="QTY"/>
          <xsd:element minOccurs="0" name="any" type="PQ"/>
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="prohibited"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL.HIGH_PQ.TIME">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="IVL.HIGH_PQ.TIME-0">
            <sch:assert test="high and not(high\@nullFlavor) and (@highClosed = &quot;true&quot;)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="IVL.HIGH_PQ.TIME-1">
            <sch:assert test="not(low) and not(@lowClosed)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="IVL_PQ.TIME">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="low" type="PQ.TIME"/>
          <xsd:element minOccurs="0" name="high" type="PQ.TIME"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="width" type="QTY"/>
          <xsd:element minOccurs="0" name="any" type="PQ.TIME"/>
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="prohibited"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL.HIGH_REAL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="IVL.HIGH_REAL-0">
            <sch:assert test="high and not(high\@nullFlavor) and (@highClosed = &quot;true&quot;)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="IVL.HIGH_REAL-1">
            <sch:assert test="not(low) and not(@lowClosed)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="IVL_REAL">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="low" type="REAL"/>
          <xsd:element minOccurs="0" name="high" type="REAL"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="width" type="QTY"/>
          <xsd:element minOccurs="0" name="any" type="REAL"/>
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="prohibited"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL.HIGH_INT">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="IVL.HIGH_INT-0">
            <sch:assert test="high and not(high\@nullFlavor) and (@highClosed = &quot;true&quot;)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="IVL.HIGH_INT-1">
            <sch:assert test="not(low) and not(@lowClosed)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="IVL_INT">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="low" type="INT"/>
          <xsd:element minOccurs="0" name="high" type="INT"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="width" type="QTY"/>
          <xsd:element minOccurs="0" name="any" type="INT"/>
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="prohibited"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL.HIGH_INT.NONNEG">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="IVL.HIGH_INT.NONNEG-0">
            <sch:assert test="high and not(high\@nullFlavor) and (@highClosed = &quot;true&quot;)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="IVL.HIGH_INT.NONNEG-1">
            <sch:assert test="not(low) and not(@lowClosed)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="IVL_INT.NONNEG">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="low" type="INT.NONNEG"/>
          <xsd:element minOccurs="0" name="high" type="INT.NONNEG"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="width" type="QTY"/>
          <xsd:element minOccurs="0" name="any" type="INT.NONNEG"/>
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="prohibited"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL.HIGH_INT.POS">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="IVL.HIGH_INT.POS-0">
            <sch:assert test="high and not(high\@nullFlavor) and (@highClosed = &quot;true&quot;)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="IVL.HIGH_INT.POS-1">
            <sch:assert test="not(low) and not(@lowClosed)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="IVL_INT.POS">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="low" type="INT.POS"/>
          <xsd:element minOccurs="0" name="high" type="INT.POS"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="width" type="QTY"/>
          <xsd:element minOccurs="0" name="any" type="INT.POS"/>
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="prohibited"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="SLIST_CO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="required attributes">
          <sch:rule abstract="true" id="SLIST_CO-0">
            <sch:assert test="@nullFlavor or (origin and not(origin\@nullFlavor) and count(*[digits\not(@nullFlavor))>0)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on SLIST attributes">
          <sch:rule abstract="true" id="SLIST_CO-1">
            <sch:assert test="count(*[self::origin or self::scale or self::digits][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="origin" type="CO"/>
          <xsd:element minOccurs="0" name="scale" type="QTY"/>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="digit" type="INT"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="SLIST_TS">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="required attributes">
          <sch:rule abstract="true" id="SLIST_TS-0">
            <sch:assert test="@nullFlavor or (origin and not(origin\@nullFlavor) and count(*[digits\not(@nullFlavor))>0)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on SLIST attributes">
          <sch:rule abstract="true" id="SLIST_TS-1">
            <sch:assert test="count(*[self::origin or self::scale or self::digits][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="origin" type="TS"/>
          <xsd:element minOccurs="0" name="scale" type="QTY"/>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="digit" type="INT"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="SLIST_TS.DATE">
    <xsd:annotation>
      <xsd:appinfo>
        © 299
ISO 2008  All rights reserved
        <sch:pattern name="required attributes">
          <sch:rule abstract="true" id="SLIST_TS.DATE-0">
            <sch:assert test="@nullFlavor or (origin and not(origin\@nullFlavor) and count(*[digits\not(@nullFlavor))>0)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on SLIST attributes">
          <sch:rule abstract="true" id="SLIST_TS.DATE-1">
            <sch:assert test="count(*[self::origin or self::scale or self::digits][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="origin" type="TS.DATE"/>
          <xsd:element minOccurs="0" name="scale" type="QTY"/>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="digit" type="INT"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="SLIST_TS.DATE.FULL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="required attributes">
          <sch:rule abstract="true" id="SLIST_TS.DATE.FULL-0">
            <sch:assert test="@nullFlavor or (origin and not(origin\@nullFlavor) and count(*[digits\not(@nullFlavor))>0)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on SLIST attributes">
          <sch:rule abstract="true" id="SLIST_TS.DATE.FULL-1">
            <sch:assert test="count(*[self::origin or self::scale or self::digits][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="origin" type="TS.DATE.FULL"/>
          <xsd:element minOccurs="0" name="scale" type="QTY"/>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="digit" type="INT"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="SLIST_TS.DATETIME">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="required attributes">
          <sch:rule abstract="true" id="SLIST_TS.DATETIME-0">
            <sch:assert test="@nullFlavor or (origin and not(origin\@nullFlavor) and count(*[digits\not(@nullFlavor))>0)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on SLIST attributes">
          <sch:rule abstract="true" id="SLIST_TS.DATETIME-1">
            <sch:assert test="count(*[self::origin or self::scale or self::digits][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="origin" type="TS.DATETIME"/>
          <xsd:element minOccurs="0" name="scale" type="QTY"/>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="digit" type="INT"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="SLIST_TS.DATETIME.FULL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="required attributes">
          <sch:rule abstract="true" id="SLIST_TS.DATETIME.FULL-0">
            <sch:assert test="@nullFlavor or (origin and not(origin\@nullFlavor) and count(*[digits\not(@nullFlavor))>0)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on SLIST attributes">
          <sch:rule abstract="true" id="SLIST_TS.DATETIME.FULL-1">
            <sch:assert test="count(*[self::origin or self::scale or self::digits][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="origin" type="TS.DATETIME.FULL"/>
          <xsd:element minOccurs="0" name="scale" type="QTY"/>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="digit" type="INT"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="SLIST_TS.BIRTH">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="required attributes">
          <sch:rule abstract="true" id="SLIST_TS.BIRTH-0">
            <sch:assert test="@nullFlavor or (origin and not(origin\@nullFlavor) and count(*[digits\not(@nullFlavor))>0)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on SLIST attributes">
          <sch:rule abstract="true" id="SLIST_TS.BIRTH-1">
            <sch:assert test="count(*[self::origin or self::scale or self::digits][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="origin" type="TS.BIRTH"/>
          <xsd:element minOccurs="0" name="scale" type="QTY"/>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="digit" type="INT"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="SLIST_RTO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="required attributes">
          <sch:rule abstract="true" id="SLIST_RTO-0">
            <sch:assert test="@nullFlavor or (origin and not(origin\@nullFlavor) and count(*[digits\not(@nullFlavor))>0)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on SLIST attributes">
          <sch:rule abstract="true" id="SLIST_RTO-1">
            <sch:assert test="count(*[self::origin or self::scale or self::digits][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="origin" type="RTO"/>
          <xsd:element minOccurs="0" name="scale" type="QTY"/>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="digit" type="INT"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="SLIST_MO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="required attributes">
          <sch:rule abstract="true" id="SLIST_MO-0">
            <sch:assert test="@nullFlavor or (origin and not(origin\@nullFlavor) and count(*[digits\not(@nullFlavor))>0)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on SLIST attributes">
          <sch:rule abstract="true" id="SLIST_MO-1">
            <sch:assert test="count(*[self::origin or self::scale or self::digits][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="origin" type="MO"/>
          <xsd:element minOccurs="0" name="scale" type="QTY"/>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="digit" type="INT"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="SLIST_PQ">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="required attributes">
          <sch:rule abstract="true" id="SLIST_PQ-0">
            <sch:assert test="@nullFlavor or (origin and not(origin\@nullFlavor) and count(*[digits\not(@nullFlavor))>0)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on SLIST attributes">
          <sch:rule abstract="true" id="SLIST_PQ-1">
            <sch:assert test="count(*[self::origin or self::scale or self::digits][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="origin" type="PQ"/>
          <xsd:element minOccurs="0" name="scale" type="QTY"/>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="digit" type="INT"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="SLIST_PQ.TIME">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="required attributes">
          <sch:rule abstract="true" id="SLIST_PQ.TIME-0">
            <sch:assert test="@nullFlavor or (origin and not(origin\@nullFlavor) and count(*[digits\not(@nullFlavor))>0)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on SLIST attributes">
          <sch:rule abstract="true" id="SLIST_PQ.TIME-1">
            <sch:assert test="count(*[self::origin or self::scale or self::digits][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="origin" type="PQ.TIME"/>
          <xsd:element minOccurs="0" name="scale" type="QTY"/>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="digit" type="INT"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="SLIST_REAL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="required attributes">
          <sch:rule abstract="true" id="SLIST_REAL-0">
            <sch:assert test="@nullFlavor or (origin and not(origin\@nullFlavor) and count(*[digits\not(@nullFlavor))>0)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on SLIST attributes">
          <sch:rule abstract="true" id="SLIST_REAL-1">
            <sch:assert test="count(*[self::origin or self::scale or self::digits][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="origin" type="REAL"/>
          <xsd:element minOccurs="0" name="scale" type="QTY"/>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="digit" type="INT"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="SLIST_INT">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="required attributes">
          <sch:rule abstract="true" id="SLIST_INT-0">
            <sch:assert test="@nullFlavor or (origin and not(origin\@nullFlavor) and count(*[digits\not(@nullFlavor))>0)"/>
          </sch:rule>
          © 303
ISO 2008  All rights reserved
        </sch:pattern>
        <sch:pattern name="no updateMode or History on SLIST attributes">
          <sch:rule abstract="true" id="SLIST_INT-1">
            <sch:assert test="count(*[self::origin or self::scale or self::digits][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="origin" type="INT"/>
          <xsd:element minOccurs="0" name="scale" type="QTY"/>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="digit" type="INT"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="SLIST_INT.NONNEG">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="required attributes">
          <sch:rule abstract="true" id="SLIST_INT.NONNEG-0">
            <sch:assert test="@nullFlavor or (origin and not(origin\@nullFlavor) and count(*[digits\not(@nullFlavor))>0)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on SLIST attributes">
          <sch:rule abstract="true" id="SLIST_INT.NONNEG-1">
            <sch:assert test="count(*[self::origin or self::scale or self::digits][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="origin" type="INT.NONNEG"/>
          <xsd:element minOccurs="0" name="scale" type="QTY"/>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="digit" type="INT"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="SLIST_INT.POS">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="required attributes">
          <sch:rule abstract="true" id="SLIST_INT.POS-0">
            <sch:assert test="@nullFlavor or (origin and not(origin\@nullFlavor) and count(*[digits\not(@nullFlavor))>0)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on SLIST attributes">
          <sch:rule abstract="true" id="SLIST_INT.POS-1">
            <sch:assert test="count(*[self::origin or self::scale or self::digits][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="origin" type="INT.POS"/>
          <xsd:element minOccurs="0" name="scale" type="QTY"/>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="digit" type="INT"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="GLIST_CO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="required attributes">
          <sch:rule abstract="true" id="GLIST_CO-0">
            <sch:assert test="@nullFlavor or (head and not(head\@nullFlavor) and increment and not(increment\@nullFlavor) and @denominator)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="denominator must be positive">
          <sch:rule abstract="true" id="GLIST_CO-1">
            <sch:assert test="not(@denominator) or (@denominator > 0)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="period must be positive">
          <sch:rule abstract="true" id="GLIST_CO-2">
            <sch:assert test="todo"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on GLIST attributes">
          <sch:rule abstract="true" id="GLIST_CO-3">
            <sch:assert test="count(*[self::head or self::increment][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="head" type="CO"/>
          <xsd:element minOccurs="0" name="increment" type="QTY"/>
        </xsd:sequence>
        <xsd:attribute name="denominator" type="xsd:int" use="optional"/>
        <xsd:attribute name="period" type="xsd:int" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="GLIST_TS">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="required attributes">
          <sch:rule abstract="true" id="GLIST_TS-0">
            <sch:assert test="@nullFlavor or (head and not(head\@nullFlavor) and increment and not(increment\@nullFlavor) and @denominator)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="denominator must be positive">
          <sch:rule abstract="true" id="GLIST_TS-1">
            <sch:assert test="not(@denominator) or (@denominator > 0)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="period must be positive">
          <sch:rule abstract="true" id="GLIST_TS-2">
            <sch:assert test="todo"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on GLIST attributes">
          <sch:rule abstract="true" id="GLIST_TS-3">
            <sch:assert test="count(*[self::head or self::increment][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="head" type="TS"/>
          <xsd:element minOccurs="0" name="increment" type="QTY"/>
        </xsd:sequence>
        <xsd:attribute name="denominator" type="xsd:int" use="optional"/>
        <xsd:attribute name="period" type="xsd:int" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="GLIST_TS.DATE">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="required attributes">
          <sch:rule abstract="true" id="GLIST_TS.DATE-0">
            <sch:assert test="@nullFlavor or (head and not(head\@nullFlavor) and increment and not(increment\@nullFlavor) and @denominator)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="denominator must be positive">
          <sch:rule abstract="true" id="GLIST_TS.DATE-1">
            <sch:assert test="not(@denominator) or (@denominator > 0)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="period must be positive">
          <sch:rule abstract="true" id="GLIST_TS.DATE-2">
            <sch:assert test="todo"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on GLIST attributes">
          <sch:rule abstract="true" id="GLIST_TS.DATE-3">
            <sch:assert test="count(*[self::head or self::increment][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="head" type="TS.DATE"/>
          <xsd:element minOccurs="0" name="increment" type="QTY"/>
        </xsd:sequence>
        <xsd:attribute name="denominator" type="xsd:int" use="optional"/>
        <xsd:attribute name="period" type="xsd:int" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="GLIST_TS.DATE.FULL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="required attributes">
          <sch:rule abstract="true" id="GLIST_TS.DATE.FULL-0">
            <sch:assert test="@nullFlavor or (head and not(head\@nullFlavor) and increment and not(increment\@nullFlavor) and @denominator)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="denominator must be positive">
          <sch:rule abstract="true" id="GLIST_TS.DATE.FULL-1">
            <sch:assert test="not(@denominator) or (@denominator > 0)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="period must be positive">
          <sch:rule abstract="true" id="GLIST_TS.DATE.FULL-2">
            <sch:assert test="todo"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on GLIST attributes">
          <sch:rule abstract="true" id="GLIST_TS.DATE.FULL-3">
            <sch:assert test="count(*[self::head or self::increment][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="head" type="TS.DATE.FULL"/>
          <xsd:element minOccurs="0" name="increment" type="QTY"/>
        </xsd:sequence>
        <xsd:attribute name="denominator" type="xsd:int" use="optional"/>
        <xsd:attribute name="period" type="xsd:int" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="GLIST_TS.DATETIME">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="required attributes">
          <sch:rule abstract="true" id="GLIST_TS.DATETIME-0">
            <sch:assert test="@nullFlavor or (head and not(head\@nullFlavor) and increment and not(increment\@nullFlavor) and @denominator)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="denominator must be positive">
          <sch:rule abstract="true" id="GLIST_TS.DATETIME-1">
            <sch:assert test="not(@denominator) or (@denominator > 0)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="period must be positive">
          <sch:rule abstract="true" id="GLIST_TS.DATETIME-2">
            <sch:assert test="todo"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on GLIST attributes">
          <sch:rule abstract="true" id="GLIST_TS.DATETIME-3">
            <sch:assert test="count(*[self::head or self::increment][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="head" type="TS.DATETIME"/>
          <xsd:element minOccurs="0" name="increment" type="QTY"/>
        </xsd:sequence>
        <xsd:attribute name="denominator" type="xsd:int" use="optional"/>
        <xsd:attribute name="period" type="xsd:int" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="GLIST_TS.DATETIME.FULL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="required attributes">
          <sch:rule abstract="true" id="GLIST_TS.DATETIME.FULL-0">
            <sch:assert test="@nullFlavor or (head and not(head\@nullFlavor) and increment and not(increment\@nullFlavor) and @denominator)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="denominator must be positive">
          <sch:rule abstract="true" id="GLIST_TS.DATETIME.FULL-1">
            <sch:assert test="not(@denominator) or (@denominator > 0)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="period must be positive">
          <sch:rule abstract="true" id="GLIST_TS.DATETIME.FULL-2">
            <sch:assert test="todo"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on GLIST attributes">
          © 307
ISO 2008  All rights reserved
          <sch:rule abstract="true" id="GLIST_TS.DATETIME.FULL-3">
            <sch:assert test="count(*[self::head or self::increment][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="head" type="TS.DATETIME.FULL"/>
          <xsd:element minOccurs="0" name="increment" type="QTY"/>
        </xsd:sequence>
        <xsd:attribute name="denominator" type="xsd:int" use="optional"/>
        <xsd:attribute name="period" type="xsd:int" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="GLIST_TS.BIRTH">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="required attributes">
          <sch:rule abstract="true" id="GLIST_TS.BIRTH-0">
            <sch:assert test="@nullFlavor or (head and not(head\@nullFlavor) and increment and not(increment\@nullFlavor) and @denominator)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="denominator must be positive">
          <sch:rule abstract="true" id="GLIST_TS.BIRTH-1">
            <sch:assert test="not(@denominator) or (@denominator > 0)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="period must be positive">
          <sch:rule abstract="true" id="GLIST_TS.BIRTH-2">
            <sch:assert test="todo"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on GLIST attributes">
          <sch:rule abstract="true" id="GLIST_TS.BIRTH-3">
            <sch:assert test="count(*[self::head or self::increment][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="head" type="TS.BIRTH"/>
          <xsd:element minOccurs="0" name="increment" type="QTY"/>
        </xsd:sequence>
        <xsd:attribute name="denominator" type="xsd:int" use="optional"/>
        <xsd:attribute name="period" type="xsd:int" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="GLIST_RTO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="required attributes">
          <sch:rule abstract="true" id="GLIST_RTO-0">
            <sch:assert test="@nullFlavor or (head and not(head\@nullFlavor) and increment and not(increment\@nullFlavor) and @denominator)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="denominator must be positive">
          <sch:rule abstract="true" id="GLIST_RTO-1">
            <sch:assert test="not(@denominator) or (@denominator > 0)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="period must be positive">
          <sch:rule abstract="true" id="GLIST_RTO-2">
            <sch:assert test="todo"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on GLIST attributes">
          <sch:rule abstract="true" id="GLIST_RTO-3">
            <sch:assert test="count(*[self::head or self::increment][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="head" type="RTO"/>
          <xsd:element minOccurs="0" name="increment" type="QTY"/>
        </xsd:sequence>
        <xsd:attribute name="denominator" type="xsd:int" use="optional"/>
        <xsd:attribute name="period" type="xsd:int" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="GLIST_MO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="required attributes">
          <sch:rule abstract="true" id="GLIST_MO-0">
            <sch:assert test="@nullFlavor or (head and not(head\@nullFlavor) and increment and not(increment\@nullFlavor) and @denominator)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="denominator must be positive">
          <sch:rule abstract="true" id="GLIST_MO-1">
            <sch:assert test="not(@denominator) or (@denominator > 0)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="period must be positive">
          <sch:rule abstract="true" id="GLIST_MO-2">
            <sch:assert test="todo"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on GLIST attributes">
          <sch:rule abstract="true" id="GLIST_MO-3">
            <sch:assert test="count(*[self::head or self::increment][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="head" type="MO"/>
          <xsd:element minOccurs="0" name="increment" type="QTY"/>
        </xsd:sequence>
        <xsd:attribute name="denominator" type="xsd:int" use="optional"/>
        <xsd:attribute name="period" type="xsd:int" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="GLIST_PQ">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="required attributes">
          <sch:rule abstract="true" id="GLIST_PQ-0">
            <sch:assert test="@nullFlavor or (head and not(head\@nullFlavor) and increment and not(increment\@nullFlavor) and @denominator)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="denominator must be positive">
          <sch:rule abstract="true" id="GLIST_PQ-1">
            <sch:assert test="not(@denominator) or (@denominator > 0)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="period must be positive">
          <sch:rule abstract="true" id="GLIST_PQ-2">
            <sch:assert test="todo"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on GLIST attributes">
          <sch:rule abstract="true" id="GLIST_PQ-3">
            <sch:assert test="count(*[self::head or self::increment][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="head" type="PQ"/>
          <xsd:element minOccurs="0" name="increment" type="QTY"/>
        </xsd:sequence>
        <xsd:attribute name="denominator" type="xsd:int" use="optional"/>
        <xsd:attribute name="period" type="xsd:int" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="GLIST_PQ.TIME">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="required attributes">
          <sch:rule abstract="true" id="GLIST_PQ.TIME-0">
            <sch:assert test="@nullFlavor or (head and not(head\@nullFlavor) and increment and not(increment\@nullFlavor) and @denominator)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="denominator must be positive">
          <sch:rule abstract="true" id="GLIST_PQ.TIME-1">
            <sch:assert test="not(@denominator) or (@denominator > 0)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="period must be positive">
          <sch:rule abstract="true" id="GLIST_PQ.TIME-2">
            <sch:assert test="todo"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on GLIST attributes">
          <sch:rule abstract="true" id="GLIST_PQ.TIME-3">
            <sch:assert test="count(*[self::head or self::increment][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="head" type="PQ.TIME"/>
          <xsd:element minOccurs="0" name="increment" type="QTY"/>
        </xsd:sequence>
        <xsd:attribute name="denominator" type="xsd:int" use="optional"/>
        <xsd:attribute name="period" type="xsd:int" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="GLIST_REAL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="required attributes">
          <sch:rule abstract="true" id="GLIST_REAL-0">
            <sch:assert test="@nullFlavor or (head and not(head\@nullFlavor) and increment and not(increment\@nullFlavor) and @denominator)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="denominator must be positive">
          <sch:rule abstract="true" id="GLIST_REAL-1">
            <sch:assert test="not(@denominator) or (@denominator > 0)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="period must be positive">
          <sch:rule abstract="true" id="GLIST_REAL-2">
            <sch:assert test="todo"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on GLIST attributes">
          <sch:rule abstract="true" id="GLIST_REAL-3">
            <sch:assert test="count(*[self::head or self::increment][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="head" type="REAL"/>
          <xsd:element minOccurs="0" name="increment" type="QTY"/>
        </xsd:sequence>
        <xsd:attribute name="denominator" type="xsd:int" use="optional"/>
        <xsd:attribute name="period" type="xsd:int" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="GLIST_INT">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="required attributes">
          <sch:rule abstract="true" id="GLIST_INT-0">
            <sch:assert test="@nullFlavor or (head and not(head\@nullFlavor) and increment and not(increment\@nullFlavor) and @denominator)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="denominator must be positive">
          <sch:rule abstract="true" id="GLIST_INT-1">
            <sch:assert test="not(@denominator) or (@denominator > 0)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="period must be positive">
          <sch:rule abstract="true" id="GLIST_INT-2">
            <sch:assert test="todo"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on GLIST attributes">
          <sch:rule abstract="true" id="GLIST_INT-3">
            <sch:assert test="count(*[self::head or self::increment][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="head" type="INT"/>
          <xsd:element minOccurs="0" name="increment" type="QTY"/>
        </xsd:sequence>
        <xsd:attribute name="denominator" type="xsd:int" use="optional"/>
        <xsd:attribute name="period" type="xsd:int" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="GLIST_INT.NONNEG">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="required attributes">
          <sch:rule abstract="true" id="GLIST_INT.NONNEG-0">
            <sch:assert test="@nullFlavor or (head and not(head\@nullFlavor) and increment and not(increment\@nullFlavor) and @denominator)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="denominator must be positive">
          <sch:rule abstract="true" id="GLIST_INT.NONNEG-1">
            <sch:assert test="not(@denominator) or (@denominator > 0)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="period must be positive">
          <sch:rule abstract="true" id="GLIST_INT.NONNEG-2">
            <sch:assert test="todo"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on GLIST attributes">
          <sch:rule abstract="true" id="GLIST_INT.NONNEG-3">
            <sch:assert test="count(*[self::head or self::increment][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="head" type="INT.NONNEG"/>
          <xsd:element minOccurs="0" name="increment" type="QTY"/>
        </xsd:sequence>
        <xsd:attribute name="denominator" type="xsd:int" use="optional"/>
        <xsd:attribute name="period" type="xsd:int" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="GLIST_INT.POS">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="required attributes">
          <sch:rule abstract="true" id="GLIST_INT.POS-0">
            <sch:assert test="@nullFlavor or (head and not(head\@nullFlavor) and increment and not(increment\@nullFlavor) and @denominator)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="denominator must be positive">
          <sch:rule abstract="true" id="GLIST_INT.POS-1">
            <sch:assert test="not(@denominator) or (@denominator > 0)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="period must be positive">
          <sch:rule abstract="true" id="GLIST_INT.POS-2">
            <sch:assert test="todo"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on GLIST attributes">
          <sch:rule abstract="true" id="GLIST_INT.POS-3">
            <sch:assert test="count(*[self::head or self::increment][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="head" type="INT.POS"/>
          <xsd:element minOccurs="0" name="increment" type="QTY"/>
        </xsd:sequence>
        <xsd:attribute name="denominator" type="xsd:int" use="optional"/>
        <xsd:attribute name="period" type="xsd:int" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSD_CO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSD_CO-0">
            <sch:assert test="@nullFlavor or (not(first/@nullFlavor) and not(second/@nullFlavor))"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_CO">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="first" type="QSET_CO"/>
          <xsd:element minOccurs="0" name="second" type="QSET_CO"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSD_TS">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSD_TS-0">
            <sch:assert test="@nullFlavor or (not(first/@nullFlavor) and not(second/@nullFlavor))"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_TS">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="first" type="QSET_TS"/>
          <xsd:element minOccurs="0" name="second" type="QSET_TS"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSD_TS.DATE">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSD_TS.DATE-0">
            <sch:assert test="@nullFlavor or (not(first/@nullFlavor) and not(second/@nullFlavor))"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_TS.DATE">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="first" type="QSET_TS.DATE"/>
          <xsd:element minOccurs="0" name="second" type="QSET_TS.DATE"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSD_TS.DATE.FULL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSD_TS.DATE.FULL-0">
            <sch:assert test="@nullFlavor or (not(first/@nullFlavor) and not(second/@nullFlavor))"/>
          </sch:rule>
          © 313
ISO 2008  All rights reserved
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_TS.DATE.FULL">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="first" type="QSET_TS.DATE.FULL"/>
          <xsd:element minOccurs="0" name="second" type="QSET_TS.DATE.FULL"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSD_TS.DATETIME">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSD_TS.DATETIME-0">
            <sch:assert test="@nullFlavor or (not(first/@nullFlavor) and not(second/@nullFlavor))"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_TS.DATETIME">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="first" type="QSET_TS.DATETIME"/>
          <xsd:element minOccurs="0" name="second" type="QSET_TS.DATETIME"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSD_TS.DATETIME.FULL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSD_TS.DATETIME.FULL-0">
            <sch:assert test="@nullFlavor or (not(first/@nullFlavor) and not(second/@nullFlavor))"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_TS.DATETIME.FULL">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="first" type="QSET_TS.DATETIME.FULL"/>
          <xsd:element minOccurs="0" name="second" type="QSET_TS.DATETIME.FULL"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSD_TS.BIRTH">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSD_TS.BIRTH-0">
            <sch:assert test="@nullFlavor or (not(first/@nullFlavor) and not(second/@nullFlavor))"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_TS.BIRTH">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="first" type="QSET_TS.BIRTH"/>
          <xsd:element minOccurs="0" name="second" type="QSET_TS.BIRTH"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSD_RTO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSD_RTO-0">
            <sch:assert test="@nullFlavor or (not(first/@nullFlavor) and not(second/@nullFlavor))"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_RTO">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="first" type="QSET_RTO"/>
          <xsd:element minOccurs="0" name="second" type="QSET_RTO"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSD_MO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSD_MO-0">
            <sch:assert test="@nullFlavor or (not(first/@nullFlavor) and not(second/@nullFlavor))"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_MO">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="first" type="QSET_MO"/>
          <xsd:element minOccurs="0" name="second" type="QSET_MO"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSD_PQ">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSD_PQ-0">
            <sch:assert test="@nullFlavor or (not(first/@nullFlavor) and not(second/@nullFlavor))"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_PQ">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="first" type="QSET_PQ"/>
          <xsd:element minOccurs="0" name="second" type="QSET_PQ"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSD_PQ.TIME">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSD_PQ.TIME-0">
            <sch:assert test="@nullFlavor or (not(first/@nullFlavor) and not(second/@nullFlavor))"/>
          </sch:rule>
        </sch:pattern>
        © 315
ISO 2008  All rights reserved
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_PQ.TIME">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="first" type="QSET_PQ.TIME"/>
          <xsd:element minOccurs="0" name="second" type="QSET_PQ.TIME"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSD_REAL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSD_REAL-0">
            <sch:assert test="@nullFlavor or (not(first/@nullFlavor) and not(second/@nullFlavor))"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_REAL">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="first" type="QSET_REAL"/>
          <xsd:element minOccurs="0" name="second" type="QSET_REAL"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSD_INT">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSD_INT-0">
            <sch:assert test="@nullFlavor or (not(first/@nullFlavor) and not(second/@nullFlavor))"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_INT">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="first" type="QSET_INT"/>
          <xsd:element minOccurs="0" name="second" type="QSET_INT"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSD_INT.NONNEG">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSD_INT.NONNEG-0">
            <sch:assert test="@nullFlavor or (not(first/@nullFlavor) and not(second/@nullFlavor))"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_INT.NONNEG">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="first" type="QSET_INT.NONNEG"/>
          <xsd:element minOccurs="0" name="second" type="QSET_INT.NONNEG"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSD_INT.POS">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSD_INT.POS-0">
            <sch:assert test="@nullFlavor or (not(first/@nullFlavor) and not(second/@nullFlavor))"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_INT.POS">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="first" type="QSET_INT.POS"/>
          <xsd:element minOccurs="0" name="second" type="QSET_INT.POS"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSI_CO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSI_CO-0">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSI_CO-1">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) >= 2)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_CO">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="term" type="QSET_CO"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSI_TS">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSI_TS-0">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSI_TS-1">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) >= 2)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_TS">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="term" type="QSET_TS"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSI_TS.DATE">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSI_TS.DATE-0">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
            © 317
ISO 2008  All rights reserved
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSI_TS.DATE-1">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) >= 2)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_TS.DATE">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="term" type="QSET_TS.DATE"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSI_TS.DATE.FULL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSI_TS.DATE.FULL-0">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSI_TS.DATE.FULL-1">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) >= 2)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_TS.DATE.FULL">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="term" type="QSET_TS.DATE.FULL"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSI_TS.DATETIME">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSI_TS.DATETIME-0">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSI_TS.DATETIME-1">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) >= 2)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_TS.DATETIME">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="term" type="QSET_TS.DATETIME"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSI_TS.DATETIME.FULL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSI_TS.DATETIME.FULL-0">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSI_TS.DATETIME.FULL-1">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) >= 2)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_TS.DATETIME.FULL">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="term" type="QSET_TS.DATETIME.FULL"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSI_TS.BIRTH">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSI_TS.BIRTH-0">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSI_TS.BIRTH-1">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) >= 2)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_TS.BIRTH">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="term" type="QSET_TS.BIRTH"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSI_RTO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSI_RTO-0">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSI_RTO-1">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) >= 2)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_RTO">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="term" type="QSET_RTO"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSI_MO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSI_MO-0">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
          </sch:rule>
        </sch:pattern>
        © 319
ISO 2008  All rights reserved
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSI_MO-1">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) >= 2)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_MO">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="term" type="QSET_MO"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSI_PQ">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSI_PQ-0">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSI_PQ-1">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) >= 2)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_PQ">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="term" type="QSET_PQ"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSI_PQ.TIME">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSI_PQ.TIME-0">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSI_PQ.TIME-1">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) >= 2)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_PQ.TIME">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="term" type="QSET_PQ.TIME"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSI_REAL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSI_REAL-0">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSI_REAL-1">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) >= 2)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_REAL">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="term" type="QSET_REAL"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSI_INT">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSI_INT-0">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSI_INT-1">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) >= 2)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_INT">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="term" type="QSET_INT"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSI_INT.NONNEG">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSI_INT.NONNEG-0">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSI_INT.NONNEG-1">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) >= 2)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_INT.NONNEG">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="term" type="QSET_INT.NONNEG"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSI_INT.POS">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSI_INT.POS-0">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSI_INT.POS-1">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) >= 2)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_INT.POS">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="term" type="QSET_INT.POS"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSU_CO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSU_CO-0">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSU_CO-1">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) >= 2)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_CO">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="term" type="QSET_CO"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSU_TS">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSU_TS-0">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSU_TS-1">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) >= 2)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_TS">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="term" type="QSET_TS"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSU_TS.DATE">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSU_TS.DATE-0">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSU_TS.DATE-1">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) >= 2)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_TS.DATE">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="term" type="QSET_TS.DATE"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSU_TS.DATE.FULL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSU_TS.DATE.FULL-0">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSU_TS.DATE.FULL-1">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) >= 2)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_TS.DATE.FULL">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="term" type="QSET_TS.DATE.FULL"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSU_TS.DATETIME">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSU_TS.DATETIME-0">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSU_TS.DATETIME-1">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) >= 2)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_TS.DATETIME">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="term" type="QSET_TS.DATETIME"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSU_TS.DATETIME.FULL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSU_TS.DATETIME.FULL-0">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSU_TS.DATETIME.FULL-1">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) >= 2)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_TS.DATETIME.FULL">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="term" type="QSET_TS.DATETIME.FULL"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSU_TS.BIRTH">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSU_TS.BIRTH-0">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSU_TS.BIRTH-1">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) >= 2)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_TS.BIRTH">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="term" type="QSET_TS.BIRTH"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSU_RTO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSU_RTO-0">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSU_RTO-1">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) >= 2)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_RTO">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="term" type="QSET_RTO"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSU_MO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSU_MO-0">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSU_MO-1">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) >= 2)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_MO">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="term" type="QSET_MO"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSU_PQ">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSU_PQ-0">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSU_PQ-1">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) >= 2)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_PQ">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="term" type="QSET_PQ"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSU_PQ.TIME">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSU_PQ.TIME-0">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSU_PQ.TIME-1">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) >= 2)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_PQ.TIME">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="term" type="QSET_PQ.TIME"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSU_REAL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSU_REAL-0">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSU_REAL-1">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) >= 2)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_REAL">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="term" type="QSET_REAL"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSU_INT">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSU_INT-0">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSU_INT-1">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) >= 2)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_INT">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="term" type="QSET_INT"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSU_INT.NONNEG">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSU_INT.NONNEG-0">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSU_INT.NONNEG-1">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) >= 2)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_INT.NONNEG">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="term" type="QSET_INT.NONNEG"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSU_INT.POS">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSU_INT.POS-0">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSU_INT.POS-1">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) >= 2)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_INT.POS">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="term" type="QSET_INT.POS"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSP_CO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSP_CO-0">
            <sch:assert test="@nullFlavor or (not(first/@nullFlavor) and not(second/@nullFlavor))"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_CO">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="first" type="QSET_CO"/>
          <xsd:element minOccurs="0" name="second" type="QSET_CO"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSP_TS">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSP_TS-0">
            <sch:assert test="@nullFlavor or (not(first/@nullFlavor) and not(second/@nullFlavor))"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_TS">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="first" type="QSET_TS"/>
          <xsd:element minOccurs="0" name="second" type="QSET_TS"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSP_TS.DATE">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSP_TS.DATE-0">
            <sch:assert test="@nullFlavor or (not(first/@nullFlavor) and not(second/@nullFlavor))"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_TS.DATE">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="first" type="QSET_TS.DATE"/>
          <xsd:element minOccurs="0" name="second" type="QSET_TS.DATE"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSP_TS.DATE.FULL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSP_TS.DATE.FULL-0">
            <sch:assert test="@nullFlavor or (not(first/@nullFlavor) and not(second/@nullFlavor))"/>
          </sch:rule>
        </sch:pattern>
        © 327
ISO 2008  All rights reserved
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_TS.DATE.FULL">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="first" type="QSET_TS.DATE.FULL"/>
          <xsd:element minOccurs="0" name="second" type="QSET_TS.DATE.FULL"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSP_TS.DATETIME">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSP_TS.DATETIME-0">
            <sch:assert test="@nullFlavor or (not(first/@nullFlavor) and not(second/@nullFlavor))"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_TS.DATETIME">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="first" type="QSET_TS.DATETIME"/>
          <xsd:element minOccurs="0" name="second" type="QSET_TS.DATETIME"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSP_TS.DATETIME.FULL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSP_TS.DATETIME.FULL-0">
            <sch:assert test="@nullFlavor or (not(first/@nullFlavor) and not(second/@nullFlavor))"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_TS.DATETIME.FULL">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="first" type="QSET_TS.DATETIME.FULL"/>
          <xsd:element minOccurs="0" name="second" type="QSET_TS.DATETIME.FULL"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSP_TS.BIRTH">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSP_TS.BIRTH-0">
            <sch:assert test="@nullFlavor or (not(first/@nullFlavor) and not(second/@nullFlavor))"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_TS.BIRTH">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="first" type="QSET_TS.BIRTH"/>
          <xsd:element minOccurs="0" name="second" type="QSET_TS.BIRTH"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSP_RTO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSP_RTO-0">
            <sch:assert test="@nullFlavor or (not(first/@nullFlavor) and not(second/@nullFlavor))"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_RTO">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="first" type="QSET_RTO"/>
          <xsd:element minOccurs="0" name="second" type="QSET_RTO"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSP_MO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSP_MO-0">
            <sch:assert test="@nullFlavor or (not(first/@nullFlavor) and not(second/@nullFlavor))"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_MO">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="first" type="QSET_MO"/>
          <xsd:element minOccurs="0" name="second" type="QSET_MO"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSP_PQ">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSP_PQ-0">
            <sch:assert test="@nullFlavor or (not(first/@nullFlavor) and not(second/@nullFlavor))"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_PQ">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="first" type="QSET_PQ"/>
          <xsd:element minOccurs="0" name="second" type="QSET_PQ"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSP_PQ.TIME">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSP_PQ.TIME-0">
            <sch:assert test="@nullFlavor or (not(first/@nullFlavor) and not(second/@nullFlavor))"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_PQ.TIME">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="first" type="QSET_PQ.TIME"/>
          <xsd:element minOccurs="0" name="second" type="QSET_PQ.TIME"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSP_REAL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSP_REAL-0">
            <sch:assert test="@nullFlavor or (not(first/@nullFlavor) and not(second/@nullFlavor))"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_REAL">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="first" type="QSET_REAL"/>
          <xsd:element minOccurs="0" name="second" type="QSET_REAL"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSP_INT">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSP_INT-0">
            <sch:assert test="@nullFlavor or (not(first/@nullFlavor) and not(second/@nullFlavor))"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_INT">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="first" type="QSET_INT"/>
          <xsd:element minOccurs="0" name="second" type="QSET_INT"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSP_INT.NONNEG">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSP_INT.NONNEG-0">
            <sch:assert test="@nullFlavor or (not(first/@nullFlavor) and not(second/@nullFlavor))"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_INT.NONNEG">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="first" type="QSET_INT.NONNEG"/>
          <xsd:element minOccurs="0" name="second" type="QSET_INT.NONNEG"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSP_INT.POS">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSP_INT.POS-0">
            <sch:assert test="@nullFlavor or (not(first/@nullFlavor) and not(second/@nullFlavor))"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_INT.POS">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="first" type="QSET_INT.POS"/>
          <xsd:element minOccurs="0" name="second" type="QSET_INT.POS"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSS_CO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSS_CO-0">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSS_CO-1">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) >= 1)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSS_CO-2">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSS_CO-3">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) >= 1)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_CO">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="term" type="CO"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSS_TS">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSS_TS-0">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSS_TS-1">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) >= 1)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSS_TS-2">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSS_TS-3">
            © 331
ISO 2008  All rights reserved
            <sch:assert test="@nullFlavor or (count(*[self::terms]) >= 1)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_TS">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="term" type="TS"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSS_TS.DATE">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSS_TS.DATE-0">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSS_TS.DATE-1">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) >= 1)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSS_TS.DATE-2">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSS_TS.DATE-3">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) >= 1)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_TS.DATE">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="term" type="TS.DATE"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSS_TS.DATE.FULL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSS_TS.DATE.FULL-0">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSS_TS.DATE.FULL-1">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) >= 1)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSS_TS.DATE.FULL-2">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSS_TS.DATE.FULL-3">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) >= 1)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_TS.DATE.FULL">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="term" type="TS.DATE.FULL"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSS_TS.DATETIME">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSS_TS.DATETIME-0">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSS_TS.DATETIME-1">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) >= 1)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSS_TS.DATETIME-2">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSS_TS.DATETIME-3">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) >= 1)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_TS.DATETIME">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="term" type="TS.DATETIME"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSS_TS.DATETIME.FULL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSS_TS.DATETIME.FULL-0">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSS_TS.DATETIME.FULL-1">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) >= 1)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSS_TS.DATETIME.FULL-2">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSS_TS.DATETIME.FULL-3">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) >= 1)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_TS.DATETIME.FULL">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="term" type="TS.DATETIME.FULL"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSS_TS.BIRTH">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSS_TS.BIRTH-0">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSS_TS.BIRTH-1">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) >= 1)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSS_TS.BIRTH-2">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSS_TS.BIRTH-3">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) >= 1)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_TS.BIRTH">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="term" type="TS.BIRTH"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSS_RTO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSS_RTO-0">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSS_RTO-1">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) >= 1)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSS_RTO-2">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSS_RTO-3">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) >= 1)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_RTO">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="term" type="RTO"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSS_MO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSS_MO-0">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSS_MO-1">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) >= 1)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSS_MO-2">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSS_MO-3">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) >= 1)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_MO">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="term" type="MO"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSS_PQ">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSS_PQ-0">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSS_PQ-1">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) >= 1)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSS_PQ-2">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSS_PQ-3">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) >= 1)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_PQ">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="term" type="PQ"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSS_PQ.TIME">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSS_PQ.TIME-0">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSS_PQ.TIME-1">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) >= 1)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSS_PQ.TIME-2">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSS_PQ.TIME-3">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) >= 1)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_PQ.TIME">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="term" type="PQ.TIME"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSS_REAL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSS_REAL-0">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSS_REAL-1">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) >= 1)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSS_REAL-2">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSS_REAL-3">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) >= 1)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_REAL">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="term" type="REAL"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSS_INT">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSS_INT-0">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSS_INT-1">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) >= 1)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSS_INT-2">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSS_INT-3">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) >= 1)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_INT">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="term" type="INT"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSS_INT.NONNEG">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSS_INT.NONNEG-0">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSS_INT.NONNEG-1">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) >= 1)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSS_INT.NONNEG-2">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSS_INT.NONNEG-3">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) >= 1)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_INT.NONNEG">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="term" type="INT.NONNEG"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSS_INT.POS">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSS_INT.POS-0">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSS_INT.POS-1">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) >= 1)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSS_INT.POS-2">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSS_INT.POS-3">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) >= 1)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_INT.POS">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="term" type="INT.POS"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="PIVL_TS">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="period or frequency">
          <sch:rule abstract="true" id="PIVL_TS-0">
            <sch:assert test="not(period) or not(frequency)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on PIVL attributes">
          <sch:rule abstract="true" id="PIVL_TS-1">
            <sch:assert test="count(*[self::phase or self::period][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_TS">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="phase" type="IVL_TS"/>
          <xsd:element minOccurs="0" name="period" type="PQ"/>
          <xsd:element minOccurs="0" name="frequency" type="RTO"/>
          <xsd:element minOccurs="0" name="count" type="INT.POS"/>
        </xsd:sequence>
        <xsd:attribute name="alignment" type="CalendarCycle" use="optional"/>
        <xsd:attribute name="isFlexible" type="xsd:boolean" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="PIVL_TS.DATE">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="period or frequency">
          <sch:rule abstract="true" id="PIVL_TS.DATE-0">
            <sch:assert test="not(period) or not(frequency)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on PIVL attributes">
          <sch:rule abstract="true" id="PIVL_TS.DATE-1">
            <sch:assert test="count(*[self::phase or self::period][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_TS.DATE">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="phase" type="IVL_TS.DATE"/>
          <xsd:element minOccurs="0" name="period" type="PQ"/>
          <xsd:element minOccurs="0" name="frequency" type="RTO"/>
          <xsd:element minOccurs="0" name="count" type="INT.POS"/>
        </xsd:sequence>
        <xsd:attribute name="alignment" type="CalendarCycle" use="optional"/>
        <xsd:attribute name="isFlexible" type="xsd:boolean" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="PIVL_TS.DATE.FULL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="period or frequency">
          <sch:rule abstract="true" id="PIVL_TS.DATE.FULL-0">
            <sch:assert test="not(period) or not(frequency)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on PIVL attributes">
          <sch:rule abstract="true" id="PIVL_TS.DATE.FULL-1">
            <sch:assert test="count(*[self::phase or self::period][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_TS.DATE.FULL">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="phase" type="IVL_TS.DATE.FULL"/>
          <xsd:element minOccurs="0" name="period" type="PQ"/>
          <xsd:element minOccurs="0" name="frequency" type="RTO"/>
          <xsd:element minOccurs="0" name="count" type="INT.POS"/>
        </xsd:sequence>
        <xsd:attribute name="alignment" type="CalendarCycle" use="optional"/>
        <xsd:attribute name="isFlexible" type="xsd:boolean" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="PIVL_TS.DATETIME">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="period or frequency">
          <sch:rule abstract="true" id="PIVL_TS.DATETIME-0">
            <sch:assert test="not(period) or not(frequency)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on PIVL attributes">
          <sch:rule abstract="true" id="PIVL_TS.DATETIME-1">
            <sch:assert test="count(*[self::phase or self::period][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_TS.DATETIME">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="phase" type="IVL_TS.DATETIME"/>
          <xsd:element minOccurs="0" name="period" type="PQ"/>
          <xsd:element minOccurs="0" name="frequency" type="RTO"/>
          <xsd:element minOccurs="0" name="count" type="INT.POS"/>
        </xsd:sequence>
        <xsd:attribute name="alignment" type="CalendarCycle" use="optional"/>
        <xsd:attribute name="isFlexible" type="xsd:boolean" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="PIVL_TS.DATETIME.FULL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="period or frequency">
          <sch:rule abstract="true" id="PIVL_TS.DATETIME.FULL-0">
            <sch:assert test="not(period) or not(frequency)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on PIVL attributes">
          <sch:rule abstract="true" id="PIVL_TS.DATETIME.FULL-1">
            <sch:assert test="count(*[self::phase or self::period][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
          © 339
ISO 2008  All rights reserved
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_TS.DATETIME.FULL">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="phase" type="IVL_TS.DATETIME.FULL"/>
          <xsd:element minOccurs="0" name="period" type="PQ"/>
          <xsd:element minOccurs="0" name="frequency" type="RTO"/>
          <xsd:element minOccurs="0" name="count" type="INT.POS"/>
        </xsd:sequence>
        <xsd:attribute name="alignment" type="CalendarCycle" use="optional"/>
        <xsd:attribute name="isFlexible" type="xsd:boolean" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="PIVL_TS.BIRTH">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="period or frequency">
          <sch:rule abstract="true" id="PIVL_TS.BIRTH-0">
            <sch:assert test="not(period) or not(frequency)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on PIVL attributes">
          <sch:rule abstract="true" id="PIVL_TS.BIRTH-1">
            <sch:assert test="count(*[self::phase or self::period][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_TS.BIRTH">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="phase" type="IVL_TS.BIRTH"/>
          <xsd:element minOccurs="0" name="period" type="PQ"/>
          <xsd:element minOccurs="0" name="frequency" type="RTO"/>
          <xsd:element minOccurs="0" name="count" type="INT.POS"/>
        </xsd:sequence>
        <xsd:attribute name="alignment" type="CalendarCycle" use="optional"/>
        <xsd:attribute name="isFlexible" type="xsd:boolean" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="EIVL_TS">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="required attributes">
          <sch:rule abstract="true" id="EIVL_TS-0">
            <sch:assert test="@nullFlavor or (event)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on EIVL attributes">
          <sch:rule abstract="true" id="EIVL_TS-1">
            <sch:assert test="count(*[self::offset][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_TS">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="offset" type="IVL_PQ"/>
        </xsd:sequence>
        <xsd:attribute name="event" type="TimingEvent" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="EIVL_TS.DATE">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="required attributes">
          <sch:rule abstract="true" id="EIVL_TS.DATE-0">
            <sch:assert test="@nullFlavor or (event)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on EIVL attributes">
          <sch:rule abstract="true" id="EIVL_TS.DATE-1">
            <sch:assert test="count(*[self::offset][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_TS.DATE">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="offset" type="IVL_PQ"/>
        </xsd:sequence>
        <xsd:attribute name="event" type="TimingEvent" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="EIVL_TS.DATE.FULL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="required attributes">
          <sch:rule abstract="true" id="EIVL_TS.DATE.FULL-0">
            <sch:assert test="@nullFlavor or (event)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on EIVL attributes">
          <sch:rule abstract="true" id="EIVL_TS.DATE.FULL-1">
            <sch:assert test="count(*[self::offset][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_TS.DATE.FULL">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="offset" type="IVL_PQ"/>
        </xsd:sequence>
        <xsd:attribute name="event" type="TimingEvent" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="EIVL_TS.DATETIME">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="required attributes">
          <sch:rule abstract="true" id="EIVL_TS.DATETIME-0">
            <sch:assert test="@nullFlavor or (event)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on EIVL attributes">
          <sch:rule abstract="true" id="EIVL_TS.DATETIME-1">
            <sch:assert test="count(*[self::offset][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_TS.DATETIME">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="offset" type="IVL_PQ"/>
        </xsd:sequence>
        <xsd:attribute name="event" type="TimingEvent" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="EIVL_TS.DATETIME.FULL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="required attributes">
          <sch:rule abstract="true" id="EIVL_TS.DATETIME.FULL-0">
            <sch:assert test="@nullFlavor or (event)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on EIVL attributes">
          <sch:rule abstract="true" id="EIVL_TS.DATETIME.FULL-1">
            <sch:assert test="count(*[self::offset][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_TS.DATETIME.FULL">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="offset" type="IVL_PQ"/>
        </xsd:sequence>
        <xsd:attribute name="event" type="TimingEvent" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="EIVL_TS.BIRTH">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="required attributes">
          <sch:rule abstract="true" id="EIVL_TS.BIRTH-0">
            <sch:assert test="@nullFlavor or (event)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on EIVL attributes">
          <sch:rule abstract="true" id="EIVL_TS.BIRTH-1">
            <sch:assert test="count(*[self::offset][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_TS.BIRTH">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="offset" type="IVL_PQ"/>
        </xsd:sequence>
        <xsd:attribute name="event" type="TimingEvent" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="NPPD_BL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="must have at least one item">
          <sch:rule abstract="true" id="NPPD_BL-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="UVP_BL"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="UVP_BL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="value not null">
          <sch:rule abstract="true" id="UVP_BL-0">
            <sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="must have probability">
          <sch:rule abstract="true" id="UVP_BL-1">
            <sch:assert test="@nullFlavor or @probability"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="UVP_BL-2">
            <sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="value" type="BL"/>
        </xsd:sequence>
        <xsd:attribute name="probability" type="xsd:double" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="NPPD_BL.NONNULL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="must have at least one item">
          <sch:rule abstract="true" id="NPPD_BL.NONNULL-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="UVP_BL.NONNULL"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="UVP_BL.NONNULL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="value not null">
          <sch:rule abstract="true" id="UVP_BL.NONNULL-0">
            <sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="must have probability">
          <sch:rule abstract="true" id="UVP_BL.NONNULL-1">
            <sch:assert test="@nullFlavor or @probability"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="UVP_BL.NONNULL-2">
            <sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="value" type="BL.NONNULL"/>
        </xsd:sequence>
        <xsd:attribute name="probability" type="xsd:double" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="NPPD_ED">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="must have at least one item">
          <sch:rule abstract="true" id="NPPD_ED-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="UVP_ED"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="UVP_ED">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="value not null">
          <sch:rule abstract="true" id="UVP_ED-0">
            <sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="must have probability">
          <sch:rule abstract="true" id="UVP_ED-1">
            <sch:assert test="@nullFlavor or @probability"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="UVP_ED-2">
            <sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="value" type="ED"/>
        </xsd:sequence>
        <xsd:attribute name="probability" type="xsd:double" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="NPPD_ED.IMAGE">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="must have at least one item">
          <sch:rule abstract="true" id="NPPD_ED.IMAGE-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="UVP_ED.IMAGE"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="UVP_ED.IMAGE">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="value not null">
          <sch:rule abstract="true" id="UVP_ED.IMAGE-0">
            <sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="must have probability">
          <sch:rule abstract="true" id="UVP_ED.IMAGE-1">
            <sch:assert test="@nullFlavor or @probability"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="UVP_ED.IMAGE-2">
            <sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="value" type="ED.IMAGE"/>
        </xsd:sequence>
        <xsd:attribute name="probability" type="xsd:double" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="NPPD_ED.TEXT">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="must have at least one item">
          <sch:rule abstract="true" id="NPPD_ED.TEXT-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="UVP_ED.TEXT"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="UVP_ED.TEXT">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="value not null">
          <sch:rule abstract="true" id="UVP_ED.TEXT-0">
            <sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="must have probability">
          <sch:rule abstract="true" id="UVP_ED.TEXT-1">
            <sch:assert test="@nullFlavor or @probability"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="UVP_ED.TEXT-2">
            <sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="value" type="ED.TEXT"/>
        </xsd:sequence>
        <xsd:attribute name="probability" type="xsd:double" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="NPPD_ED.DOC">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="must have at least one item">
          <sch:rule abstract="true" id="NPPD_ED.DOC-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="UVP_ED.DOC"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="UVP_ED.DOC">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="value not null">
          <sch:rule abstract="true" id="UVP_ED.DOC-0">
            <sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="must have probability">
          <sch:rule abstract="true" id="UVP_ED.DOC-1">
            <sch:assert test="@nullFlavor or @probability"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="UVP_ED.DOC-2">
            <sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="value" type="ED.DOC"/>
        </xsd:sequence>
        <xsd:attribute name="probability" type="xsd:double" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="NPPD_ED.DOC.REF">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="must have at least one item">
          <sch:rule abstract="true" id="NPPD_ED.DOC.REF-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="UVP_ED.DOC.REF"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="UVP_ED.DOC.REF">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="value not null">
          <sch:rule abstract="true" id="UVP_ED.DOC.REF-0">
            <sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="must have probability">
          <sch:rule abstract="true" id="UVP_ED.DOC.REF-1">
            <sch:assert test="@nullFlavor or @probability"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="UVP_ED.DOC.REF-2">
            <sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="value" type="ED.DOC.REF"/>
        </xsd:sequence>
        <xsd:attribute name="probability" type="xsd:double" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="NPPD_ED.DOC.INLINE">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="must have at least one item">
          <sch:rule abstract="true" id="NPPD_ED.DOC.INLINE-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="UVP_ED.DOC.INLINE"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="UVP_ED.DOC.INLINE">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="value not null">
          <sch:rule abstract="true" id="UVP_ED.DOC.INLINE-0">
            <sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="must have probability">
          <sch:rule abstract="true" id="UVP_ED.DOC.INLINE-1">
            <sch:assert test="@nullFlavor or @probability"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="UVP_ED.DOC.INLINE-2">
            <sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="value" type="ED.DOC.INLINE"/>
        </xsd:sequence>
        <xsd:attribute name="probability" type="xsd:double" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="NPPD_ED.SIGNATURE">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="must have at least one item">
          <sch:rule abstract="true" id="NPPD_ED.SIGNATURE-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="UVP_ED.SIGNATURE"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="UVP_ED.SIGNATURE">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="value not null">
          <sch:rule abstract="true" id="UVP_ED.SIGNATURE-0">
            <sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="must have probability">
          <sch:rule abstract="true" id="UVP_ED.SIGNATURE-1">
            <sch:assert test="@nullFlavor or @probability"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="UVP_ED.SIGNATURE-2">
            <sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="value" type="ED.SIGNATURE"/>
        </xsd:sequence>
        <xsd:attribute name="probability" type="xsd:double" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="NPPD_ED.STRUCTUREDTEXT">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="must have at least one item">
          <sch:rule abstract="true" id="NPPD_ED.STRUCTUREDTEXT-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="UVP_ED.STRUCTUREDTEXT"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="UVP_ED.STRUCTUREDTEXT">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="value not null">
          <sch:rule abstract="true" id="UVP_ED.STRUCTUREDTEXT-0">
            <sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="must have probability">
          <sch:rule abstract="true" id="UVP_ED.STRUCTUREDTEXT-1">
            <sch:assert test="@nullFlavor or @probability"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="UVP_ED.STRUCTUREDTEXT-2">
            <sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="value" type="ED.STRUCTUREDTEXT"/>
        </xsd:sequence>
        <xsd:attribute name="probability" type="xsd:double" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="NPPD_ST">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="must have at least one item">
          <sch:rule abstract="true" id="NPPD_ST-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="UVP_ST"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="UVP_ST">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="value not null">
          <sch:rule abstract="true" id="UVP_ST-0">
            <sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="must have probability">
          <sch:rule abstract="true" id="UVP_ST-1">
            <sch:assert test="@nullFlavor or @probability"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="UVP_ST-2">
            <sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="value" type="ST"/>
        </xsd:sequence>
        <xsd:attribute name="probability" type="xsd:double" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="NPPD_ST.NT">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="must have at least one item">
          <sch:rule abstract="true" id="NPPD_ST.NT-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="UVP_ST.NT"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="UVP_ST.NT">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="value not null">
          <sch:rule abstract="true" id="UVP_ST.NT-0">
            <sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="must have probability">
          <sch:rule abstract="true" id="UVP_ST.NT-1">
            <sch:assert test="@nullFlavor or @probability"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="UVP_ST.NT-2">
            <sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="value" type="ST.NT"/>
        </xsd:sequence>
        <xsd:attribute name="probability" type="xsd:double" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="NPPD_SC">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="must have at least one item">
          <sch:rule abstract="true" id="NPPD_SC-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="UVP_SC"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="UVP_SC">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="value not null">
          <sch:rule abstract="true" id="UVP_SC-0">
            <sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="must have probability">
          <sch:rule abstract="true" id="UVP_SC-1">
            <sch:assert test="@nullFlavor or @probability"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="UVP_SC-2">
            <sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="value" type="SC"/>
        </xsd:sequence>
        <xsd:attribute name="probability" type="xsd:double" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="NPPD_SC.NT">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="must have at least one item">
          <sch:rule abstract="true" id="NPPD_SC.NT-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="UVP_SC.NT"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="UVP_SC.NT">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="value not null">
          <sch:rule abstract="true" id="UVP_SC.NT-0">
            <sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="must have probability">
          <sch:rule abstract="true" id="UVP_SC.NT-1">
            <sch:assert test="@nullFlavor or @probability"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="UVP_SC.NT-2">
            © 351
ISO 2008  All rights reserved
            <sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="value" type="SC.NT"/>
        </xsd:sequence>
        <xsd:attribute name="probability" type="xsd:double" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="NPPD_TEL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="must have at least one item">
          <sch:rule abstract="true" id="NPPD_TEL-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="UVP_TEL"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="UVP_TEL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="value not null">
          <sch:rule abstract="true" id="UVP_TEL-0">
            <sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="must have probability">
          <sch:rule abstract="true" id="UVP_TEL-1">
            <sch:assert test="@nullFlavor or @probability"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="UVP_TEL-2">
            <sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="value" type="TEL"/>
        </xsd:sequence>
        <xsd:attribute name="probability" type="xsd:double" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="NPPD_TEL.EMAIL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="must have at least one item">
          <sch:rule abstract="true" id="NPPD_TEL.EMAIL-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="UVP_TEL.EMAIL"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="UVP_TEL.EMAIL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="value not null">
          <sch:rule abstract="true" id="UVP_TEL.EMAIL-0">
            <sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="must have probability">
          <sch:rule abstract="true" id="UVP_TEL.EMAIL-1">
            <sch:assert test="@nullFlavor or @probability"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="UVP_TEL.EMAIL-2">
            <sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="value" type="TEL.EMAIL"/>
        </xsd:sequence>
        <xsd:attribute name="probability" type="xsd:double" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="NPPD_TEL.PERSON">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="must have at least one item">
          <sch:rule abstract="true" id="NPPD_TEL.PERSON-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="UVP_TEL.PERSON"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="UVP_TEL.PERSON">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="value not null">
          <sch:rule abstract="true" id="UVP_TEL.PERSON-0">
            <sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="must have probability">
          <sch:rule abstract="true" id="UVP_TEL.PERSON-1">
            <sch:assert test="@nullFlavor or @probability"/>
          </sch:rule>
        </sch:pattern>
        © 353
ISO 2008  All rights reserved
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="UVP_TEL.PERSON-2">
            <sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="value" type="TEL.PERSON"/>
        </xsd:sequence>
        <xsd:attribute name="probability" type="xsd:double" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="NPPD_TEL.PHONE">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="must have at least one item">
          <sch:rule abstract="true" id="NPPD_TEL.PHONE-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="UVP_TEL.PHONE"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="UVP_TEL.PHONE">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="value not null">
          <sch:rule abstract="true" id="UVP_TEL.PHONE-0">
            <sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="must have probability">
          <sch:rule abstract="true" id="UVP_TEL.PHONE-1">
            <sch:assert test="@nullFlavor or @probability"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="UVP_TEL.PHONE-2">
            <sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="value" type="TEL.PHONE"/>
        </xsd:sequence>
        <xsd:attribute name="probability" type="xsd:double" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="NPPD_TEL.URL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="must have at least one item">
          <sch:rule abstract="true" id="NPPD_TEL.URL-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="UVP_TEL.URL"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="UVP_TEL.URL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="value not null">
          <sch:rule abstract="true" id="UVP_TEL.URL-0">
            <sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="must have probability">
          <sch:rule abstract="true" id="UVP_TEL.URL-1">
            <sch:assert test="@nullFlavor or @probability"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="UVP_TEL.URL-2">
            <sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="value" type="TEL.URL"/>
        </xsd:sequence>
        <xsd:attribute name="probability" type="xsd:double" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="NPPD_II">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="must have at least one item">
          <sch:rule abstract="true" id="NPPD_II-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="UVP_II"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="UVP_II">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="value not null">
          <sch:rule abstract="true" id="UVP_II-0">
            <sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="must have probability">
          <sch:rule abstract="true" id="UVP_II-1">
            <sch:assert test="@nullFlavor or @probability"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="UVP_II-2">
            <sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="value" type="II"/>
        </xsd:sequence>
        <xsd:attribute name="probability" type="xsd:double" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="NPPD_CD">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="must have at least one item">
          <sch:rule abstract="true" id="NPPD_CD-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="UVP_CD"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="UVP_CD">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="value not null">
          <sch:rule abstract="true" id="UVP_CD-0">
            <sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="must have probability">
          <sch:rule abstract="true" id="UVP_CD-1">
            <sch:assert test="@nullFlavor or @probability"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="UVP_CD-2">
            <sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="value" type="CD"/>
        </xsd:sequence>
        <xsd:attribute name="probability" type="xsd:double" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="NPPD_CD.CV">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="must have at least one item">
          <sch:rule abstract="true" id="NPPD_CD.CV-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="UVP_CD.CV"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="UVP_CD.CV">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="value not null">
          <sch:rule abstract="true" id="UVP_CD.CV-0">
            <sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="must have probability">
          <sch:rule abstract="true" id="UVP_CD.CV-1">
            <sch:assert test="@nullFlavor or @probability"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="UVP_CD.CV-2">
            <sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="value" type="CD.CV"/>
        </xsd:sequence>
        <xsd:attribute name="probability" type="xsd:double" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="NPPD_CO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="must have at least one item">
          <sch:rule abstract="true" id="NPPD_CO-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="UVP_CO"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="UVP_CO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="value not null">
          <sch:rule abstract="true" id="UVP_CO-0">
            <sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="must have probability">
          <sch:rule abstract="true" id="UVP_CO-1">
            <sch:assert test="@nullFlavor or @probability"/>
            © 357
ISO 2008  All rights reserved
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="UVP_CO-2">
            <sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="value" type="CO"/>
        </xsd:sequence>
        <xsd:attribute name="probability" type="xsd:double" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="NPPD_CS">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="must have at least one item">
          <sch:rule abstract="true" id="NPPD_CS-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="UVP_CS"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="UVP_CS">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="value not null">
          <sch:rule abstract="true" id="UVP_CS-0">
            <sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="must have probability">
          <sch:rule abstract="true" id="UVP_CS-1">
            <sch:assert test="@nullFlavor or @probability"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="UVP_CS-2">
            <sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="value" type="CS"/>
        </xsd:sequence>
        <xsd:attribute name="probability" type="xsd:double" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="NPPD_AD">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="must have at least one item">
          <sch:rule abstract="true" id="NPPD_AD-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="UVP_AD"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="UVP_AD">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="value not null">
          <sch:rule abstract="true" id="UVP_AD-0">
            <sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="must have probability">
          <sch:rule abstract="true" id="UVP_AD-1">
            <sch:assert test="@nullFlavor or @probability"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="UVP_AD-2">
            <sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="value" type="AD"/>
        </xsd:sequence>
        <xsd:attribute name="probability" type="xsd:double" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="NPPD_EN">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="must have at least one item">
          <sch:rule abstract="true" id="NPPD_EN-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="UVP_EN"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="UVP_EN">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="value not null">
          <sch:rule abstract="true" id="UVP_EN-0">
            <sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="must have probability">
          <sch:rule abstract="true" id="UVP_EN-1">
            © 359
ISO 2008  All rights reserved
            <sch:assert test="@nullFlavor or @probability"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="UVP_EN-2">
            <sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="value" type="EN"/>
        </xsd:sequence>
        <xsd:attribute name="probability" type="xsd:double" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="NPPD_EN.TN">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="must have at least one item">
          <sch:rule abstract="true" id="NPPD_EN.TN-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="UVP_EN.TN"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="UVP_EN.TN">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="value not null">
          <sch:rule abstract="true" id="UVP_EN.TN-0">
            <sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="must have probability">
          <sch:rule abstract="true" id="UVP_EN.TN-1">
            <sch:assert test="@nullFlavor or @probability"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="UVP_EN.TN-2">
            <sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="value" type="EN.TN"/>
        </xsd:sequence>
        <xsd:attribute name="probability" type="xsd:double" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="NPPD_EN.PN">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="must have at least one item">
          <sch:rule abstract="true" id="NPPD_EN.PN-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="UVP_EN.PN"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="UVP_EN.PN">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="value not null">
          <sch:rule abstract="true" id="UVP_EN.PN-0">
            <sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="must have probability">
          <sch:rule abstract="true" id="UVP_EN.PN-1">
            <sch:assert test="@nullFlavor or @probability"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="UVP_EN.PN-2">
            <sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="value" type="EN.PN"/>
        </xsd:sequence>
        <xsd:attribute name="probability" type="xsd:double" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="NPPD_EN.ON">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="must have at least one item">
          <sch:rule abstract="true" id="NPPD_EN.ON-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="UVP_EN.ON"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="UVP_EN.ON">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="value not null">
          <sch:rule abstract="true" id="UVP_EN.ON-0">
            <sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="must have probability">
          © 361
ISO 2008  All rights reserved
          <sch:rule abstract="true" id="UVP_EN.ON-1">
            <sch:assert test="@nullFlavor or @probability"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="UVP_EN.ON-2">
            <sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="value" type="EN.ON"/>
        </xsd:sequence>
        <xsd:attribute name="probability" type="xsd:double" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="NPPD_TS">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="must have at least one item">
          <sch:rule abstract="true" id="NPPD_TS-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="UVP_TS"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="UVP_TS">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="value not null">
          <sch:rule abstract="true" id="UVP_TS-0">
            <sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="must have probability">
          <sch:rule abstract="true" id="UVP_TS-1">
            <sch:assert test="@nullFlavor or @probability"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="UVP_TS-2">
            <sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="value" type="TS"/>
        </xsd:sequence>
        <xsd:attribute name="probability" type="xsd:double" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="NPPD_TS.DATE">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="must have at least one item">
          <sch:rule abstract="true" id="NPPD_TS.DATE-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="UVP_TS.DATE"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="UVP_TS.DATE">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="value not null">
          <sch:rule abstract="true" id="UVP_TS.DATE-0">
            <sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="must have probability">
          <sch:rule abstract="true" id="UVP_TS.DATE-1">
            <sch:assert test="@nullFlavor or @probability"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="UVP_TS.DATE-2">
            <sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="value" type="TS.DATE"/>
        </xsd:sequence>
        <xsd:attribute name="probability" type="xsd:double" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="NPPD_TS.DATE.FULL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="must have at least one item">
          <sch:rule abstract="true" id="NPPD_TS.DATE.FULL-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="UVP_TS.DATE.FULL"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="UVP_TS.DATE.FULL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="value not null">
          <sch:rule abstract="true" id="UVP_TS.DATE.FULL-0">
            <sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="must have probability">
          <sch:rule abstract="true" id="UVP_TS.DATE.FULL-1">
            <sch:assert test="@nullFlavor or @probability"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="UVP_TS.DATE.FULL-2">
            <sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="value" type="TS.DATE.FULL"/>
        </xsd:sequence>
        <xsd:attribute name="probability" type="xsd:double" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="NPPD_TS.DATETIME">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="must have at least one item">
          <sch:rule abstract="true" id="NPPD_TS.DATETIME-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="UVP_TS.DATETIME"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="UVP_TS.DATETIME">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="value not null">
          <sch:rule abstract="true" id="UVP_TS.DATETIME-0">
            <sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="must have probability">
          <sch:rule abstract="true" id="UVP_TS.DATETIME-1">
            <sch:assert test="@nullFlavor or @probability"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="UVP_TS.DATETIME-2">
            <sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="value" type="TS.DATETIME"/>
        </xsd:sequence>
        <xsd:attribute name="probability" type="xsd:double" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="NPPD_TS.DATETIME.FULL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="must have at least one item">
          <sch:rule abstract="true" id="NPPD_TS.DATETIME.FULL-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="UVP_TS.DATETIME.FULL"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="UVP_TS.DATETIME.FULL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="value not null">
          <sch:rule abstract="true" id="UVP_TS.DATETIME.FULL-0">
            <sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="must have probability">
          <sch:rule abstract="true" id="UVP_TS.DATETIME.FULL-1">
            <sch:assert test="@nullFlavor or @probability"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="UVP_TS.DATETIME.FULL-2">
            <sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="value" type="TS.DATETIME.FULL"/>
        </xsd:sequence>
        <xsd:attribute name="probability" type="xsd:double" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="NPPD_TS.BIRTH">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="must have at least one item">
          <sch:rule abstract="true" id="NPPD_TS.BIRTH-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="UVP_TS.BIRTH"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="UVP_TS.BIRTH">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="value not null">
          © 365
ISO 2008  All rights reserved
          <sch:rule abstract="true" id="UVP_TS.BIRTH-0">
            <sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="must have probability">
          <sch:rule abstract="true" id="UVP_TS.BIRTH-1">
            <sch:assert test="@nullFlavor or @probability"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="UVP_TS.BIRTH-2">
            <sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="value" type="TS.BIRTH"/>
        </xsd:sequence>
        <xsd:attribute name="probability" type="xsd:double" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="NPPD_RTO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="must have at least one item">
          <sch:rule abstract="true" id="NPPD_RTO-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="UVP_RTO"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="UVP_RTO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="value not null">
          <sch:rule abstract="true" id="UVP_RTO-0">
            <sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="must have probability">
          <sch:rule abstract="true" id="UVP_RTO-1">
            <sch:assert test="@nullFlavor or @probability"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="UVP_RTO-2">
            <sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="value" type="RTO"/>
        </xsd:sequence>
        <xsd:attribute name="probability" type="xsd:double" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="NPPD_MO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="must have at least one item">
          <sch:rule abstract="true" id="NPPD_MO-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="UVP_MO"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="UVP_MO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="value not null">
          <sch:rule abstract="true" id="UVP_MO-0">
            <sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="must have probability">
          <sch:rule abstract="true" id="UVP_MO-1">
            <sch:assert test="@nullFlavor or @probability"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="UVP_MO-2">
            <sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="value" type="MO"/>
        </xsd:sequence>
        <xsd:attribute name="probability" type="xsd:double" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="NPPD_PQ">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="must have at least one item">
          <sch:rule abstract="true" id="NPPD_PQ-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="UVP_PQ"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="UVP_PQ">
    <xsd:annotation>
      <xsd:appinfo>
        © 367
ISO 2008  All rights reserved
        <sch:pattern name="value not null">
          <sch:rule abstract="true" id="UVP_PQ-0">
            <sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="must have probability">
          <sch:rule abstract="true" id="UVP_PQ-1">
            <sch:assert test="@nullFlavor or @probability"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="UVP_PQ-2">
            <sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="value" type="PQ"/>
        </xsd:sequence>
        <xsd:attribute name="probability" type="xsd:double" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="NPPD_PQ.TIME">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="must have at least one item">
          <sch:rule abstract="true" id="NPPD_PQ.TIME-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="UVP_PQ.TIME"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="UVP_PQ.TIME">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="value not null">
          <sch:rule abstract="true" id="UVP_PQ.TIME-0">
            <sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="must have probability">
          <sch:rule abstract="true" id="UVP_PQ.TIME-1">
            <sch:assert test="@nullFlavor or @probability"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="UVP_PQ.TIME-2">
            <sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="value" type="PQ.TIME"/>
        </xsd:sequence>
        <xsd:attribute name="probability" type="xsd:double" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="NPPD_REAL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="must have at least one item">
          <sch:rule abstract="true" id="NPPD_REAL-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="UVP_REAL"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="UVP_REAL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="value not null">
          <sch:rule abstract="true" id="UVP_REAL-0">
            <sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="must have probability">
          <sch:rule abstract="true" id="UVP_REAL-1">
            <sch:assert test="@nullFlavor or @probability"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="UVP_REAL-2">
            <sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="value" type="REAL"/>
        </xsd:sequence>
        <xsd:attribute name="probability" type="xsd:double" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="NPPD_INT">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="must have at least one item">
          <sch:rule abstract="true" id="NPPD_INT-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="UVP_INT"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="UVP_INT">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="value not null">
          <sch:rule abstract="true" id="UVP_INT-0">
            <sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="must have probability">
          <sch:rule abstract="true" id="UVP_INT-1">
            <sch:assert test="@nullFlavor or @probability"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="UVP_INT-2">
            <sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="value" type="INT"/>
        </xsd:sequence>
        <xsd:attribute name="probability" type="xsd:double" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="NPPD_INT.NONNEG">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="must have at least one item">
          <sch:rule abstract="true" id="NPPD_INT.NONNEG-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="UVP_INT.NONNEG"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="UVP_INT.NONNEG">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="value not null">
          <sch:rule abstract="true" id="UVP_INT.NONNEG-0">
            <sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="must have probability">
          <sch:rule abstract="true" id="UVP_INT.NONNEG-1">
            <sch:assert test="@nullFlavor or @probability"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="UVP_INT.NONNEG-2">
            <sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="value" type="INT.NONNEG"/>
        </xsd:sequence>
        <xsd:attribute name="probability" type="xsd:double" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="NPPD_INT.POS">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="must have at least one item">
          <sch:rule abstract="true" id="NPPD_INT.POS-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="UVP_INT.POS"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="UVP_INT.POS">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="value not null">
          <sch:rule abstract="true" id="UVP_INT.POS-0">
            <sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="must have probability">
          <sch:rule abstract="true" id="UVP_INT.POS-1">
            <sch:assert test="@nullFlavor or @probability"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="UVP_INT.POS-2">
            <sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="value" type="INT.POS"/>
        </xsd:sequence>
        <xsd:attribute name="probability" type="xsd:double" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSET.BOUNDEDPIVL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="QSET.BOUNDEDPIVL 2">
          <sch:rule abstract="true" id="QSET.BOUNDEDPIVL-0">
            <sch:assert test="count(*)=2"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="QSI_TS">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="term" type="QSET_TS"/>
        </xsd:sequence>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="HIST_BL">
    <xsd:complexContent>
      <xsd:extension base="LIST_BL"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="HIST_BL.NONNULL">
    <xsd:complexContent>
      <xsd:extension base="LIST_BL.NONNULL"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="HIST_ED">
    <xsd:complexContent>
      <xsd:extension base="LIST_ED"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="HIST_ED.IMAGE">
    <xsd:complexContent>
      <xsd:extension base="LIST_ED.IMAGE"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="HIST_ED.TEXT">
    <xsd:complexContent>
      <xsd:extension base="LIST_ED.TEXT"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="HIST_ED.DOC">
    <xsd:complexContent>
      <xsd:extension base="LIST_ED.DOC"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="HIST_ED.DOC.REF">
    <xsd:complexContent>
      <xsd:extension base="LIST_ED.DOC.REF"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="HIST_ED.DOC.INLINE">
    <xsd:complexContent>
      <xsd:extension base="LIST_ED.DOC.INLINE"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="HIST_ED.SIGNATURE">
    <xsd:complexContent>
      <xsd:extension base="LIST_ED.SIGNATURE"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="HIST_ED.STRUCTUREDTEXT">
    <xsd:complexContent>
      <xsd:extension base="LIST_ED.STRUCTUREDTEXT"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="HIST_ED.STRUCTUREDTITLE">
    <xsd:complexContent>
      <xsd:extension base="LIST_ED.STRUCTUREDTITLE"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="HIST_ST">
    <xsd:complexContent>
      <xsd:extension base="LIST_ST"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="HIST_ST.NT">
    <xsd:complexContent>
      <xsd:extension base="LIST_ST.NT"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="HIST_SC">
    <xsd:complexContent>
      <xsd:extension base="LIST_SC"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="HIST_SC.NT">
    <xsd:complexContent>
      <xsd:extension base="LIST_SC.NT"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="HIST_TEL">
    <xsd:complexContent>
      <xsd:extension base="LIST_TEL"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="HIST_TEL.EMAIL">
    <xsd:complexContent>
      <xsd:extension base="LIST_TEL.EMAIL"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="HIST_TEL.PERSON">
    <xsd:complexContent>
      <xsd:extension base="LIST_TEL.PERSON"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="HIST_TEL.PHONE">
    <xsd:complexContent>
      <xsd:extension base="LIST_TEL.PHONE"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="HIST_TEL.URL">
    <xsd:complexContent>
      <xsd:extension base="LIST_TEL.URL"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="HIST_II">
    <xsd:complexContent>
      <xsd:extension base="LIST_II"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="HIST_CD">
    <xsd:complexContent>
      <xsd:extension base="LIST_CD"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="HIST_CD.CV">
    <xsd:complexContent>
      <xsd:extension base="LIST_CD.CV"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="HIST_CO">
    <xsd:complexContent>
      <xsd:extension base="LIST_CO"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="HIST_CS">
    <xsd:complexContent>
      <xsd:extension base="LIST_CS"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="HIST_AD">
    <xsd:complexContent>
      <xsd:extension base="LIST_AD"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="HIST_EN">
    <xsd:complexContent>
      <xsd:extension base="LIST_EN"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="HIST_EN.TN">
    <xsd:complexContent>
      <xsd:extension base="LIST_EN.TN"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="HIST_EN.PN">
    <xsd:complexContent>
      <xsd:extension base="LIST_EN.PN"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="HIST_EN.ON">
    <xsd:complexContent>
      <xsd:extension base="LIST_EN.ON"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="HIST_TS">
    <xsd:complexContent>
      <xsd:extension base="LIST_TS"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="HIST_TS.DATE">
    <xsd:complexContent>
      <xsd:extension base="LIST_TS.DATE"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="HIST_TS.DATE.FULL">
    <xsd:complexContent>
      <xsd:extension base="LIST_TS.DATE.FULL"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="HIST_TS.DATETIME">
    <xsd:complexContent>
      <xsd:extension base="LIST_TS.DATETIME"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="HIST_TS.DATETIME.FULL">
    <xsd:complexContent>
      <xsd:extension base="LIST_TS.DATETIME.FULL"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="HIST_TS.BIRTH">
    <xsd:complexContent>
      <xsd:extension base="LIST_TS.BIRTH"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="HIST_RTO">
    <xsd:complexContent>
      <xsd:extension base="LIST_RTO"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="HIST_MO">
    <xsd:complexContent>
      <xsd:extension base="LIST_MO"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="HIST_PQ">
    <xsd:complexContent>
      <xsd:extension base="LIST_PQ"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="HIST_PQ.TIME">
    <xsd:complexContent>
      <xsd:extension base="LIST_PQ.TIME"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="HIST_REAL">
    <xsd:complexContent>
      <xsd:extension base="LIST_REAL"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="HIST_INT">
    <xsd:complexContent>
      <xsd:extension base="LIST_INT"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="HIST_INT.NONNEG">
    <xsd:complexContent>
      <xsd:extension base="LIST_INT.NONNEG"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="HIST_INT.POS">
    <xsd:complexContent>
      <xsd:extension base="LIST_INT.POS"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="URG_CO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="no inner attributes">
          <sch:rule abstract="true" id="URG_CO-0">
            <sch:assert test="not(@validTimeLow) and not(@validTimeHigh) and not (@controlActRoot) and not(@controlActExtension) and not(@flavorId) and not(@nullFlavor) and not(@updateMode) and not(expression) and not(originalText) and not(uncertainty) and not(@uncertaintyType)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QTY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="low" type="CO"/>
          <xsd:element minOccurs="0" name="high" type="CO"/>
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="optional"/>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="optional"/>
      </xsd:extension>
      <!--<xsd:complexType name="URG_TS.DATETIME"> TODO-->
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="URG_TS">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="no inner attributes">
          <sch:rule abstract="true" id="URG_TS-0">
            <sch:assert test="not(@validTimeLow) and not(@validTimeHigh) and not (@controlActRoot) and not(@controlActExtension) and not(@flavorId) and not(@nullFlavor) and not(@updateMode) and not(expression) and not(originalText) and not(uncertainty) and not(@uncertaintyType)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QTY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="low" type="TS"/>
          <xsd:element minOccurs="0" name="high" type="TS"/>
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="optional"/>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="optional"/>
      </xsd:extension>
      <!--<xsd:attribute name="nullFlavor" type="NullFlavor" fixed="UNK" use="optional"/>-->
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="URG_TS.DATE">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="no inner attributes">
          <sch:rule abstract="true" id="URG_TS.DATE-0">
            <sch:assert test="not(@validTimeLow) and not(@validTimeHigh) and not (@controlActRoot) and not(@controlActExtension) and not(@flavorId) and not(@nullFlavor) and not(@updateMode) and not(expression) and not(originalText) and not(uncertainty) and not(@uncertaintyType)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QTY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="low" type="TS.DATE"/>
          <xsd:element minOccurs="0" name="high" type="TS.DATE"/>
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="optional"/>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="optional"/>
      </xsd:extension>
      <!--<xsd:attribute name="nullFlavor" type="NullFlavor" fixed="UNK" use="optional"/> TODO-->
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="URG_TS.DATE.FULL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="no inner attributes">
          <sch:rule abstract="true" id="URG_TS.DATE.FULL-0">
            <sch:assert test="not(@validTimeLow) and not(@validTimeHigh) and not (@controlActRoot) and not(@controlActExtension) and not(@flavorId) and not(@nullFlavor) and not(@updateMode) and not(expression) and not(originalText) and not(uncertainty) and not(@uncertaintyType)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QTY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="low" type="TS.DATE.FULL"/>
          <xsd:element minOccurs="0" name="high" type="TS.DATE.FULL"/>
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="optional"/>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="optional"/>
      </xsd:extension>
      <!--<xsd:attribute name="nullFlavor" type="NullFlavor" fixed="UNK" use="optional"/> OBS!!!!-->
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="URG_TS.DATETIME">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="no inner attributes">
          <sch:rule abstract="true" id="URG_TS.DATETIME-0">
            <sch:assert test="not(@validTimeLow) and not(@validTimeHigh) and not (@controlActRoot) and not(@controlActExtension) and not(@flavorId) and not(@nullFlavor) and not(@updateMode) and not(expression) and not(originalText) and not(uncertainty) and not(@uncertaintyType)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QTY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="low" type="TS.DATETIME"/>
          <xsd:element minOccurs="0" name="high" type="TS.DATETIME"/>
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="optional"/>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="optional"/>
      </xsd:extension>
      <!--<xsd:attribute name="nullFlavor" type="NullFlavor" fixed="UNK" use="optional"/>-->
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="URG_TS.DATETIME.FULL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="no inner attributes">
          <sch:rule abstract="true" id="URG_TS.DATETIME.FULL-0">
            <sch:assert test="not(@validTimeLow) and not(@validTimeHigh) and not (@controlActRoot) and not(@controlActExtension) and not(@flavorId) and not(@nullFlavor) and not(@updateMode) and not(expression) and not(originalText) and not(uncertainty) and not(@uncertaintyType)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QTY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="low" type="TS.DATETIME.FULL"/>
          <xsd:element minOccurs="0" name="high" type="TS.DATETIME.FULL"/>
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="optional"/>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="optional"/>
      </xsd:extension>
      <!--<xsd:complexType name="URG_TS.DATETIME"> TODO-->
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="URG_TS.BIRTH">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="no inner attributes">
          <sch:rule abstract="true" id="URG_TS.BIRTH-0">
            <sch:assert test="not(@validTimeLow) and not(@validTimeHigh) and not (@controlActRoot) and not(@controlActExtension) and not(@flavorId) and not(@nullFlavor) and not(@updateMode) and not(expression) and not(originalText) and not(uncertainty) and not(@uncertaintyType)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QTY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="low" type="TS.BIRTH"/>
          <xsd:element minOccurs="0" name="high" type="TS.BIRTH"/>
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="optional"/>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="optional"/>
      </xsd:extension>
      <!--<xsd:attribute name="nullFlavor" type="NullFlavor" fixed="UNK" use="optional"/> TODO-->
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="URG_RTO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="no inner attributes">
          <sch:rule abstract="true" id="URG_RTO-0">
            <sch:assert test="not(@validTimeLow) and not(@validTimeHigh) and not (@controlActRoot) and not(@controlActExtension) and not(@flavorId) and not(@nullFlavor) and not(@updateMode) and not(expression) and not(originalText) and not(uncertainty) and not(@uncertaintyType)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QTY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="low" type="RTO"/>
          <xsd:element minOccurs="0" name="high" type="RTO"/>
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="optional"/>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="optional"/>
      </xsd:extension>
      <!--<xsd:attribute name="nullFlavor" type="NullFlavor" fixed="UNK" use="optional"/>-->
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="URG_MO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="no inner attributes">
          <sch:rule abstract="true" id="URG_MO-0">
            <sch:assert test="not(@validTimeLow) and not(@validTimeHigh) and not (@controlActRoot) and not(@controlActExtension) and not(@flavorId) and not(@nullFlavor) and not(@updateMode) and not(expression) and not(originalText) and not(uncertainty) and not(@uncertaintyType)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QTY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="low" type="MO"/>
          <xsd:element minOccurs="0" name="high" type="MO"/>
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="optional"/>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="optional"/>
      </xsd:extension>
      <!--<xsd:attribute name="nullFlavor" type="NullFlavor" fixed="UNK" use="optional"/> TODO-->
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="URG_PQ">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="no inner attributes">
          <sch:rule abstract="true" id="URG_PQ-0">
            <sch:assert test="not(@validTimeLow) and not(@validTimeHigh) and not (@controlActRoot) and not(@controlActExtension) and not(@flavorId) and not(@nullFlavor) and not(@updateMode) and not(expression) and not(originalText) and not(uncertainty) and not(@uncertaintyType)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QTY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="low" type="PQ"/>
          <xsd:element minOccurs="0" name="high" type="PQ"/>
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="optional"/>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="optional"/>
      </xsd:extension>
      <!--<xsd:attribute name="nullFlavor" type="NullFlavor" fixed="UNK" use="optional"/> TODO-->
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="URG_PQ.TIME">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="no inner attributes">
          <sch:rule abstract="true" id="URG_PQ.TIME-0">
            <sch:assert test="not(@validTimeLow) and not(@validTimeHigh) and not (@controlActRoot) and not(@controlActExtension) and not(@flavorId) and not(@nullFlavor) and not(@updateMode) and not(expression) and not(originalText) and not(uncertainty) and not(@uncertaintyType)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QTY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="low" type="PQ.TIME"/>
          <xsd:element minOccurs="0" name="high" type="PQ.TIME"/>
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="optional"/>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="optional"/>
      </xsd:extension>
      <!--<xsd:complexType name="URG_TS.DATETIME"> TODO-->
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="URG_REAL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="no inner attributes">
          <sch:rule abstract="true" id="URG_REAL-0">
            <sch:assert test="not(@validTimeLow) and not(@validTimeHigh) and not (@controlActRoot) and not(@controlActExtension) and not(@flavorId) and not(@nullFlavor) and not(@updateMode) and not(expression) and not(originalText) and not(uncertainty) and not(@uncertaintyType)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QTY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="low" type="REAL"/>
          <xsd:element minOccurs="0" name="high" type="REAL"/>
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="optional"/>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="optional"/>
      </xsd:extension>
      <!--<xsd:complexType name="URG_TS.DATETIME"> TODO-->
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="URG_INT">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="no inner attributes">
          <sch:rule abstract="true" id="URG_INT-0">
            <sch:assert test="not(@validTimeLow) and not(@validTimeHigh) and not (@controlActRoot) and not(@controlActExtension) and not(@flavorId) and not(@nullFlavor) and not(@updateMode) and not(expression) and not(originalText) and not(uncertainty) and not(@uncertaintyType)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QTY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="low" type="INT"/>
          <xsd:element minOccurs="0" name="high" type="INT"/>
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="optional"/>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="optional"/>
      </xsd:extension>
      <!--<xsd:attribute name="nullFlavor" type="NullFlavor" fixed="UNK" use="optional"/>-->
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="URG_INT.NONNEG">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="no inner attributes">
          <sch:rule abstract="true" id="URG_INT.NONNEG-0">
            <sch:assert test="not(@validTimeLow) and not(@validTimeHigh) and not (@controlActRoot) and not(@controlActExtension) and not(@flavorId) and not(@nullFlavor) and not(@updateMode) and not(expression) and not(originalText) and not(uncertainty) and not(@uncertaintyType)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QTY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="low" type="INT.NONNEG"/>
          <xsd:element minOccurs="0" name="high" type="INT.NONNEG"/>
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="optional"/>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="optional"/>
      </xsd:extension>
      <!--<xsd:complexType name="URG_TS.DATETIME"> TODO-->
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="URG_INT.POS">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="no inner attributes">
          <sch:rule abstract="true" id="URG_INT.POS-0">
            <sch:assert test="not(@validTimeLow) and not(@validTimeHigh) and not (@controlActRoot) and not(@controlActExtension) and not(@flavorId) and not(@nullFlavor) and not(@updateMode) and not(expression) and not(originalText) and not(uncertainty) and not(@uncertaintyType)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QTY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="low" type="INT.POS"/>
          <xsd:element minOccurs="0" name="high" type="INT.POS"/>
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="optional"/>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="optional"/>
      </xsd:extension>
      <!--<xsd:attribute name="nullFlavor" type="NullFlavor" fixed="UNK" use="optional"/>-->
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="URG.LOW_CO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="URG.LOW_CO-0">
            <sch:assert test="low and not(low\@nullFlavor) and (@lowClosed = &quot;true&quot;)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="URG.LOW_CO-1">
            <sch:assert test="not(high) and not(@highClosed)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="URG_CO">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="expression" type="ED"/>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element minOccurs="0" name="uncertainty" type="QTY"/>
          <xsd:element minOccurs="0" name="low" type="CO"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="high" type="CO"/>
        </xsd:sequence>
        <xsd:attribute fixed="UNK" name="nullFlavor" type="NullFlavor"/>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="prohibited"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="URG.LOW_TS">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="URG.LOW_TS-0">
            <sch:assert test="low and not(low\@nullFlavor) and (@lowClosed = &quot;true&quot;)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="URG.LOW_TS-1">
            <sch:assert test="not(high) and not(@highClosed)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="URG_TS">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="expression" type="ED"/>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element minOccurs="0" name="uncertainty" type="QTY"/>
          <xsd:element minOccurs="0" name="low" type="TS"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="high" type="TS"/>
        </xsd:sequence>
        <xsd:attribute fixed="UNK" name="nullFlavor" type="NullFlavor"/>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="prohibited"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="URG.LOW_TS.DATE">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="URG.LOW_TS.DATE-0">
            <sch:assert test="low and not(low\@nullFlavor) and (@lowClosed = &quot;true&quot;)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="URG.LOW_TS.DATE-1">
            <sch:assert test="not(high) and not(@highClosed)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="URG_TS.DATE">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="expression" type="ED"/>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element minOccurs="0" name="uncertainty" type="QTY"/>
          <xsd:element minOccurs="0" name="low" type="TS.DATE"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="high" type="TS.DATE"/>
        </xsd:sequence>
        <xsd:attribute fixed="UNK" name="nullFlavor" type="NullFlavor"/>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="prohibited"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="URG.LOW_TS.DATE.FULL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="URG.LOW_TS.DATE.FULL-0">
            <sch:assert test="low and not(low\@nullFlavor) and (@lowClosed = &quot;true&quot;)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="URG.LOW_TS.DATE.FULL-1">
            <sch:assert test="not(high) and not(@highClosed)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="URG_TS.DATE.FULL">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="expression" type="ED"/>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element minOccurs="0" name="uncertainty" type="QTY"/>
          <xsd:element minOccurs="0" name="low" type="TS.DATE.FULL"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="high" type="TS.DATE.FULL"/>
        </xsd:sequence>
        <xsd:attribute fixed="UNK" name="nullFlavor" type="NullFlavor"/>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="prohibited"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="URG.LOW_TS.DATETIME">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="URG.LOW_TS.DATETIME-0">
            <sch:assert test="low and not(low\@nullFlavor) and (@lowClosed = &quot;true&quot;)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="URG.LOW_TS.DATETIME-1">
            <sch:assert test="not(high) and not(@highClosed)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="URG_TS.DATETIME">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="expression" type="ED"/>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element minOccurs="0" name="uncertainty" type="QTY"/>
          <xsd:element minOccurs="0" name="low" type="TS.DATETIME"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="high" type="TS.DATETIME"/>
        </xsd:sequence>
        <xsd:attribute fixed="UNK" name="nullFlavor" type="NullFlavor"/>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="prohibited"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="URG.LOW_TS.DATETIME.FULL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="URG.LOW_TS.DATETIME.FULL-0">
            <sch:assert test="low and not(low\@nullFlavor) and (@lowClosed = &quot;true&quot;)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="URG.LOW_TS.DATETIME.FULL-1">
            <sch:assert test="not(high) and not(@highClosed)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="URG_TS.DATETIME.FULL">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="expression" type="ED"/>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element minOccurs="0" name="uncertainty" type="QTY"/>
          <xsd:element minOccurs="0" name="low" type="TS.DATETIME.FULL"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="high" type="TS.DATETIME.FULL"/>
        </xsd:sequence>
        <xsd:attribute fixed="UNK" name="nullFlavor" type="NullFlavor"/>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="prohibited"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="URG.LOW_TS.BIRTH">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="URG.LOW_TS.BIRTH-0">
            <sch:assert test="low and not(low\@nullFlavor) and (@lowClosed = &quot;true&quot;)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="URG.LOW_TS.BIRTH-1">
            <sch:assert test="not(high) and not(@highClosed)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="URG_TS.BIRTH">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="expression" type="ED"/>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element minOccurs="0" name="uncertainty" type="QTY"/>
          <xsd:element minOccurs="0" name="low" type="TS.BIRTH"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="high" type="TS.BIRTH"/>
        </xsd:sequence>
        <xsd:attribute fixed="UNK" name="nullFlavor" type="NullFlavor"/>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="prohibited"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="URG.LOW_RTO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="URG.LOW_RTO-0">
            <sch:assert test="low and not(low\@nullFlavor) and (@lowClosed = &quot;true&quot;)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="URG.LOW_RTO-1">
            <sch:assert test="not(high) and not(@highClosed)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="URG_RTO">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="expression" type="ED"/>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element minOccurs="0" name="uncertainty" type="QTY"/>
          <xsd:element minOccurs="0" name="low" type="RTO"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="high" type="RTO"/>
        </xsd:sequence>
        <xsd:attribute fixed="UNK" name="nullFlavor" type="NullFlavor"/>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="prohibited"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="URG.LOW_MO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="URG.LOW_MO-0">
            <sch:assert test="low and not(low\@nullFlavor) and (@lowClosed = &quot;true&quot;)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="URG.LOW_MO-1">
            <sch:assert test="not(high) and not(@highClosed)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="URG_MO">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="expression" type="ED"/>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element minOccurs="0" name="uncertainty" type="QTY"/>
          <xsd:element minOccurs="0" name="low" type="MO"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="high" type="MO"/>
        </xsd:sequence>
        <xsd:attribute fixed="UNK" name="nullFlavor" type="NullFlavor"/>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="prohibited"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="URG.LOW_PQ">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="URG.LOW_PQ-0">
            <sch:assert test="low and not(low\@nullFlavor) and (@lowClosed = &quot;true&quot;)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="URG.LOW_PQ-1">
            <sch:assert test="not(high) and not(@highClosed)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="URG_PQ">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="expression" type="ED"/>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element minOccurs="0" name="uncertainty" type="QTY"/>
          <xsd:element minOccurs="0" name="low" type="PQ"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="high" type="PQ"/>
        </xsd:sequence>
        <xsd:attribute fixed="UNK" name="nullFlavor" type="NullFlavor"/>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="prohibited"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="URG.LOW_PQ.TIME">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="URG.LOW_PQ.TIME-0">
            <sch:assert test="low and not(low\@nullFlavor) and (@lowClosed = &quot;true&quot;)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="URG.LOW_PQ.TIME-1">
            <sch:assert test="not(high) and not(@highClosed)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="URG_PQ.TIME">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="expression" type="ED"/>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element minOccurs="0" name="uncertainty" type="QTY"/>
          <xsd:element minOccurs="0" name="low" type="PQ.TIME"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="high" type="PQ.TIME"/>
        </xsd:sequence>
        <xsd:attribute fixed="UNK" name="nullFlavor" type="NullFlavor"/>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="prohibited"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="URG.LOW_REAL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="URG.LOW_REAL-0">
            <sch:assert test="low and not(low\@nullFlavor) and (@lowClosed = &quot;true&quot;)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="URG.LOW_REAL-1">
            <sch:assert test="not(high) and not(@highClosed)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="URG_REAL">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="expression" type="ED"/>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element minOccurs="0" name="uncertainty" type="QTY"/>
          <xsd:element minOccurs="0" name="low" type="REAL"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="high" type="REAL"/>
        </xsd:sequence>
        <xsd:attribute fixed="UNK" name="nullFlavor" type="NullFlavor"/>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="prohibited"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="URG.LOW_INT">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="URG.LOW_INT-0">
            <sch:assert test="low and not(low\@nullFlavor) and (@lowClosed = &quot;true&quot;)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="URG.LOW_INT-1">
            <sch:assert test="not(high) and not(@highClosed)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="URG_INT">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="expression" type="ED"/>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element minOccurs="0" name="uncertainty" type="QTY"/>
          <xsd:element minOccurs="0" name="low" type="INT"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="high" type="INT"/>
        </xsd:sequence>
        <xsd:attribute fixed="UNK" name="nullFlavor" type="NullFlavor"/>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="prohibited"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="URG.LOW_INT.NONNEG">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="URG.LOW_INT.NONNEG-0">
            <sch:assert test="low and not(low\@nullFlavor) and (@lowClosed = &quot;true&quot;)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="URG.LOW_INT.NONNEG-1">
            <sch:assert test="not(high) and not(@highClosed)"/>
          </sch:rule>
        </sch:pattern>
        © 385
ISO 2008  All rights reserved
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="URG_INT.NONNEG">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="expression" type="ED"/>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element minOccurs="0" name="uncertainty" type="QTY"/>
          <xsd:element minOccurs="0" name="low" type="INT.NONNEG"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="high" type="INT.NONNEG"/>
        </xsd:sequence>
        <xsd:attribute fixed="UNK" name="nullFlavor" type="NullFlavor"/>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="prohibited"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="URG.LOW_INT.POS">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="URG.LOW_INT.POS-0">
            <sch:assert test="low and not(low\@nullFlavor) and (@lowClosed = &quot;true&quot;)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="URG.LOW_INT.POS-1">
            <sch:assert test="not(high) and not(@highClosed)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="URG_INT.POS">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="expression" type="ED"/>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element minOccurs="0" name="uncertainty" type="QTY"/>
          <xsd:element minOccurs="0" name="low" type="INT.POS"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="high" type="INT.POS"/>
        </xsd:sequence>
        <xsd:attribute fixed="UNK" name="nullFlavor" type="NullFlavor"/>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="prohibited"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="URG.HIGH_CO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="URG.HIGH_CO-0">
            <sch:assert test="high and not(high\@nullFlavor) and (@highClosed = &quot;true&quot;)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="URG.HIGH_CO-1">
            <sch:assert test="not(low) and not(@lowClosed)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="URG_CO">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="expression" type="ED"/>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element minOccurs="0" name="uncertainty" type="QTY"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="low" type="CO"/>
          <xsd:element minOccurs="0" name="high" type="CO"/>
        </xsd:sequence>
        <xsd:attribute fixed="UNK" name="nullFlavor" type="NullFlavor"/>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="prohibited"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="URG.HIGH_TS">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="URG.HIGH_TS-0">
            <sch:assert test="high and not(high\@nullFlavor) and (@highClosed = &quot;true&quot;)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="URG.HIGH_TS-1">
            <sch:assert test="not(low) and not(@lowClosed)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="URG_TS">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="expression" type="ED"/>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element minOccurs="0" name="uncertainty" type="QTY"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="low" type="TS"/>
          <xsd:element minOccurs="0" name="high" type="TS"/>
        </xsd:sequence>
        <xsd:attribute fixed="UNK" name="nullFlavor" type="NullFlavor"/>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="prohibited"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="URG.HIGH_TS.DATE">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="URG.HIGH_TS.DATE-0">
            <sch:assert test="high and not(high\@nullFlavor) and (@highClosed = &quot;true&quot;)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="URG.HIGH_TS.DATE-1">
            <sch:assert test="not(low) and not(@lowClosed)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="URG_TS.DATE">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="expression" type="ED"/>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element minOccurs="0" name="uncertainty" type="QTY"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="low" type="TS.DATE"/>
          <xsd:element minOccurs="0" name="high" type="TS.DATE"/>
        </xsd:sequence>
        <xsd:attribute fixed="UNK" name="nullFlavor" type="NullFlavor"/>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="prohibited"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="URG.HIGH_TS.DATE.FULL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="URG.HIGH_TS.DATE.FULL-0">
            <sch:assert test="high and not(high\@nullFlavor) and (@highClosed = &quot;true&quot;)"/>
            © 387
ISO 2008  All rights reserved
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="URG.HIGH_TS.DATE.FULL-1">
            <sch:assert test="not(low) and not(@lowClosed)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="URG_TS.DATE.FULL">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="expression" type="ED"/>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element minOccurs="0" name="uncertainty" type="QTY"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="low" type="TS.DATE.FULL"/>
          <xsd:element minOccurs="0" name="high" type="TS.DATE.FULL"/>
        </xsd:sequence>
        <xsd:attribute fixed="UNK" name="nullFlavor" type="NullFlavor"/>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="prohibited"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="URG.HIGH_TS.DATETIME">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="URG.HIGH_TS.DATETIME-0">
            <sch:assert test="high and not(high\@nullFlavor) and (@highClosed = &quot;true&quot;)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="URG.HIGH_TS.DATETIME-1">
            <sch:assert test="not(low) and not(@lowClosed)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="URG_TS.DATETIME">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="expression" type="ED"/>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element minOccurs="0" name="uncertainty" type="QTY"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="low" type="TS.DATETIME"/>
          <xsd:element minOccurs="0" name="high" type="TS.DATETIME"/>
        </xsd:sequence>
        <xsd:attribute fixed="UNK" name="nullFlavor" type="NullFlavor"/>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="prohibited"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="URG.HIGH_TS.DATETIME.FULL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="URG.HIGH_TS.DATETIME.FULL-0">
            <sch:assert test="high and not(high\@nullFlavor) and (@highClosed = &quot;true&quot;)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="URG.HIGH_TS.DATETIME.FULL-1">
            <sch:assert test="not(low) and not(@lowClosed)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="URG_TS.DATETIME.FULL">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="expression" type="ED"/>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element minOccurs="0" name="uncertainty" type="QTY"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="low" type="TS.DATETIME.FULL"/>
          <xsd:element minOccurs="0" name="high" type="TS.DATETIME.FULL"/>
        </xsd:sequence>
        <xsd:attribute fixed="UNK" name="nullFlavor" type="NullFlavor"/>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="prohibited"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="URG.HIGH_TS.BIRTH">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="URG.HIGH_TS.BIRTH-0">
            <sch:assert test="high and not(high\@nullFlavor) and (@highClosed = &quot;true&quot;)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="URG.HIGH_TS.BIRTH-1">
            <sch:assert test="not(low) and not(@lowClosed)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="URG_TS.BIRTH">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="expression" type="ED"/>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element minOccurs="0" name="uncertainty" type="QTY"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="low" type="TS.BIRTH"/>
          <xsd:element minOccurs="0" name="high" type="TS.BIRTH"/>
        </xsd:sequence>
        <xsd:attribute fixed="UNK" name="nullFlavor" type="NullFlavor"/>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="prohibited"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="URG.HIGH_RTO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="URG.HIGH_RTO-0">
            <sch:assert test="high and not(high\@nullFlavor) and (@highClosed = &quot;true&quot;)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="URG.HIGH_RTO-1">
            <sch:assert test="not(low) and not(@lowClosed)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="URG_RTO">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="expression" type="ED"/>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element minOccurs="0" name="uncertainty" type="QTY"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="low" type="RTO"/>
          <xsd:element minOccurs="0" name="high" type="RTO"/>
        </xsd:sequence>
        <xsd:attribute fixed="UNK" name="nullFlavor" type="NullFlavor"/>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="prohibited"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="URG.HIGH_MO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="URG.HIGH_MO-0">
            <sch:assert test="high and not(high\@nullFlavor) and (@highClosed = &quot;true&quot;)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="URG.HIGH_MO-1">
            <sch:assert test="not(low) and not(@lowClosed)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="URG_MO">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="expression" type="ED"/>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element minOccurs="0" name="uncertainty" type="QTY"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="low" type="MO"/>
          <xsd:element minOccurs="0" name="high" type="MO"/>
        </xsd:sequence>
        <xsd:attribute fixed="UNK" name="nullFlavor" type="NullFlavor"/>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="prohibited"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="URG.HIGH_PQ">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="URG.HIGH_PQ-0">
            <sch:assert test="high and not(high\@nullFlavor) and (@highClosed = &quot;true&quot;)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="URG.HIGH_PQ-1">
            <sch:assert test="not(low) and not(@lowClosed)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="URG_PQ">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="expression" type="ED"/>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element minOccurs="0" name="uncertainty" type="QTY"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="low" type="PQ"/>
          <xsd:element minOccurs="0" name="high" type="PQ"/>
        </xsd:sequence>
        <xsd:attribute fixed="UNK" name="nullFlavor" type="NullFlavor"/>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="prohibited"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="URG.HIGH_PQ.TIME">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="URG.HIGH_PQ.TIME-0">
            <sch:assert test="high and not(high\@nullFlavor) and (@highClosed = &quot;true&quot;)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="URG.HIGH_PQ.TIME-1">
            <sch:assert test="not(low) and not(@lowClosed)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="URG_PQ.TIME">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="expression" type="ED"/>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element minOccurs="0" name="uncertainty" type="QTY"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="low" type="PQ.TIME"/>
          <xsd:element minOccurs="0" name="high" type="PQ.TIME"/>
        </xsd:sequence>
        <xsd:attribute fixed="UNK" name="nullFlavor" type="NullFlavor"/>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="prohibited"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="URG.HIGH_REAL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="URG.HIGH_REAL-0">
            <sch:assert test="high and not(high\@nullFlavor) and (@highClosed = &quot;true&quot;)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="URG.HIGH_REAL-1">
            <sch:assert test="not(low) and not(@lowClosed)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="URG_REAL">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="expression" type="ED"/>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element minOccurs="0" name="uncertainty" type="QTY"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="low" type="REAL"/>
          <xsd:element minOccurs="0" name="high" type="REAL"/>
        </xsd:sequence>
        <xsd:attribute fixed="UNK" name="nullFlavor" type="NullFlavor"/>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="prohibited"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="URG.HIGH_INT">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="URG.HIGH_INT-0">
            <sch:assert test="high and not(high\@nullFlavor) and (@highClosed = &quot;true&quot;)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="URG.HIGH_INT-1">
            <sch:assert test="not(low) and not(@lowClosed)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="URG_INT">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="expression" type="ED"/>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element minOccurs="0" name="uncertainty" type="QTY"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="low" type="INT"/>
          <xsd:element minOccurs="0" name="high" type="INT"/>
        </xsd:sequence>
        <xsd:attribute fixed="UNK" name="nullFlavor" type="NullFlavor"/>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="prohibited"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="URG.HIGH_INT.NONNEG">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="URG.HIGH_INT.NONNEG-0">
            <sch:assert test="high and not(high\@nullFlavor) and (@highClosed = &quot;true&quot;)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="URG.HIGH_INT.NONNEG-1">
            <sch:assert test="not(low) and not(@lowClosed)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="URG_INT.NONNEG">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="expression" type="ED"/>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element minOccurs="0" name="uncertainty" type="QTY"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="low" type="INT.NONNEG"/>
          <xsd:element minOccurs="0" name="high" type="INT.NONNEG"/>
        </xsd:sequence>
        <xsd:attribute fixed="UNK" name="nullFlavor" type="NullFlavor"/>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="prohibited"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="URG.HIGH_INT.POS">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="URG.HIGH_INT.POS-0">
            <sch:assert test="high and not(high\@nullFlavor) and (@highClosed=&quot;true&quot;)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="URG.HIGH_INT.POS-1">
            <sch:assert test="not(low) and not(@lowClosed)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="URG_INT.POS">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="expression" type="ED"/>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element minOccurs="0" name="uncertainty" type="QTY"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="low" type="INT.POS"/>
          <xsd:element minOccurs="0" name="high" type="INT.POS"/>
        </xsd:sequence>
        <xsd:attribute fixed="UNK" name="nullFlavor" type="NullFlavor"/>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="prohibited"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
</xsd:schema>]]></con:content><con:type>http://www.w3.org/2001/XMLSchema</con:type></con:part><con:part><con:url>http://localhost:11000/npoadapter/ehrextract/v11?xsd=SE13606-1.xsd</con:url><con:content><![CDATA[<xs:schema elementFormDefault="qualified" targetNamespace="urn:riv13606:v1.1" xml:lang="en" xmlns="urn:riv13606:v1.1" xmlns:tns="urn:riv13606:v1.1" xmlns:xs="http://www.w3.org/2001/XMLSchema">
  <xs:annotation>
    <xs:documentation>--------------- original copyright -------------------------
       XML Schema equivalent  representation of  the  CEN/ISO 13606 
       part 1 model  for  Electronic  Healthcare  Record  Exchange. 
       This  version of the schema emphasises (1) fidelity  to  the 
       13606-1 standard  (even where  this leads to sub-optimal XML 
       representation)  and  (2)  maximum  use  of  W3C  XML Schema
       features (even where this increases parser complexity). This
       Schema definition conforms  to the 13606-1 version published
       February 2007.

       (c) 2008 CHIME, University College London.
       Created by Taher Hassan.
       --------------------------------------------------------------------------------------
       --------------------------------------------------------------------------------------
		Modified by Brainpool-Mawell to use ISO datatypes, split
		into separate schemas, corrected and simplified.
		Rodolfo Garcia
		Kristin Schoug
		Torbjorn Dahlin
		
		-----------------------------------------------------------------------------
		v1.1 2008-10-29. Modified by Andreas Ostberg - Arkitekturledningens T-grupp
		Modification of LINK-type. Additional optional attribute target_type. Holds a 
		code about the type of content of the target(s). There can only be 0-1 
		target_type in LINK, therefore it is not possible to use target_type if LINK 
		is referring to several different types of targets. If it is still necessary to set 
		target_type use one LINK for each type of target.
		
		v1.2 2009-02-03: Modified by Kristin Schoug Bertilsson. The attribute 
		elementFormDefault="qualified" was added because of problems with the 
		nameSpace validation.
                
                v1.3 2012-11-01. Modified by Bjorn Strihagen Inera (HCT)
                Replaced xmlns=.. with xmlns:tns=.. in header and qualified referred types with tns:
                This is required by svcutil.exe
		-----------------------------------------------------------------------------</xs:documentation>
  </xs:annotation>
  <xs:include schemaLocation="http://localhost:11000/npoadapter/ehrextract/v11?xsd=ISO_dt.xsd"/>
  <xs:include schemaLocation="http://localhost:11000/npoadapter/ehrextract/v11?xsd=SE13606-1_demographics.xsd"/>
  <!---->
  <!--The content of an XML document conforming to this schema-->
  <!---->
  <xs:element name="ehr_extract" type="tns:EHR_EXTRACT"/>
  <!---->
  <!--EHR Extract Types-->
  <!---->
  <xs:complexType name="EHR_EXTRACT">
    <xs:annotation>
      <xs:documentation>The root node of an EHR Extract.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element minOccurs="0" name="authorising_party" type="II"/>
      <xs:element name="ehr_id" type="II"/>
      <xs:element name="ehr_system" type="II"/>
      <xs:element fixed="EN 13606" name="rm_id"/>
      <xs:element name="subject_of_care" type="II"/>
      <xs:element name="time_created" type="TS"/>
      <xs:element maxOccurs="unbounded" minOccurs="0" name="all_compositions" type="tns:COMPOSITION"/>
      <xs:element maxOccurs="unbounded" minOccurs="0" name="criteria" type="tns:EXTRACT_CRITERIA"/>
      <xs:element maxOccurs="unbounded" minOccurs="0" name="folders" type="tns:FOLDER"/>
      <xs:element maxOccurs="unbounded" minOccurs="0" name="demographic_extract" type="tns:IDENTIFIED_ENTITY"/>
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="EXTRACT_CRITERIA">
    <xs:annotation>
      <xs:documentation>Restrictions or filters on the creation of the EHR Extract.
        The time_period  should be a  restriction on the data types
        of low and  high to  make them TS,  but this restriction is
        not permissible in XML  Schema and thus the IVL  properties
        are simply  copied here with the appropriate types.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element minOccurs="0" name="all_versions" type="BL"/>
      <xs:element maxOccurs="unbounded" minOccurs="0" name="archetype_ids" type="II"/>
      <xs:element minOccurs="0" name="max_sensitivity" type="INT"/>
      <xs:element minOccurs="0" name="multimedia_included" type="BL"/>
      <xs:element minOccurs="0" name="other_constraints" type="ST"/>
      <xs:element minOccurs="0" name="time_period" type="IVL_TS"/>
    </xs:sequence>
  </xs:complexType>
  <xs:complexType abstract="true" name="RECORD_COMPONENT">
    <xs:annotation>
      <xs:documentation>Superclass  of all concrete  aggregator classes in  the EHR
        hierarchy.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element minOccurs="0" name="archetype_id" type="ST"/>
      <xs:element minOccurs="0" name="meaning" type="CD"/>
      <xs:element name="name" type="ST"/>
      <xs:element minOccurs="0" name="orig_parent_ref" type="II"/>
      <xs:element maxOccurs="unbounded" minOccurs="0" name="policy_ids" type="II"/>
      <xs:element name="rc_id" type="II"/>
      <xs:element minOccurs="0" name="sensitivity" type="INT"/>
      <xs:element name="synthesised" type="BL"/>
      <xs:element maxOccurs="unbounded" minOccurs="0" name="links" type="tns:LINK"/>
      <xs:element minOccurs="0" name="feeder_audit" type="tns:AUDIT_INFO"/>
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="FOLDER">
    <xs:annotation>
      <xs:documentation>Organises and groups Compositions within an EHR Extract.</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="tns:RECORD_COMPONENT">
        <xs:sequence>
          <xs:element maxOccurs="unbounded" minOccurs="0" name="sub_folders" type="tns:FOLDER"/>
          <xs:element maxOccurs="unbounded" minOccurs="0" name="attestations" type="tns:ATTESTATION_INFO"/>
          <xs:element maxOccurs="unbounded" minOccurs="0" name="composition_rc_ids" type="ST"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="COMPOSITION">
    <xs:annotation>
      <xs:documentation>Key  aggregation  class  representing  the  set  of  Record
        Components authored and committed during a  single clinical
        encounter.  Note the  values for  territory  will  indicate
        the legal  framework under which  the  data was  committed.
        The session_time should be a  restriction on the data types
        of low and  high to  make them TS,  but this restriction is
        not permissible in XML  Schema and thus the IVL  properties
        are simply copied here with the appropriate types.</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="tns:RECORD_COMPONENT">
        <xs:sequence>
          <xs:element minOccurs="0" name="contribution_id" type="II"/>
          <xs:element minOccurs="0" name="session_time" type="IVL_TS"/>
          <xs:element minOccurs="0" name="territory" type="CS"/>
          <xs:element maxOccurs="unbounded" minOccurs="0" name="attestations" type="tns:ATTESTATION_INFO"/>
          <xs:element maxOccurs="unbounded" minOccurs="0" name="other_participations" type="tns:FUNCTIONAL_ROLE"/>
          <xs:element name="committal" type="tns:AUDIT_INFO"/>
          <xs:element minOccurs="0" name="composer" type="tns:FUNCTIONAL_ROLE"/>
          <xs:element maxOccurs="unbounded" minOccurs="0" name="content" type="tns:CONTENT"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType abstract="true" name="CONTENT">
    <xs:annotation>
      <xs:documentation>Superclass of Section and Entry that  enables the former to
        include instances of itself.</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="tns:RECORD_COMPONENT"/>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="SECTION">
    <xs:annotation>
      <xs:documentation>Represents  a heading  in the  record  under which  further
        Entry instances might be found.</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="tns:CONTENT">
        <xs:sequence>
          <xs:element maxOccurs="unbounded" minOccurs="0" name="members" type="tns:CONTENT"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="ENTRY">
    <xs:annotation>
      <xs:documentation>Represents the information  acquired for a  single clinical
        activity  or recording.  The  Entry  may be  nilled  if  it 
        corrects a previous erroneous version.</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="tns:CONTENT">
        <xs:sequence>
          <xs:element minOccurs="0" name="act_id" type="ST"/>
          <xs:element minOccurs="0" name="act_status" type="CS"/>
          <xs:element minOccurs="0" name="subject_of_information_category" type="CS"/>
          <xs:element name="uncertainty_expressed" type="BL"/>
          <xs:element maxOccurs="unbounded" minOccurs="0" name="items" nillable="true" type="tns:ITEM"/>
          <xs:element minOccurs="0" name="info_provider" type="tns:FUNCTIONAL_ROLE"/>
          <xs:element maxOccurs="unbounded" minOccurs="0" name="other_participations" type="tns:FUNCTIONAL_ROLE"/>
          <xs:element minOccurs="0" name="subject_of_information" type="tns:RELATED_PARTY"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType abstract="true" name="ITEM">
    <xs:annotation>
      <xs:documentation>Superclass of  Cluster and Element  that enables the former
        to include  instances of itself.  The obs_time  should be a
        restriction on the data types of low and high to make  them
        TS,  but this  restriction is not permissible in XML Schema
        and thus the IVL properties are simply copied here with the
        appropriate types.</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="tns:RECORD_COMPONENT">
        <xs:sequence>
          <xs:element minOccurs="0" name="emphasis" type="CD"/>
          <xs:element minOccurs="0" name="item_category" type="CS"/>
          <xs:element minOccurs="0" name="obs_time" type="IVL_TS"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="CLUSTER">
    <xs:annotation>
      <xs:documentation>Represents hierarchical organisation of data values.</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="tns:ITEM">
        <xs:sequence>
          <xs:element name="structure_type" type="CS"/>
          <xs:element maxOccurs="unbounded" minOccurs="0" name="parts" type="tns:ITEM"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="ELEMENT">
    <xs:annotation>
      <xs:documentation>The Data Value holder in the aggregation structure.</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="tns:ITEM">
        <xs:sequence>
          <xs:element minOccurs="0" name="value" type="ANY"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="AUDIT_INFO">
    <xs:annotation>
      <xs:documentation>The  committal  and revision  data for a  Record Component.
        Note   that  the   invariant  is   incorrectly  stated   as 
        constraining  "attribute_version_status.coding_scheme_name"
        in the printed standard.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="committer" type="II"/>
      <xs:element name="ehr_system" type="II"/>
      <xs:element minOccurs="0" name="previous_version" type="II"/>
      <xs:element minOccurs="0" name="reason_for_revision" type="CD"/>
      <xs:element name="time_committed" type="TS"/>
      <xs:element minOccurs="0" name="version_set_id" type="II"/>
      <xs:element minOccurs="0" name="version_status" type="CS"/>
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="ATTESTATION_INFO">
    <xs:annotation>
      <xs:documentation>Any  attestations  for a Record Component.  The proof field
        should be a  cryptographic  hash of the RECORD_COMPONENT it
        attests,  but it is recognised that in many implementations
        the components will change to  point to new components that
        revise  them.  In  that case,  the  proof  should sign  the
        unchanging parts of the component only.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element minOccurs="0" name="attested_view" type="ED"/>
      <xs:element minOccurs="0" name="proof" type="ED"/>
      <xs:element name="reason_for_attestation" type="CD"/>
      <xs:element name="time" type="TS"/>
      <xs:element maxOccurs="unbounded" name="target_rc_id" type="II"/>
      <xs:element name="attester" type="tns:FUNCTIONAL_ROLE"/>
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="FUNCTIONAL_ROLE">
    <xs:annotation>
      <xs:documentation>The participation of an entity in the EHR.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element minOccurs="0" name="function" type="CD"/>
      <xs:element minOccurs="0" name="healthcare_facility" type="II"/>
      <xs:element minOccurs="0" name="mode" type="CS"/>
      <xs:element name="performer" type="II"/>
      <xs:element minOccurs="0" name="service_setting" type="CD"/>
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="RELATED_PARTY">
    <xs:annotation>
      <xs:documentation>Identifies the relationship  of a person to the  subject of
        care. Specifically used in Entry.subject_of_information.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element minOccurs="0" name="party" type="II"/>
      <xs:element name="relationship" type="ED"/>
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="LINK">
    <xs:annotation>
      <xs:documentation>Creates a  relationship between  two Record Components that
        is orthogonal  to the common one of containment.  Note that
        if a recipient is not permitted to see the component linked
        to,  even revealing the  link constitutes an  inappropriate
        disclosure.  Role is  of type  CD so  that  the displayName
        property of that class can be used in place of any specific
        coding scheme.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="follow_link" type="BL"/>
      <xs:element name="nature" type="CS"/>
      <xs:element minOccurs="0" name="role" type="CD"/>
      <xs:element minOccurs="0" name="target_type" type="CD"/>
      <xs:element maxOccurs="unbounded" name="target_id" type="II"/>
    </xs:sequence>
  </xs:complexType>
</xs:schema>]]></con:content><con:type>http://www.w3.org/2001/XMLSchema</con:type></con:part><con:part><con:url>http://localhost:11000/npoadapter/ehrextract/v11?xsd=SE13606-1_demographics.xsd</con:url><con:content><![CDATA[<xs:schema attributeFormDefault="unqualified" elementFormDefault="qualified" targetNamespace="urn:riv13606:v1.1" xmlns="urn:riv13606:v1.1" xmlns:tns="urn:riv13606:v1.1" xmlns:xs="http://www.w3.org/2001/XMLSchema">
  <!--xmlns="urn:riv13606:v1.1"-->
  <!---->
  <!--Demographics Types-->
  <!---->
  <!--The demographics package is provided on page 47  of the CEN/ISO
    13606 part 1 standard.
    
    Note possible shortcomings of the 13606-1 definition:
    (a) On several occasions in the standard a code is described as
    having a CS type, but only two of the necessary parts of the CS
    are provided by the documentation (usually a value and a human-
    readable   portion).   They  are  represented  here  as  simple
    enumerations (with whitespace removed as necessary).-->
  <xs:include schemaLocation="http://localhost:11000/npoadapter/ehrextract/v11?xsd=ISO_dt.xsd"/>
  <xs:complexType abstract="true" name="IDENTIFIED_ENTITY">
    <xs:annotation>
      <xs:documentation>Superclass of all  identified parties  to the record.  Note
        that the  type of  id is not  given  in the  printed  class
        description  but  is included  in the class diagram on page
        47 of the standard.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="extract_id" type="II"/>
      <xs:element maxOccurs="unbounded" minOccurs="0" name="id" type="II"/>
      <xs:element maxOccurs="unbounded" minOccurs="0" name="telecom" type="TEL"/>
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="SOFTWARE_OR_DEVICE">
    <xs:annotation>
      <xs:documentation>A piece of equipment or a device.</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="tns:IDENTIFIED_ENTITY">
        <xs:sequence>
          <xs:element name="code" type="CD"/>
          <xs:element name="desc" type="ST"/>
          <xs:element name="manufacturerModelName" type="ST"/>
          <xs:element minOccurs="0" name="version" type="ST"/>
          <xs:element minOccurs="0" name="owningOrganisation_id" type="ST"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="ORGANISATION">
    <xs:annotation>
      <xs:documentation>An  organisation  corresponding to GPIC 2.008  (2008 in the
        printed standard).</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="tns:IDENTIFIED_ENTITY">
        <xs:sequence>
          <xs:element name="code" type="CD"/>
          <xs:element name="desc" type="ST"/>
          <xs:element name="name" type="ST"/>
          <xs:element maxOccurs="unbounded" minOccurs="0" name="addr" type="AD"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="PERSON">
    <xs:annotation>
      <xs:documentation>General    demographic    information    about   a   person
        corresponding to GPIC 2.006.</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="tns:IDENTIFIED_ENTITY">
        <xs:sequence>
          <xs:element maxOccurs="unbounded" minOccurs="0" name="name" type="EN"/>
          <xs:element maxOccurs="unbounded" minOccurs="0" name="addr" type="AD"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="IDENTIFIED_HEALTHCARE_PROFESSIONAL">
    <xs:annotation>
      <xs:documentation>Reference to an identified healthcare professional, derived 
        from GPIC 2.034.</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="tns:PERSON">
        <xs:sequence>
          <xs:element maxOccurs="unbounded" minOccurs="0" name="role" type="tns:HEALTHCARE_PROFESSIONAL_ROLE"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="HEALTHCARE_PROFESSIONAL_ROLE">
    <xs:annotation>
      <xs:documentation>Describes the  role of  a  healthcare professional  in  the 
        record,  based on  the GPICS  class of the  same name. Note
        that the id instances  should refer to the  same identified
        individual,   but   might  be   needed  to  establish  that 
        individual's identity in different working environments.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element maxOccurs="unbounded" minOccurs="0" name="id" type="II"/>
      <xs:element minOccurs="0" name="position_or_grade" type="CD"/>
      <xs:element minOccurs="0" name="profession" type="CD"/>
      <xs:element minOccurs="0" name="specialty" type="CD"/>
      <xs:element minOccurs="0" name="scopingOrganisation_id" type="II"/>
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="SUBJECT_OF_CARE_PERSON_IDENTIFICATION">
    <xs:annotation>
      <xs:documentation>Identification information about a person  corresponding to
        GPIC 2.015.</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="tns:PERSON">
        <xs:sequence>
          <xs:element name="administrativeGenderCode" type="CS"/>
          <xs:element minOccurs="0" name="birthOrderNumber" type="INT"/>
          <xs:element name="birthTime" type="TS"/>
          <xs:element minOccurs="0" name="deceasedTime" type="TS"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
</xs:schema>]]></con:content><con:type>http://www.w3.org/2001/XMLSchema</con:type></con:part></con:definitionCache><con:endpoints><con:endpoint>http://localhost:11000/npoadapter/ehrextract/v11</con:endpoint></con:endpoints><con:operation isOneWay="false" action="urn:riv13606:v1.1:RIV13606REQUEST_EHR_EXTRACT" name="RIV13606REQUEST_EHR_EXTRACT" bindingOperationName="RIV13606REQUEST_EHR_EXTRACT" type="Request-Response" inputName="" receivesAttachments="false" sendsAttachments="false" anonymous="optional"><con:settings/><con:call name="Short"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;xml-fragment/></con:setting></con:settings><con:encoding>UTF-8</con:encoding><con:endpoint>http://localhost:11000/npoadapter/ehrextract/stub</con:endpoint><con:request><![CDATA[<soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/" 
xmlns:urn="urn:riv13606:v1.1">
   <soapenv:Header/>
   <soapenv:Body>
      <urn:RIV13606REQUEST_EHR_EXTRACT_request>
		<urn:subject_of_care_id root="1.2.752.129.2.1.3.1" extension="193812217044"/>
		<urn:time_period><urn:low value="20080101"/><urn:high value="20080520"/></urn:time_period>	
		<urn:meanings code="voo"/>
		<urn:max_records value="100"/>		
		<urn:parameters>
			<urn:name value="hsa_id" />
			<urn:value value="123456" />
		</urn:parameters>
      </urn:RIV13606REQUEST_EHR_EXTRACT_request>
   </soapenv:Body>
</soapenv:Envelope>]]></con:request><con:credentials><con:authType>Global HTTP Settings</con:authType></con:credentials><con:jmsConfig JMSDeliveryMode="PERSISTENT"/><con:jmsPropertyConfig/><con:wsaConfig mustUnderstand="NONE" version="200508" action="urn:riv13606:v1.1:RIV13606REQUEST_EHR_EXTRACT"/><con:wsrmConfig version="1.2"/></con:call><con:call name="Long"><con:settings/><con:encoding>UTF-8</con:encoding><con:endpoint>http://localhost:11000/npoadapter/ehrextract/v11</con:endpoint><con:request><![CDATA[<soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/" xmlns:urn="urn:riv13606:v1.1">
   <soapenv:Header/>
   <soapenv:Body>
      <urn:RIV13606REQUEST_EHR_EXTRACT_request>
         <urn:subject_of_care_id validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" root="?" extension="?" identifierName="?" displayable="?" scope="?" reliability="?"/>
         <!--Optional:-->
         <urn:purpose validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" code="?" codeSystem="?" codeSystemName="?" codeSystemVersion="?" valueSet="?" valueSetVersion="?" codingRationale="?" id="?">
            <!--Optional:-->
            <urn:displayName validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?" language="?">
               <!--Zero or more repetitions:-->
               <urn:translation validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?" language="?"/>
            </urn:displayName>
            <!--Optional:-->
            <urn:originalText validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?" mediaType="text/plain" charset="?" language="?" integrityCheckAlgorithm="?">
               <!--Optional:-->
               <urn:reference validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?">
                  <!--Optional:-->
                  <urn:useablePeriod validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?">
                     <!--Optional:-->
                     <urn:originalText/>
                  </urn:useablePeriod>
               </urn:reference>
               <!--Optional:-->
               <urn:description validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?" language="?">
                  <!--Zero or more repetitions:-->
                  <urn:translation validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?" language="?"/>
               </urn:description>
            </urn:originalText>
            <!--Zero or more repetitions:-->
            <urn:translation/>
            <!--Optional:-->
            <urn:source xref="?"/>
         </urn:purpose>
         <!--Zero or more repetitions:-->
         <urn:rc_ids validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" root="?" extension="?" identifierName="?" displayable="?" scope="?" reliability="?"/>
         <!--Optional:-->
         <urn:time_period validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" lowClosed="?" highClosed="?">
            <!--Optional:-->
            <urn:originalText validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?" mediaType="text/plain" charset="?" language="?" integrityCheckAlgorithm="?">
               <!--Optional:-->
               <urn:reference validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?">
                  <!--Optional:-->
                  <urn:useablePeriod validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?">
                     <!--Optional:-->
                     <urn:originalText/>
                  </urn:useablePeriod>
               </urn:reference>
               <!--Optional:-->
               <urn:description validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?" language="?">
                  <!--Zero or more repetitions:-->
                  <urn:translation validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?" language="?"/>
               </urn:description>
            </urn:originalText>
            <!--Optional:-->
            <urn:low validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" uncertaintyType="?" value="?">
               <!--Optional:-->
               <urn:expression validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?" mediaType="text/plain" charset="?" language="?" compression="?" integrityCheckAlgorithm="?">
                  <!--Optional:-->
                  <urn:data>cid:295307093210</urn:data>
                  <!--Optional:-->
                  <urn:xml>?</urn:xml>
                  <!--Optional:-->
                  <urn:reference validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?">
                     <!--Optional:-->
                     <urn:useablePeriod validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?">
                        <!--Optional:-->
                        <urn:originalText validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?" mediaType="text/plain" charset="?" language="?" integrityCheckAlgorithm="?">
                           <!--Optional:-->
                           <urn:reference/>
                           <!--Optional:-->
                           <urn:description validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?" language="?">
                              <!--Zero or more repetitions:-->
                              <urn:translation validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?" language="?"/>
                           </urn:description>
                        </urn:originalText>
                     </urn:useablePeriod>
                  </urn:reference>
                  <!--Optional:-->
                  <urn:integrityCheck>cid:150219978041</urn:integrityCheck>
                  <!--Optional:-->
                  <urn:thumbnail/>
                  <!--Optional:-->
                  <urn:description validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?" language="?">
                     <!--Zero or more repetitions:-->
                     <urn:translation validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?" language="?"/>
                  </urn:description>
                  <!--Zero or more repetitions:-->
                  <urn:translation/>
               </urn:expression>
               <!--Optional:-->
               <urn:originalText validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?" mediaType="text/plain" charset="?" language="?" integrityCheckAlgorithm="?">
                  <!--Optional:-->
                  <urn:reference validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?">
                     <!--Optional:-->
                     <urn:useablePeriod validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?">
                        <!--Optional:-->
                        <urn:originalText/>
                     </urn:useablePeriod>
                  </urn:reference>
                  <!--Optional:-->
                  <urn:description validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?" language="?">
                     <!--Zero or more repetitions:-->
                     <urn:translation validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?" language="?"/>
                  </urn:description>
               </urn:originalText>
               <!--Optional:-->
               <urn:uncertainty validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" uncertaintyType="?">
                  <!--Optional:-->
                  <urn:expression validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?" mediaType="text/plain" charset="?" language="?" compression="?" integrityCheckAlgorithm="?">
                     <!--Optional:-->
                     <urn:data>cid:269584195702</urn:data>
                     <!--Optional:-->
                     <urn:xml>?</urn:xml>
                     <!--Optional:-->
                     <urn:reference validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?">
                        <!--Optional:-->
                        <urn:useablePeriod validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?">
                           <!--Optional:-->
                           <urn:originalText validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?" mediaType="text/plain" charset="?" language="?" integrityCheckAlgorithm="?">
                              <!--Optional:-->
                              <urn:reference/>
                              <!--Optional:-->
                              <urn:description validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?" language="?">
                                 <!--Zero or more repetitions:-->
                                 <urn:translation validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?" language="?"/>
                              </urn:description>
                           </urn:originalText>
                        </urn:useablePeriod>
                     </urn:reference>
                     <!--Optional:-->
                     <urn:integrityCheck>cid:578999933576</urn:integrityCheck>
                     <!--Optional:-->
                     <urn:thumbnail/>
                     <!--Optional:-->
                     <urn:description validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?" language="?">
                        <!--Zero or more repetitions:-->
                        <urn:translation validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?" language="?"/>
                     </urn:description>
                     <!--Zero or more repetitions:-->
                     <urn:translation/>
                  </urn:expression>
                  <!--Optional:-->
                  <urn:originalText validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?" mediaType="text/plain" charset="?" language="?" integrityCheckAlgorithm="?">
                     <!--Optional:-->
                     <urn:reference validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?">
                        <!--Optional:-->
                        <urn:useablePeriod validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?">
                           <!--Optional:-->
                           <urn:originalText/>
                        </urn:useablePeriod>
                     </urn:reference>
                     <!--Optional:-->
                     <urn:description validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?" language="?">
                        <!--Zero or more repetitions:-->
                        <urn:translation validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?" language="?"/>
                     </urn:description>
                  </urn:originalText>
                  <!--Optional:-->
                  <urn:uncertainty/>
               </urn:uncertainty>
            </urn:low>
            <!--Optional:-->
            <urn:high validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" uncertaintyType="?" value="?">
               <!--Optional:-->
               <urn:expression validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?" mediaType="text/plain" charset="?" language="?" compression="?" integrityCheckAlgorithm="?">
                  <!--Optional:-->
                  <urn:data>cid:319933574071</urn:data>
                  <!--Optional:-->
                  <urn:xml>?</urn:xml>
                  <!--Optional:-->
                  <urn:reference validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?">
                     <!--Optional:-->
                     <urn:useablePeriod validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?">
                        <!--Optional:-->
                        <urn:originalText validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?" mediaType="text/plain" charset="?" language="?" integrityCheckAlgorithm="?">
                           <!--Optional:-->
                           <urn:reference/>
                           <!--Optional:-->
                           <urn:description validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?" language="?">
                              <!--Zero or more repetitions:-->
                              <urn:translation validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?" language="?"/>
                           </urn:description>
                        </urn:originalText>
                     </urn:useablePeriod>
                  </urn:reference>
                  <!--Optional:-->
                  <urn:integrityCheck>cid:1004939940704</urn:integrityCheck>
                  <!--Optional:-->
                  <urn:thumbnail/>
                  <!--Optional:-->
                  <urn:description validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?" language="?">
                     <!--Zero or more repetitions:-->
                     <urn:translation validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?" language="?"/>
                  </urn:description>
                  <!--Zero or more repetitions:-->
                  <urn:translation/>
               </urn:expression>
               <!--Optional:-->
               <urn:originalText validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?" mediaType="text/plain" charset="?" language="?" integrityCheckAlgorithm="?">
                  <!--Optional:-->
                  <urn:reference validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?">
                     <!--Optional:-->
                     <urn:useablePeriod validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?">
                        <!--Optional:-->
                        <urn:originalText/>
                     </urn:useablePeriod>
                  </urn:reference>
                  <!--Optional:-->
                  <urn:description validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?" language="?">
                     <!--Zero or more repetitions:-->
                     <urn:translation validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?" language="?"/>
                  </urn:description>
               </urn:originalText>
               <!--Optional:-->
               <urn:uncertainty validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" uncertaintyType="?">
                  <!--Optional:-->
                  <urn:expression validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?" mediaType="text/plain" charset="?" language="?" compression="?" integrityCheckAlgorithm="?">
                     <!--Optional:-->
                     <urn:data>cid:639657811621</urn:data>
                     <!--Optional:-->
                     <urn:xml>?</urn:xml>
                     <!--Optional:-->
                     <urn:reference validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?">
                        <!--Optional:-->
                        <urn:useablePeriod validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?">
                           <!--Optional:-->
                           <urn:originalText validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?" mediaType="text/plain" charset="?" language="?" integrityCheckAlgorithm="?">
                              <!--Optional:-->
                              <urn:reference/>
                              <!--Optional:-->
                              <urn:description validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?" language="?">
                                 <!--Zero or more repetitions:-->
                                 <urn:translation validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?" language="?"/>
                              </urn:description>
                           </urn:originalText>
                        </urn:useablePeriod>
                     </urn:reference>
                     <!--Optional:-->
                     <urn:integrityCheck>cid:1147051424032</urn:integrityCheck>
                     <!--Optional:-->
                     <urn:thumbnail/>
                     <!--Optional:-->
                     <urn:description validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?" language="?">
                        <!--Zero or more repetitions:-->
                        <urn:translation validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?" language="?"/>
                     </urn:description>
                     <!--Zero or more repetitions:-->
                     <urn:translation/>
                  </urn:expression>
                  <!--Optional:-->
                  <urn:originalText validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?" mediaType="text/plain" charset="?" language="?" integrityCheckAlgorithm="?">
                     <!--Optional:-->
                     <urn:reference validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?">
                        <!--Optional:-->
                        <urn:useablePeriod validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?">
                           <!--Optional:-->
                           <urn:originalText/>
                        </urn:useablePeriod>
                     </urn:reference>
                     <!--Optional:-->
                     <urn:description validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?" language="?">
                        <!--Zero or more repetitions:-->
                        <urn:translation validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?" language="?"/>
                     </urn:description>
                  </urn:originalText>
                  <!--Optional:-->
                  <urn:uncertainty/>
               </urn:uncertainty>
            </urn:high>
            <!--Optional:-->
            <urn:width validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" uncertaintyType="?">
               <!--Optional:-->
               <urn:expression validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?" mediaType="text/plain" charset="?" language="?" compression="?" integrityCheckAlgorithm="?">
                  <!--Optional:-->
                  <urn:data>cid:849694152551</urn:data>
                  <!--Optional:-->
                  <urn:xml>?</urn:xml>
                  <!--Optional:-->
                  <urn:reference validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?">
                     <!--Optional:-->
                     <urn:useablePeriod validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?">
                        <!--Optional:-->
                        <urn:originalText validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?" mediaType="text/plain" charset="?" language="?" integrityCheckAlgorithm="?">
                           <!--Optional:-->
                           <urn:reference/>
                           <!--Optional:-->
                           <urn:description validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?" language="?">
                              <!--Zero or more repetitions:-->
                              <urn:translation validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?" language="?"/>
                           </urn:description>
                        </urn:originalText>
                     </urn:useablePeriod>
                  </urn:reference>
                  <!--Optional:-->
                  <urn:integrityCheck>cid:258177994706</urn:integrityCheck>
                  <!--Optional:-->
                  <urn:thumbnail/>
                  <!--Optional:-->
                  <urn:description validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?" language="?">
                     <!--Zero or more repetitions:-->
                     <urn:translation validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?" language="?"/>
                  </urn:description>
                  <!--Zero or more repetitions:-->
                  <urn:translation/>
               </urn:expression>
               <!--Optional:-->
               <urn:originalText validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?" mediaType="text/plain" charset="?" language="?" integrityCheckAlgorithm="?">
                  <!--Optional:-->
                  <urn:reference validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?">
                     <!--Optional:-->
                     <urn:useablePeriod validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?">
                        <!--Optional:-->
                        <urn:originalText/>
                     </urn:useablePeriod>
                  </urn:reference>
                  <!--Optional:-->
                  <urn:description validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?" language="?">
                     <!--Zero or more repetitions:-->
                     <urn:translation validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?" language="?"/>
                  </urn:description>
               </urn:originalText>
               <!--Optional:-->
               <urn:uncertainty/>
            </urn:width>
            <!--Optional:-->
            <urn:any validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" uncertaintyType="?" value="?">
               <!--Optional:-->
               <urn:expression validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?" mediaType="text/plain" charset="?" language="?" compression="?" integrityCheckAlgorithm="?">
                  <!--Optional:-->
                  <urn:data>cid:49845883262</urn:data>
                  <!--Optional:-->
                  <urn:xml>?</urn:xml>
                  <!--Optional:-->
                  <urn:reference validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?">
                     <!--Optional:-->
                     <urn:useablePeriod validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?">
                        <!--Optional:-->
                        <urn:originalText validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?" mediaType="text/plain" charset="?" language="?" integrityCheckAlgorithm="?">
                           <!--Optional:-->
                           <urn:reference/>
                           <!--Optional:-->
                           <urn:description validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?" language="?">
                              <!--Zero or more repetitions:-->
                              <urn:translation validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?" language="?"/>
                           </urn:description>
                        </urn:originalText>
                     </urn:useablePeriod>
                  </urn:reference>
                  <!--Optional:-->
                  <urn:integrityCheck>cid:553899112443</urn:integrityCheck>
                  <!--Optional:-->
                  <urn:thumbnail/>
                  <!--Optional:-->
                  <urn:description validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?" language="?">
                     <!--Zero or more repetitions:-->
                     <urn:translation validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?" language="?"/>
                  </urn:description>
                  <!--Zero or more repetitions:-->
                  <urn:translation/>
               </urn:expression>
               <!--Optional:-->
               <urn:originalText validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?" mediaType="text/plain" charset="?" language="?" integrityCheckAlgorithm="?">
                  <!--Optional:-->
                  <urn:reference validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?">
                     <!--Optional:-->
                     <urn:useablePeriod validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?">
                        <!--Optional:-->
                        <urn:originalText/>
                     </urn:useablePeriod>
                  </urn:reference>
                  <!--Optional:-->
                  <urn:description validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?" language="?">
                     <!--Zero or more repetitions:-->
                     <urn:translation validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?" language="?"/>
                  </urn:description>
               </urn:originalText>
               <!--Optional:-->
               <urn:uncertainty validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" uncertaintyType="?">
                  <!--Optional:-->
                  <urn:expression validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?" mediaType="text/plain" charset="?" language="?" compression="?" integrityCheckAlgorithm="?">
                     <!--Optional:-->
                     <urn:data>cid:967497116875</urn:data>
                     <!--Optional:-->
                     <urn:xml>?</urn:xml>
                     <!--Optional:-->
                     <urn:reference validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?">
                        <!--Optional:-->
                        <urn:useablePeriod validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?">
                           <!--Optional:-->
                           <urn:originalText validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?" mediaType="text/plain" charset="?" language="?" integrityCheckAlgorithm="?">
                              <!--Optional:-->
                              <urn:reference/>
                              <!--Optional:-->
                              <urn:description validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?" language="?">
                                 <!--Zero or more repetitions:-->
                                 <urn:translation validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?" language="?"/>
                              </urn:description>
                           </urn:originalText>
                        </urn:useablePeriod>
                     </urn:reference>
                     <!--Optional:-->
                     <urn:integrityCheck>cid:1016194314545</urn:integrityCheck>
                     <!--Optional:-->
                     <urn:thumbnail/>
                     <!--Optional:-->
                     <urn:description validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?" language="?">
                        <!--Zero or more repetitions:-->
                        <urn:translation validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?" language="?"/>
                     </urn:description>
                     <!--Zero or more repetitions:-->
                     <urn:translation/>
                  </urn:expression>
                  <!--Optional:-->
                  <urn:originalText validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?" mediaType="text/plain" charset="?" language="?" integrityCheckAlgorithm="?">
                     <!--Optional:-->
                     <urn:reference validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?">
                        <!--Optional:-->
                        <urn:useablePeriod validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?">
                           <!--Optional:-->
                           <urn:originalText/>
                        </urn:useablePeriod>
                     </urn:reference>
                     <!--Optional:-->
                     <urn:description validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?" language="?">
                        <!--Zero or more repetitions:-->
                        <urn:translation validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?" language="?"/>
                     </urn:description>
                  </urn:originalText>
                  <!--Optional:-->
                  <urn:uncertainty/>
               </urn:uncertainty>
            </urn:any>
         </urn:time_period>
         <!--Optional:-->
         <urn:max_sensitivity validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" uncertaintyType="?" value="?">
            <!--Optional:-->
            <urn:expression validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?" mediaType="text/plain" charset="?" language="?" compression="?" integrityCheckAlgorithm="?">
               <!--Optional:-->
               <urn:data>cid:890485746242</urn:data>
               <!--Optional:-->
               <urn:xml>?</urn:xml>
               <!--Optional:-->
               <urn:reference validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?">
                  <!--Optional:-->
                  <urn:useablePeriod validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?">
                     <!--Optional:-->
                     <urn:originalText validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?" mediaType="text/plain" charset="?" language="?" integrityCheckAlgorithm="?">
                        <!--Optional:-->
                        <urn:reference/>
                        <!--Optional:-->
                        <urn:description validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?" language="?">
                           <!--Zero or more repetitions:-->
                           <urn:translation validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?" language="?"/>
                        </urn:description>
                     </urn:originalText>
                  </urn:useablePeriod>
               </urn:reference>
               <!--Optional:-->
               <urn:integrityCheck>cid:1131189418712</urn:integrityCheck>
               <!--Optional:-->
               <urn:thumbnail/>
               <!--Optional:-->
               <urn:description validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?" language="?">
                  <!--Zero or more repetitions:-->
                  <urn:translation validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?" language="?"/>
               </urn:description>
               <!--Zero or more repetitions:-->
               <urn:translation/>
            </urn:expression>
            <!--Optional:-->
            <urn:originalText validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?" mediaType="text/plain" charset="?" language="?" integrityCheckAlgorithm="?">
               <!--Optional:-->
               <urn:reference validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?">
                  <!--Optional:-->
                  <urn:useablePeriod validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?">
                     <!--Optional:-->
                     <urn:originalText/>
                  </urn:useablePeriod>
               </urn:reference>
               <!--Optional:-->
               <urn:description validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?" language="?">
                  <!--Zero or more repetitions:-->
                  <urn:translation validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?" language="?"/>
               </urn:description>
            </urn:originalText>
            <!--Optional:-->
            <urn:uncertainty validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" uncertaintyType="?">
               <!--Optional:-->
               <urn:expression validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?" mediaType="text/plain" charset="?" language="?" compression="?" integrityCheckAlgorithm="?">
                  <!--Optional:-->
                  <urn:data>cid:431365122053</urn:data>
                  <!--Optional:-->
                  <urn:xml>?</urn:xml>
                  <!--Optional:-->
                  <urn:reference validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?">
                     <!--Optional:-->
                     <urn:useablePeriod validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?">
                        <!--Optional:-->
                        <urn:originalText validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?" mediaType="text/plain" charset="?" language="?" integrityCheckAlgorithm="?">
                           <!--Optional:-->
                           <urn:reference/>
                           <!--Optional:-->
                           <urn:description validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?" language="?">
                              <!--Zero or more repetitions:-->
                              <urn:translation validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?" language="?"/>
                           </urn:description>
                        </urn:originalText>
                     </urn:useablePeriod>
                  </urn:reference>
                  <!--Optional:-->
                  <urn:integrityCheck>cid:1316547050216</urn:integrityCheck>
                  <!--Optional:-->
                  <urn:thumbnail/>
                  <!--Optional:-->
                  <urn:description validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?" language="?">
                     <!--Zero or more repetitions:-->
                     <urn:translation validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?" language="?"/>
                  </urn:description>
                  <!--Zero or more repetitions:-->
                  <urn:translation/>
               </urn:expression>
               <!--Optional:-->
               <urn:originalText validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?" mediaType="text/plain" charset="?" language="?" integrityCheckAlgorithm="?">
                  <!--Optional:-->
                  <urn:reference validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?">
                     <!--Optional:-->
                     <urn:useablePeriod validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?">
                        <!--Optional:-->
                        <urn:originalText/>
                     </urn:useablePeriod>
                  </urn:reference>
                  <!--Optional:-->
                  <urn:description validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?" language="?">
                     <!--Zero or more repetitions:-->
                     <urn:translation validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?" language="?"/>
                  </urn:description>
               </urn:originalText>
               <!--Optional:-->
               <urn:uncertainty/>
            </urn:uncertainty>
         </urn:max_sensitivity>
         <!--Optional:-->
         <urn:all_versions validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?"/>
         <!--Optional:-->
         <urn:multimedia_included validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?"/>
         <!--Zero or more repetitions:-->
         <urn:archetype_ids validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" root="?" extension="?" identifierName="?" displayable="?" scope="?" reliability="?"/>
         <!--Zero or more repetitions:-->
         <urn:meanings validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" code="?" codeSystem="?" codeSystemName="?" codeSystemVersion="?" valueSet="?" valueSetVersion="?" codingRationale="?" id="?">
            <!--Optional:-->
            <urn:displayName validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?" language="?">
               <!--Zero or more repetitions:-->
               <urn:translation validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?" language="?"/>
            </urn:displayName>
            <!--Optional:-->
            <urn:originalText validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?" mediaType="text/plain" charset="?" language="?" integrityCheckAlgorithm="?">
               <!--Optional:-->
               <urn:reference validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?">
                  <!--Optional:-->
                  <urn:useablePeriod validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?">
                     <!--Optional:-->
                     <urn:originalText/>
                  </urn:useablePeriod>
               </urn:reference>
               <!--Optional:-->
               <urn:description validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?" language="?">
                  <!--Zero or more repetitions:-->
                  <urn:translation validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?" language="?"/>
               </urn:description>
            </urn:originalText>
            <!--Zero or more repetitions:-->
            <urn:translation/>
            <!--Optional:-->
            <urn:source xref="?"/>
         </urn:meanings>
         <!--Optional:-->
         <urn:max_records validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" uncertaintyType="?" value="?">
            <!--Optional:-->
            <urn:expression validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?" mediaType="text/plain" charset="?" language="?" compression="?" integrityCheckAlgorithm="?">
               <!--Optional:-->
               <urn:data>cid:996049697748</urn:data>
               <!--Optional:-->
               <urn:xml>?</urn:xml>
               <!--Optional:-->
               <urn:reference validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?">
                  <!--Optional:-->
                  <urn:useablePeriod validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?">
                     <!--Optional:-->
                     <urn:originalText validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?" mediaType="text/plain" charset="?" language="?" integrityCheckAlgorithm="?">
                        <!--Optional:-->
                        <urn:reference/>
                        <!--Optional:-->
                        <urn:description validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?" language="?">
                           <!--Zero or more repetitions:-->
                           <urn:translation validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?" language="?"/>
                        </urn:description>
                     </urn:originalText>
                  </urn:useablePeriod>
               </urn:reference>
               <!--Optional:-->
               <urn:integrityCheck>cid:358052823721</urn:integrityCheck>
               <!--Optional:-->
               <urn:thumbnail/>
               <!--Optional:-->
               <urn:description validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?" language="?">
                  <!--Zero or more repetitions:-->
                  <urn:translation validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?" language="?"/>
               </urn:description>
               <!--Zero or more repetitions:-->
               <urn:translation/>
            </urn:expression>
            <!--Optional:-->
            <urn:originalText validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?" mediaType="text/plain" charset="?" language="?" integrityCheckAlgorithm="?">
               <!--Optional:-->
               <urn:reference validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?">
                  <!--Optional:-->
                  <urn:useablePeriod validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?">
                     <!--Optional:-->
                     <urn:originalText/>
                  </urn:useablePeriod>
               </urn:reference>
               <!--Optional:-->
               <urn:description validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?" language="?">
                  <!--Zero or more repetitions:-->
                  <urn:translation validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?" language="?"/>
               </urn:description>
            </urn:originalText>
            <!--Optional:-->
            <urn:uncertainty validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" uncertaintyType="?">
               <!--Optional:-->
               <urn:expression validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?" mediaType="text/plain" charset="?" language="?" compression="?" integrityCheckAlgorithm="?">
                  <!--Optional:-->
                  <urn:data>cid:636101478664</urn:data>
                  <!--Optional:-->
                  <urn:xml>?</urn:xml>
                  <!--Optional:-->
                  <urn:reference validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?">
                     <!--Optional:-->
                     <urn:useablePeriod validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?">
                        <!--Optional:-->
                        <urn:originalText validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?" mediaType="text/plain" charset="?" language="?" integrityCheckAlgorithm="?">
                           <!--Optional:-->
                           <urn:reference/>
                           <!--Optional:-->
                           <urn:description validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?" language="?">
                              <!--Zero or more repetitions:-->
                              <urn:translation validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?" language="?"/>
                           </urn:description>
                        </urn:originalText>
                     </urn:useablePeriod>
                  </urn:reference>
                  <!--Optional:-->
                  <urn:integrityCheck>cid:510012168340</urn:integrityCheck>
                  <!--Optional:-->
                  <urn:thumbnail/>
                  <!--Optional:-->
                  <urn:description validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?" language="?">
                     <!--Zero or more repetitions:-->
                     <urn:translation validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?" language="?"/>
                  </urn:description>
                  <!--Zero or more repetitions:-->
                  <urn:translation/>
               </urn:expression>
               <!--Optional:-->
               <urn:originalText validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?" mediaType="text/plain" charset="?" language="?" integrityCheckAlgorithm="?">
                  <!--Optional:-->
                  <urn:reference validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?">
                     <!--Optional:-->
                     <urn:useablePeriod validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?">
                        <!--Optional:-->
                        <urn:originalText/>
                     </urn:useablePeriod>
                  </urn:reference>
                  <!--Optional:-->
                  <urn:description validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?" language="?">
                     <!--Zero or more repetitions:-->
                     <urn:translation validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?" language="?"/>
                  </urn:description>
               </urn:originalText>
               <!--Optional:-->
               <urn:uncertainty/>
            </urn:uncertainty>
         </urn:max_records>
         <!--Zero or more repetitions:-->
         <urn:parameters>
            <!--Optional:-->
            <urn:code validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" code="?" codeSystem="?" codeSystemName="?" codeSystemVersion="?" valueSet="?" valueSetVersion="?" codingRationale="?" id="?">
               <!--Optional:-->
               <urn:displayName validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?" language="?">
                  <!--Zero or more repetitions:-->
                  <urn:translation validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?" language="?"/>
               </urn:displayName>
               <!--Optional:-->
               <urn:originalText validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?" mediaType="text/plain" charset="?" language="?" integrityCheckAlgorithm="?">
                  <!--Optional:-->
                  <urn:reference validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?">
                     <!--Optional:-->
                     <urn:useablePeriod validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?">
                        <!--Optional:-->
                        <urn:originalText/>
                     </urn:useablePeriod>
                  </urn:reference>
                  <!--Optional:-->
                  <urn:description validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?" language="?">
                     <!--Zero or more repetitions:-->
                     <urn:translation validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?" language="?"/>
                  </urn:description>
               </urn:originalText>
               <!--Zero or more repetitions:-->
               <urn:translation/>
               <!--Optional:-->
               <urn:source xref="?"/>
            </urn:code>
            <urn:name validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?" language="?">
               <!--Zero or more repetitions:-->
               <urn:translation validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?" language="?"/>
            </urn:name>
            <urn:value validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?" language="?">
               <!--Zero or more repetitions:-->
               <urn:translation validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?" language="?"/>
            </urn:value>
         </urn:parameters>
      </urn:RIV13606REQUEST_EHR_EXTRACT_request>
   </soapenv:Body>
</soapenv:Envelope>]]></con:request><con:credentials><con:authType>Global HTTP Settings</con:authType></con:credentials><con:jmsConfig JMSDeliveryMode="PERSISTENT"/><con:jmsPropertyConfig/><con:wsaConfig mustUnderstand="NONE" version="200508" action="urn:riv13606:v1.1:RIV13606REQUEST_EHR_EXTRACT"/><con:wsrmConfig version="1.2"/></con:call></con:operation><con:operation isOneWay="false" action="urn:riv13606:v1.1:RIV13606REQUEST_EHR_EXTRACT_CONTINUATION" name="RIV13606REQUEST_EHR_EXTRACT_CONTINUATION" bindingOperationName="RIV13606REQUEST_EHR_EXTRACT_CONTINUATION" type="Request-Response" inputName="" receivesAttachments="false" sendsAttachments="false" anonymous="optional"><con:settings/><con:call name="Request 1"><con:settings/><con:encoding>UTF-8</con:encoding><con:endpoint>http://localhost:11000/npoadapter/ehrextract/v11</con:endpoint><con:request><![CDATA[<soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/" xmlns:urn="urn:riv13606:v1.1">
   <soapenv:Header/>
   <soapenv:Body>
      <urn:RIV13606REQUEST_EHR_EXTRACT_CONTINUATION_request>
         <!--Optional:-->
         <urn:max_records validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" uncertaintyType="?" value="?">
            <!--Optional:-->
            <urn:expression validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?" mediaType="text/plain" charset="?" language="?" compression="?" integrityCheckAlgorithm="?">
               <!--Optional:-->
               <urn:data>cid:221726699686</urn:data>
               <!--Optional:-->
               <urn:xml>?</urn:xml>
               <!--Optional:-->
               <urn:reference validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?">
                  <!--Optional:-->
                  <urn:useablePeriod validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?">
                     <!--Optional:-->
                     <urn:originalText validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?" mediaType="text/plain" charset="?" language="?" integrityCheckAlgorithm="?">
                        <!--Optional:-->
                        <urn:reference/>
                        <!--Optional:-->
                        <urn:description validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?" language="?">
                           <!--Zero or more repetitions:-->
                           <urn:translation validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?" language="?"/>
                        </urn:description>
                     </urn:originalText>
                  </urn:useablePeriod>
               </urn:reference>
               <!--Optional:-->
               <urn:integrityCheck>cid:1280353344359</urn:integrityCheck>
               <!--Optional:-->
               <urn:thumbnail/>
               <!--Optional:-->
               <urn:description validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?" language="?">
                  <!--Zero or more repetitions:-->
                  <urn:translation validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?" language="?"/>
               </urn:description>
               <!--Zero or more repetitions:-->
               <urn:translation/>
            </urn:expression>
            <!--Optional:-->
            <urn:originalText validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?" mediaType="text/plain" charset="?" language="?" integrityCheckAlgorithm="?">
               <!--Optional:-->
               <urn:reference validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?">
                  <!--Optional:-->
                  <urn:useablePeriod validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?">
                     <!--Optional:-->
                     <urn:originalText/>
                  </urn:useablePeriod>
               </urn:reference>
               <!--Optional:-->
               <urn:description validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?" language="?">
                  <!--Zero or more repetitions:-->
                  <urn:translation validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?" language="?"/>
               </urn:description>
            </urn:originalText>
            <!--Optional:-->
            <urn:uncertainty validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" uncertaintyType="?">
               <!--Optional:-->
               <urn:expression validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?" mediaType="text/plain" charset="?" language="?" compression="?" integrityCheckAlgorithm="?">
                  <!--Optional:-->
                  <urn:data>cid:383096881474</urn:data>
                  <!--Optional:-->
                  <urn:xml>?</urn:xml>
                  <!--Optional:-->
                  <urn:reference validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?">
                     <!--Optional:-->
                     <urn:useablePeriod validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?">
                        <!--Optional:-->
                        <urn:originalText validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?" mediaType="text/plain" charset="?" language="?" integrityCheckAlgorithm="?">
                           <!--Optional:-->
                           <urn:reference/>
                           <!--Optional:-->
                           <urn:description validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?" language="?">
                              <!--Zero or more repetitions:-->
                              <urn:translation validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?" language="?"/>
                           </urn:description>
                        </urn:originalText>
                     </urn:useablePeriod>
                  </urn:reference>
                  <!--Optional:-->
                  <urn:integrityCheck>cid:301984690411</urn:integrityCheck>
                  <!--Optional:-->
                  <urn:thumbnail/>
                  <!--Optional:-->
                  <urn:description validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?" language="?">
                     <!--Zero or more repetitions:-->
                     <urn:translation validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?" language="?"/>
                  </urn:description>
                  <!--Zero or more repetitions:-->
                  <urn:translation/>
               </urn:expression>
               <!--Optional:-->
               <urn:originalText validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?" mediaType="text/plain" charset="?" language="?" integrityCheckAlgorithm="?">
                  <!--Optional:-->
                  <urn:reference validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?">
                     <!--Optional:-->
                     <urn:useablePeriod validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?">
                        <!--Optional:-->
                        <urn:originalText/>
                     </urn:useablePeriod>
                  </urn:reference>
                  <!--Optional:-->
                  <urn:description validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?" language="?">
                     <!--Zero or more repetitions:-->
                     <urn:translation validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?" language="?"/>
                  </urn:description>
               </urn:originalText>
               <!--Optional:-->
               <urn:uncertainty/>
            </urn:uncertainty>
         </urn:max_records>
         <!--Optional:-->
         <urn:start_record validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" uncertaintyType="?" value="?">
            <!--Optional:-->
            <urn:expression validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?" mediaType="text/plain" charset="?" language="?" compression="?" integrityCheckAlgorithm="?">
               <!--Optional:-->
               <urn:data>cid:1314955213182</urn:data>
               <!--Optional:-->
               <urn:xml>?</urn:xml>
               <!--Optional:-->
               <urn:reference validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?">
                  <!--Optional:-->
                  <urn:useablePeriod validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?">
                     <!--Optional:-->
                     <urn:originalText validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?" mediaType="text/plain" charset="?" language="?" integrityCheckAlgorithm="?">
                        <!--Optional:-->
                        <urn:reference/>
                        <!--Optional:-->
                        <urn:description validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?" language="?">
                           <!--Zero or more repetitions:-->
                           <urn:translation validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?" language="?"/>
                        </urn:description>
                     </urn:originalText>
                  </urn:useablePeriod>
               </urn:reference>
               <!--Optional:-->
               <urn:integrityCheck>cid:1334441939052</urn:integrityCheck>
               <!--Optional:-->
               <urn:thumbnail/>
               <!--Optional:-->
               <urn:description validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?" language="?">
                  <!--Zero or more repetitions:-->
                  <urn:translation validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?" language="?"/>
               </urn:description>
               <!--Zero or more repetitions:-->
               <urn:translation/>
            </urn:expression>
            <!--Optional:-->
            <urn:originalText validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?" mediaType="text/plain" charset="?" language="?" integrityCheckAlgorithm="?">
               <!--Optional:-->
               <urn:reference validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?">
                  <!--Optional:-->
                  <urn:useablePeriod validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?">
                     <!--Optional:-->
                     <urn:originalText/>
                  </urn:useablePeriod>
               </urn:reference>
               <!--Optional:-->
               <urn:description validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?" language="?">
                  <!--Zero or more repetitions:-->
                  <urn:translation validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?" language="?"/>
               </urn:description>
            </urn:originalText>
            <!--Optional:-->
            <urn:uncertainty validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" uncertaintyType="?">
               <!--Optional:-->
               <urn:expression validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?" mediaType="text/plain" charset="?" language="?" compression="?" integrityCheckAlgorithm="?">
                  <!--Optional:-->
                  <urn:data>cid:410839338870</urn:data>
                  <!--Optional:-->
                  <urn:xml>?</urn:xml>
                  <!--Optional:-->
                  <urn:reference validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?">
                     <!--Optional:-->
                     <urn:useablePeriod validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?">
                        <!--Optional:-->
                        <urn:originalText validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?" mediaType="text/plain" charset="?" language="?" integrityCheckAlgorithm="?">
                           <!--Optional:-->
                           <urn:reference/>
                           <!--Optional:-->
                           <urn:description validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?" language="?">
                              <!--Zero or more repetitions:-->
                              <urn:translation validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?" language="?"/>
                           </urn:description>
                        </urn:originalText>
                     </urn:useablePeriod>
                  </urn:reference>
                  <!--Optional:-->
                  <urn:integrityCheck>cid:1144034461742</urn:integrityCheck>
                  <!--Optional:-->
                  <urn:thumbnail/>
                  <!--Optional:-->
                  <urn:description validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?" language="?">
                     <!--Zero or more repetitions:-->
                     <urn:translation validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?" language="?"/>
                  </urn:description>
                  <!--Zero or more repetitions:-->
                  <urn:translation/>
               </urn:expression>
               <!--Optional:-->
               <urn:originalText validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?" mediaType="text/plain" charset="?" language="?" integrityCheckAlgorithm="?">
                  <!--Optional:-->
                  <urn:reference validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?">
                     <!--Optional:-->
                     <urn:useablePeriod validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?">
                        <!--Optional:-->
                        <urn:originalText/>
                     </urn:useablePeriod>
                  </urn:reference>
                  <!--Optional:-->
                  <urn:description validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?" language="?">
                     <!--Zero or more repetitions:-->
                     <urn:translation validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?" language="?"/>
                  </urn:description>
               </urn:originalText>
               <!--Optional:-->
               <urn:uncertainty/>
            </urn:uncertainty>
         </urn:start_record>
         <urn:continuation_token validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?" language="?">
            <!--Zero or more repetitions:-->
            <urn:translation validTimeLow="?" validTimeHigh="?" controlActRoot="?" controlActExtension="?" nullFlavor="?" flavorId="?" updateMode="?" value="?" language="?"/>
         </urn:continuation_token>
      </urn:RIV13606REQUEST_EHR_EXTRACT_CONTINUATION_request>
   </soapenv:Body>
</soapenv:Envelope>]]></con:request><con:credentials><con:authType>Global HTTP Settings</con:authType></con:credentials><con:jmsConfig JMSDeliveryMode="PERSISTENT"/><con:jmsPropertyConfig/><con:wsaConfig mustUnderstand="NONE" version="200508" action="urn:riv13606:v1.1:RIV13606REQUEST_EHR_EXTRACT_CONTINUATION"/><con:wsrmConfig version="1.2"/></con:call></con:operation></con:interface><con:interface xsi:type="con:WsdlInterface" wsaVersion="NONE" name="SokVagvalsServiceSoap11LitDocServiceSoapBinding" type="wsdl" bindingName="{urn:skl:tp:vagvalsinfo:v2}SokVagvalsServiceSoap11LitDocServiceSoapBinding" soapVersion="1_1" anonymous="optional" definition="http://localhost:11000/npoadapter/tak/stub?wsdl" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"><con:settings/><con:definitionCache type="TEXT" rootPart="http://localhost:11000/npoadapter/tak/stub?wsdl"><con:part><con:url>http://localhost:11000/npoadapter/tak/stub?wsdl</con:url><con:content><![CDATA[<wsdl:definitions name="SokVagvalsServiceSoap11LitDocService" targetNamespace="urn:skl:tp:vagvalsinfo:v2" xmlns:ns1="http://schemas.xmlsoap.org/soap/http" xmlns:soap="http://schemas.xmlsoap.org/wsdl/soap/" xmlns:tns="urn:skl:tp:vagvalsinfo:v2" xmlns:wsdl="http://schemas.xmlsoap.org/wsdl/" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <wsdl:types>
    <xs:schema attributeFormDefault="unqualified" elementFormDefault="qualified" targetNamespace="urn:skl:tp:vagvalsinfo:v2" xmlns:xs="http://www.w3.org/2001/XMLSchema">
      <xs:element name="virtualiseringsInfo" type="tns:virtualiseringsInfoType"/>
      <xs:complexType name="hamtaAllaAnropsBehorigheterResponseType">
        <xs:sequence>
          <xs:element maxOccurs="unbounded" name="anropsBehorighetsInfo" type="tns:anropsBehorighetsInfoType"/>
        </xs:sequence>
      </xs:complexType>
      <xs:complexType name="anropsBehorighetsInfoType">
        <xs:sequence>
          <xs:element name="anropsBehorighetsInfoId" type="tns:anropsBehorighetsInfoIdType"/>
          <xs:element name="receiverId" type="xs:string"/>
          <xs:element name="senderId" type="xs:string"/>
          <xs:element name="tjansteKontrakt" type="xs:NCName"/>
          <xs:element name="fromTidpunkt" type="xs:dateTime"/>
          <xs:element name="tomTidpunkt" type="xs:dateTime"/>
          <xs:element maxOccurs="unbounded" minOccurs="0" name="filterInfo" nillable="true" type="tns:filterInfoType"/>
          <xs:any maxOccurs="unbounded" minOccurs="0" serviceNamespace="##other" processContents="lax"/>
        </xs:sequence>
      </xs:complexType>
      <xs:simpleType name="anropsBehorighetsInfoIdType">
        <xs:restriction base="xs:string"/>
      </xs:simpleType>
      <xs:complexType name="filterInfoType">
        <xs:sequence>
          <xs:element name="serviceDomain" type="xs:anyURI"/>
          <xs:element maxOccurs="unbounded" minOccurs="0" name="categorization" nillable="true" type="xs:string"/>
          <xs:any maxOccurs="unbounded" minOccurs="0" serviceNamespace="##other" processContents="lax"/>
        </xs:sequence>
      </xs:complexType>
      <xs:complexType name="virtualiseringsInfoType">
        <xs:sequence>
          <xs:element name="virtualiseringsInfoId" type="tns:virtualiseringsInfoIdType"/>
          <xs:element name="receiverId" type="xs:string"/>
          <xs:element name="rivProfil" type="xs:NCName"/>
          <xs:element name="tjansteKontrakt" type="xs:NCName"/>
          <xs:element name="fromTidpunkt" type="xs:dateTime"/>
          <xs:element name="tomTidpunkt" type="xs:dateTime"/>
          <xs:element name="adress" type="xs:string"/>
          <xs:any maxOccurs="unbounded" minOccurs="0" serviceNamespace="##other" processContents="lax"/>
        </xs:sequence>
      </xs:complexType>
      <xs:simpleType name="virtualiseringsInfoIdType">
        <xs:restriction base="xs:string"/>
      </xs:simpleType>
      <xs:complexType name="hamtaAllaVirtualiseringarResponseType">
        <xs:sequence>
          <xs:element maxOccurs="unbounded" minOccurs="0" name="virtualiseringsInfo" nillable="true" type="tns:virtualiseringsInfoType"/>
        </xs:sequence>
      </xs:complexType>
      <xs:element name="hamtaAllaAnropsBehorigheter" nillable="true" type="xs:anyType"/>
      <xs:element name="hamtaAllaAnropsBehorigheterResponse" nillable="true" type="tns:hamtaAllaAnropsBehorigheterResponseType"/>
      <xs:element name="hamtaAllaVirtualiseringar" nillable="true" type="xs:anyType"/>
      <xs:element name="hamtaAllaVirtualiseringarResponse" nillable="true" type="tns:hamtaAllaVirtualiseringarResponseType"/>
    </xs:schema>
  </wsdl:types>
  <wsdl:message name="hamtaAllaAnropsBehorigheterResponse">
    <wsdl:part element="tns:hamtaAllaAnropsBehorigheterResponse" name="response"></wsdl:part>
  </wsdl:message>
  <wsdl:message name="hamtaAllaVirtualiseringarResponse">
    <wsdl:part element="tns:hamtaAllaVirtualiseringarResponse" name="response"></wsdl:part>
  </wsdl:message>
  <wsdl:message name="hamtaAllaVirtualiseringar">
    <wsdl:part element="tns:hamtaAllaVirtualiseringar" name="parameters"></wsdl:part>
  </wsdl:message>
  <wsdl:message name="hamtaAllaAnropsBehorigheter">
    <wsdl:part element="tns:hamtaAllaAnropsBehorigheter" name="parameters"></wsdl:part>
  </wsdl:message>
  <wsdl:portType name="SokVagvalsInfoInterface">
    <wsdl:operation name="hamtaAllaAnropsBehorigheter">
      <wsdl:input message="tns:hamtaAllaAnropsBehorigheter" name="hamtaAllaAnropsBehorigheter"></wsdl:input>
      <wsdl:output message="tns:hamtaAllaAnropsBehorigheterResponse" name="hamtaAllaAnropsBehorigheterResponse"></wsdl:output>
    </wsdl:operation>
    <wsdl:operation name="hamtaAllaVirtualiseringar">
      <wsdl:input message="tns:hamtaAllaVirtualiseringar" name="hamtaAllaVirtualiseringar"></wsdl:input>
      <wsdl:output message="tns:hamtaAllaVirtualiseringarResponse" name="hamtaAllaVirtualiseringarResponse"></wsdl:output>
    </wsdl:operation>
  </wsdl:portType>
  <wsdl:binding name="SokVagvalsServiceSoap11LitDocServiceSoapBinding" type="tns:SokVagvalsInfoInterface">
    <soap:binding style="document" transport="http://schemas.xmlsoap.org/soap/http"/>
    <wsdl:operation name="hamtaAllaAnropsBehorigheter">
      <soap:operation soapAction="" style="document"/>
      <wsdl:input name="hamtaAllaAnropsBehorigheter">
        <soap:body use="literal"/>
      </wsdl:input>
      <wsdl:output name="hamtaAllaAnropsBehorigheterResponse">
        <soap:body use="literal"/>
      </wsdl:output>
    </wsdl:operation>
    <wsdl:operation name="hamtaAllaVirtualiseringar">
      <soap:operation soapAction="" style="document"/>
      <wsdl:input name="hamtaAllaVirtualiseringar">
        <soap:body use="literal"/>
      </wsdl:input>
      <wsdl:output name="hamtaAllaVirtualiseringarResponse">
        <soap:body use="literal"/>
      </wsdl:output>
    </wsdl:operation>
  </wsdl:binding>
  <wsdl:service name="SokVagvalsServiceSoap11LitDocService">
    <wsdl:port binding="tns:SokVagvalsServiceSoap11LitDocServiceSoapBinding" name="SokVagvalsSoap11LitDocPort">
      <soap:address location="http://localhost:11000/npoadapter/tak/stub"/>
    </wsdl:port>
  </wsdl:service>
</wsdl:definitions>]]></con:content><con:type>http://schemas.xmlsoap.org/wsdl/</con:type></con:part></con:definitionCache><con:endpoints><con:endpoint>http://localhost:11000/npoadapter/tak/stub</con:endpoint></con:endpoints><con:operation isOneWay="false" action="" name="hamtaAllaAnropsBehorigheter" bindingOperationName="hamtaAllaAnropsBehorigheter" type="Request-Response" outputName="hamtaAllaAnropsBehorigheterResponse" inputName="hamtaAllaAnropsBehorigheter" receivesAttachments="false" sendsAttachments="false" anonymous="optional"><con:settings/><con:call name="Request 1"><con:settings/><con:encoding>UTF-8</con:encoding><con:endpoint>http://localhost:11000/npoadapter/tak/stub</con:endpoint><con:request><![CDATA[<soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/" xmlns:urn="urn:skl:tp:vagvalsinfo:v2">
   <soapenv:Header/>
   <soapenv:Body>
      <urn:hamtaAllaAnropsBehorigheter>?</urn:hamtaAllaAnropsBehorigheter>
   </soapenv:Body>
</soapenv:Envelope>]]></con:request><con:wsaConfig mustUnderstand="NONE" version="200508" action="urn:skl:tp:vagvalsinfo:v2/SokVagvalsInfoInterface/hamtaAllaAnropsBehorigheter"/></con:call></con:operation><con:operation isOneWay="false" action="" name="hamtaAllaVirtualiseringar" bindingOperationName="hamtaAllaVirtualiseringar" type="Request-Response" outputName="hamtaAllaVirtualiseringarResponse" inputName="hamtaAllaVirtualiseringar" receivesAttachments="false" sendsAttachments="false" anonymous="optional"><con:settings/><con:call name="Request 1"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;xml-fragment/></con:setting></con:settings><con:encoding>UTF-8</con:encoding><con:endpoint>http://localhost:11000/npoadapter/tak/stub</con:endpoint><con:request><![CDATA[<soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/" xmlns:urn="urn:skl:tp:vagvalsinfo:v2">
   <soapenv:Header/>
   <soapenv:Body>
      <urn:hamtaAllaVirtualiseringar>?</urn:hamtaAllaVirtualiseringar>
   </soapenv:Body>
</soapenv:Envelope>]]></con:request><con:credentials><con:authType>Global HTTP Settings</con:authType></con:credentials><con:jmsConfig JMSDeliveryMode="PERSISTENT"/><con:jmsPropertyConfig/><con:wsaConfig mustUnderstand="NONE" version="200508" action="urn:skl:tp:vagvalsinfo:v2/SokVagvalsInfoInterface/hamtaAllaVirtualiseringar"/><con:wsrmConfig version="1.2"/></con:call></con:operation></con:interface><con:interface xsi:type="con:WsdlInterface" wsaVersion="NONE" name="GetCareContactsResponderBinding" type="wsdl" bindingName="{urn:riv:clinicalprocess:logistics:logistics:GetCareContacts:2:rivtabp21}GetCareContactsResponderBinding" soapVersion="1_1" anonymous="optional" definition="http://localhost:11000/npoadapter/getcarecontacts?wsdl" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"><con:settings/><con:definitionCache type="TEXT" rootPart="http://localhost:11000/npoadapter/getcarecontacts?wsdl"><con:part><con:url>http://localhost:11000/npoadapter/getcarecontacts?wsdl</con:url><con:content><![CDATA[<wsdl:definitions name="GetCareContactsInteraction" targetNamespace="urn:riv:clinicalprocess:logistics:logistics:GetCareContacts:2:rivtabp21" xmlns:itr="urn:riv:itintegration:registry:1" xmlns:soap="http://schemas.xmlsoap.org/wsdl/soap/" xmlns:tjsi="urn:riv:clinicalprocess:logistics:logistics:GetCareContactsInitiator:2" xmlns:tjsr="urn:riv:clinicalprocess:logistics:logistics:GetCareContactsResponder:2" xmlns:tns="urn:riv:clinicalprocess:logistics:logistics:GetCareContacts:2:rivtabp21" xmlns:wsdl="http://schemas.xmlsoap.org/wsdl/" xmlns:xs="http://www.w3.org/2001/XMLSchema">
  <wsdl:types>
    <xs:schema targetNamespace="urn:riv:clinicalprocess:logistics:logistics:GetCareContacts:2:rivtabp21">
      <xs:import serviceNamespace="urn:riv:clinicalprocess:logistics:logistics:GetCareContactsResponder:2" schemaLocation="http://localhost:11000/npoadapter/getcarecontacts?xsd=GetCareContactsResponder_2.0.xsd"/>
      <xs:import serviceNamespace="urn:riv:itintegration:registry:1" schemaLocation="http://localhost:11000/npoadapter/getcarecontacts?xsd=../../core_components/itintegration_registry_1.0.xsd"/>
    </xs:schema>
  </wsdl:types>
  <wsdl:message name="GetCareContactsRequest">
    <wsdl:part element="itr:LogicalAddress" name="LogicalAddress">
      <wsdl:documentation>National: The HSA-id of Inera AB ("national" aggregation service)
			Regional: The HSA-id of Inera AB (regional aggregation service)
			Specific Source system: The HSA-id of the source system</wsdl:documentation>
    </wsdl:part>
    <wsdl:part element="tjsr:GetCareContacts" name="parameters"></wsdl:part>
  </wsdl:message>
  <wsdl:message name="GetCareContactsResponse">
    <wsdl:part element="tjsr:GetCareContactsResponse" name="parameters"></wsdl:part>
  </wsdl:message>
  <wsdl:portType name="GetCareContactsResponderInterface">
    <wsdl:operation name="GetCareContacts">
      <wsdl:input message="tns:GetCareContactsRequest"></wsdl:input>
      <wsdl:output message="tns:GetCareContactsResponse"></wsdl:output>
    </wsdl:operation>
  </wsdl:portType>
  <wsdl:binding name="GetCareContactsResponderBinding" type="tns:GetCareContactsResponderInterface">
    <soap:binding style="document" transport="http://schemas.xmlsoap.org/soap/http"/>
    <wsdl:operation name="GetCareContacts">
      <soap:operation soapAction="urn:riv:ehr:patientsummary:GetCareContactsResponder:2:GetCareContacts" style="document"/>
      <wsdl:input>
        <soap:header message="tns:GetCareContactsRequest" part="LogicalAddress" use="literal"></soap:header>
        <soap:body parts="parameters" use="literal"/>
      </wsdl:input>
      <wsdl:output>
        <soap:body use="literal"/>
      </wsdl:output>
    </wsdl:operation>
  </wsdl:binding>
  <wsdl:service name="GetCareContactsResponderService">
    <wsdl:port binding="tns:GetCareContactsResponderBinding" name="GetCareContactsResponderPort">
      <soap:address location="http://localhost:11000/npoadapter/getcarecontacts"/>
    </wsdl:port>
  </wsdl:service>
  <xs:annotation>
    <xs:documentation>Tjänsteinteraktionens namn: GetCareContactsInteraction
			 Beskrivning: 
			   Care encounters for a subject of care
			 Revisioner: 
			 Tjänstedomän: clinicalprocess:logistics:logistics
			 Tjänsteinteraktionstyp: Fråga-Svar
			 WS-profil: RIVTABP21
			 Förvaltas av: Sveriges Kommuner och Landsting</xs:documentation>
  </xs:annotation>
</wsdl:definitions>]]></con:content><con:type>http://schemas.xmlsoap.org/wsdl/</con:type></con:part><con:part><con:url>http://localhost:11000/npoadapter/getcarecontacts?xsd=GetCareContactsResponder_2.0.xsd</con:url><con:content><![CDATA[<!--Licensed to the Apache Software Foundation (ASF) under one
 or more contributor license agreements. See the NOTICE file
 distributed with this work for additional information
 regarding copyright ownership. Sveriges Kommuner och Landsting licenses this file
 to you under the Apache License, Version 2.0 (the
 "License"); you may not use this file except in compliance
 with the License. You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing,
 software distributed under the License is distributed on an
 "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 KIND, either express or implied. See the License for the
 specific language governing permissions and limitations
 under the License.-->
<xs:schema attributeFormDefault="unqualified" elementFormDefault="qualified" targetNamespace="urn:riv:clinicalprocess:logistics:logistics:GetCareContactsResponder:2" version="2.0" xmlns:codes="urn:riv:clinicalprocess:logistics:logistics:enums:2" xmlns:core="urn:riv:clinicalprocess:logistics:logistics:2" xmlns:tns="urn:riv:clinicalprocess:logistics:logistics:GetCareContactsResponder:2" xmlns:xs="http://www.w3.org/2001/XMLSchema">
  <xs:import serviceNamespace="urn:riv:clinicalprocess:logistics:logistics:2" schemaLocation="http://localhost:11000/npoadapter/getcarecontacts?xsd=../../core_components/clinicalprocess_logistics_logistics_2.0.xsd"/>
  <xs:import serviceNamespace="urn:riv:clinicalprocess:logistics:logistics:enums:2" schemaLocation="http://localhost:11000/npoadapter/getcarecontacts?xsd=../../core_components/clinicalprocess_logistics_logistics_enum_2.0.xsd"/>
  <xs:element name="GetCareContacts" type="tns:GetCareContactsType"/>
  <xs:element name="GetCareContactsResponse" type="tns:GetCareContactsResponseType"/>
  <xs:complexType name="GetCareContactsType">
    <xs:sequence>
      <xs:element maxOccurs="unbounded" minOccurs="0" name="careUnitHSAId" type="core:HSAIdType"/>
      <xs:element name="patientId" type="core:PersonIdType"/>
      <xs:element minOccurs="0" name="timePeriod" type="core:DatePeriodType"/>
      <xs:element minOccurs="0" name="sourceSystemHSAId" type="core:HSAIdType"/>
      <xs:element maxOccurs="unbounded" minOccurs="0" name="careContactId" type="xs:string"/>
      <xs:any maxOccurs="unbounded" minOccurs="0" serviceNamespace="##other" processContents="lax"/>
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="GetCareContactsResponseType">
    <xs:sequence>
      <xs:element maxOccurs="unbounded" minOccurs="0" name="careContact" type="core:CareContactType"/>
      <xs:any maxOccurs="unbounded" minOccurs="0" serviceNamespace="##other" processContents="lax"/>
    </xs:sequence>
  </xs:complexType>
</xs:schema>]]></con:content><con:type>http://www.w3.org/2001/XMLSchema</con:type></con:part><con:part><con:url>http://localhost:11000/npoadapter/getcarecontacts?xsd=../../core_components/clinicalprocess_logistics_logistics_2.0.xsd</con:url><con:content><![CDATA[<!--Licensed to the Apache Software Foundation (ASF) under one
 or more contributor license agreements. See the NOTICE file
 distributed with this work for additional information
 regarding copyright ownership. Sveriges Kommuner och Landsting licenses this file
 to you under the Apache License, Version 2.0 (the
 "License"); you may not use this file except in compliance
 with the License. You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing,
 software distributed under the License is distributed on an
 "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 KIND, either express or implied. See the License for the
 specific language governing permissions and limitations
 under the License.-->
<xs:schema attributeFormDefault="unqualified" elementFormDefault="qualified" targetNamespace="urn:riv:clinicalprocess:logistics:logistics:2" version="2.0" xmlns:codes="urn:riv:clinicalprocess:logistics:logistics:enums:2" xmlns:tns="urn:riv:clinicalprocess:logistics:logistics:2" xmlns:xs="http://www.w3.org/2001/XMLSchema">
  <xs:import serviceNamespace="urn:riv:clinicalprocess:logistics:logistics:enums:2" schemaLocation="http://localhost:11000/npoadapter/getcarecontacts?xsd=./clinicalprocess_logistics_logistics_enum_2.0.xsd"/>
  <xs:complexType name="CareContactType">
    <xs:sequence>
      <xs:element name="careContactHeader" type="tns:PatientSummaryHeaderType"/>
      <xs:element name="careContactBody" type="tns:CareContactBodyType"/>
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="CareContactBodyType">
    <xs:annotation>
      <xs:documentation>careContactCode:
                    Typ av vård- och omsorgsdokumentation. Nullvärde tillåtetet.
                careContactReason:
                    Text som beskriver orsaken till vård- och omsorgskontakt som 
                    vård- och omsorgstagaren själv eller dess företrädare anger.
                careContactOrgUnit:
                    Den enhet som kontakt utfördes vid
	            careContactTimePeriod:
	                    För besök sätts sluttidpunken till samma tid som anges som starttidpunkt.
						För planerade kontakter sätts ingen sluttidpunkt.
						Pågående vårdtillfälle ska anges på samma sätt som en planerad vårdkontakt, 
						dvs med angivet startdatum, men utan slutdatum.				
                careContactStatus:
                    Status på vårdkontakten enligt kodverk ur NPÖ RIV-spec 2.2.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element minOccurs="0" name="careContactCode" type="codes:CareContactCodeEnum"/>
      <xs:element minOccurs="0" name="careContactReason" type="xs:string"/>
      <xs:element name="careContactOrgUnit" type="tns:OrgUnitType"/>
      <xs:element name="careContactTimePeriod" type="tns:TimePeriodType"/>
      <xs:element maxOccurs="1" minOccurs="0" name="careContactStatus" type="codes:CareContactStatusEnum"/>
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="CareContactOrgUnitType">
    <xs:annotation>
      <xs:documentation>careContactOrgUnitId:
                    HSA-id på den person inom enheten som hade
                    kontakt med patienten
                careContactOrgUnitName:
                    Namne på enhet 
                careContactOrgUnitTelecom:
                    Telefon till organisationsenheten
                careContactOrgUnitEmail:
                    Epost till organisationsenheten
                careContactOrgUnitAddress:
                    Adress till enhet
	            careContactOrgUnitLocation:
	                Text som anger namnet på plats eller ort för organisationsenhetens eller funktionens fysiska placering</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="careContactOrgUnitId" type="tns:HSAIdType"/>
      <xs:element name="careContactOrgUnitName" type="xs:string"/>
      <xs:element minOccurs="0" name="careContactOrgUnitTelecom" type="xs:string"/>
      <xs:element minOccurs="0" name="careContactOrgUnitEmail" type="xs:string"/>
      <xs:element minOccurs="0" name="careContactOrgUnitAddress" type="xs:string"/>
      <xs:element minOccurs="0" name="careContactOrgUnitLocation" type="xs:string"/>
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="PatientSummaryHeaderType">
    <xs:annotation>
      <xs:documentation>careContactId: 
                    Vårdkontaktens identitet som är unik inom källsystemet
                sourceSystemHSAId:
                    HSAId för det system som dokumentet är skapat i.
                documentTime: 
                    Tid då vård- eller omsorgskontakten registrerades
                patientId: 
                    Patientens ID (enligt PatientIdType). 
					type sätts till OID för typ av identifierare. 
					För personnummer ska Skatteverkets personnummer (1.2.752.129.2.1.3.1).
					För samordningsnummer ska Skatteverkets samordningsnummer (1.2.752.129.2.1.3.3).
					För reservnummer används lokalt definierade reservnummet, exempelvis SLL reservnummer (1.2.752.97.3.1.3)

                accountableHealthcareProfessional
                    Hälso- och sjukvårdsperson som ansvarar för vårdkontakten.
				accountableHealthcareProfessionalOrgUnit
					Organisationsenhet för vård- och omsorgspersonens uppdrag i samband med vårdkontakten.
                approvedForPatient:
                    Anger om information får delas till patient. Värdet sätts i 
                    sådant fall till true, i annat fall till false.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="documentId" type="xs:string"/>
      <xs:element name="sourceSystemHSAId" type="tns:HSAIdType"/>
      <xs:element name="patientId" type="tns:PersonIdType"/>
      <xs:element minOccurs="0" name="accountableHealthcareProfessional" type="tns:HealthcareProfessionalType"/>
      <xs:element name="approvedForPatient" type="xs:boolean"/>
      <xs:element minOccurs="0" name="nullified" type="xs:boolean"/>
      <xs:element minOccurs="0" name="nullifiedReason" type="xs:string"/>
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="HealthcareProfessionalType">
    <xs:annotation>
      <xs:documentation>Information om hälso- och omsorgspesonal
			
				healthcareProfessionalHSAId: 
					HSA-id för vård- och omsorgspersonal 
				healthcareProfessionalName
					Namn på vård- och omsorgspersonal
				healthcareProfessionalRoleCode: 
					Information om personens befattning om annat kodverk än KV Befattning används. 
				healthcareProfessionalOrgUnit: 
					HSA-id för PDL-enhet som vård- och omsorgspersonen är uppdragstagare för
				healthcareProfessionalCareUnitHSAId: 
					HSA-id för vårdgivaren, som är vårdgivare för den enhet som författaren är uppdragstagare för</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="authorTime" type="tns:TimeStampType"/>
      <xs:element minOccurs="1" name="healthcareProfessionalHSAId" type="tns:HSAIdType"/>
      <xs:element minOccurs="1" name="healthcareProfessionalName" type="xs:string"/>
      <xs:element minOccurs="0" name="healthcareProfessionalRoleCode" type="tns:CVType"/>
      <xs:element minOccurs="1" name="healthcareProfessionalOrgUnit" type="tns:OrgUnitType"/>
      <xs:element minOccurs="0" name="healthcareProfessionalCareUnitHSAId" type="tns:HSAIdType"/>
      <xs:element minOccurs="0" name="healthcareProfessionalCareGiverHSAId" type="tns:HSAIdType"/>
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="OrgUnitType">
    <xs:annotation>
      <xs:documentation>Information om en organisationsenhet

				careContactOrgUnitHsaId: 
					HSA-id för organisationsenhet
				careContactOrgUnitName
					Namn på organisationsenhet
				careContactOrgUnitTelecom: 
					Telefon till organisationsenhet
				careContactOrgUnitEmail: 
					Epost till enhet
				careContactOrgUnitAddress: 
					Postadress till enhet
				careContactOrgUnitLocation: 
					Text som anger namnet på plats eller ort för enhetens eller funktionens fysiska placering</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element minOccurs="1" name="orgUnitHSAId" type="tns:HSAIdType"/>
      <xs:element minOccurs="1" name="orgUnitName" type="xs:string"/>
      <xs:element minOccurs="0" name="orgUnitTelecom" type="xs:string"/>
      <xs:element minOccurs="0" name="orgUnitEmail" type="xs:string"/>
      <xs:element minOccurs="0" name="orgUnitAddress" type="xs:string"/>
      <xs:element minOccurs="0" name="orgUnitLocation" type="xs:string"/>
    </xs:sequence>
  </xs:complexType>
  <!--Below: only helper types allowed.
        
        A helper type is a type used in one ore more of the domain schema common types.
        It can also be a type used in two or more service schemas.-->
  <xs:complexType name="DatePeriodType">
    <xs:annotation>
      <xs:documentation>Används för att specificera ett datumintervall
                med hjälp av start- och slutdatum.
                
                start: 
                    Startdatum på formatet ÅÅÅÅMMDD
                end: 
                    Slutdatum på formatet ÅÅÅÅMMDD</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="start" type="tns:DateType"/>
      <xs:element name="end" type="tns:DateType"/>
    </xs:sequence>
  </xs:complexType>
  <!--YYYYMMDD-->
  <xs:simpleType name="DateType">
    <xs:annotation>
      <xs:documentation/>
    </xs:annotation>
    <xs:restriction base="xs:string">
      <xs:pattern value="(19|20)\d\d(0[1-9]|1[012])(0[1-9]|[12][0-9]|3[01])"/>
    </xs:restriction>
  </xs:simpleType>
  <!--@TODO Should we have maxlength 64?-->
  <xs:simpleType name="HSAIdType">
    <xs:restriction base="xs:string"/>
  </xs:simpleType>
  <xs:complexType name="PersonIdType">
    <xs:sequence>
      <xs:element name="id" type="xs:string"/>
      <xs:element name="type" type="xs:string"/>
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="TimePeriodType">
    <xs:annotation>
      <xs:documentation>Används för att specificera ett datumintervall
                med hjälp av start- och slutdatum.
                
                start: 
                Startdatum på formatet YYYYMMDDhhmmss
                end: 
                Slutdatum på formatet YYYYMMDDhhmmss</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="start" type="tns:TimeStampType"/>
      <xs:element minOccurs="0" name="end" type="tns:TimeStampType"/>
    </xs:sequence>
  </xs:complexType>
  <xs:simpleType name="TimeStampType">
    <xs:annotation>
      <xs:documentation>A quantity specifying a point on the axis of natural time.
                A point in time is most often represented as a calendar
                expression.
                
                The time has the format YYYYMMDDhhmmss</xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:string">
      <xs:pattern value="(19|20)\d\d(0[1-9]|1[012])(0[1-9]|[12][0-9]|3[01])(0[0-9]|1[0-9]|2[0123])([0-5])([0-9])([0-5])([0-9])"/>
    </xs:restriction>
  </xs:simpleType>
  <xs:complexType name="CVType">
    <xs:annotation>
      <xs:documentation/>
    </xs:annotation>
    <xs:sequence>
      <xs:element minOccurs="0" name="code" type="xs:string"/>
      <xs:element minOccurs="0" name="codeSystem" type="xs:string"/>
      <xs:element minOccurs="0" name="codeSystemName" type="xs:string"/>
      <xs:element minOccurs="0" name="codeSystemVersion" type="xs:string"/>
      <xs:element minOccurs="0" name="displayName" type="xs:string"/>
      <xs:element minOccurs="0" name="originalText" type="xs:string"/>
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="LegalAuthenticatorType">
    <xs:annotation>
      <xs:documentation/>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="signatureTime" type="tns:TimeStampType"/>
      <xs:element minOccurs="0" name="legalAuthenticatorHSAId" type="tns:HSAIdType"/>
      <xs:element minOccurs="0" name="legalAuthenticatorName" type="xs:string"/>
    </xs:sequence>
  </xs:complexType>
</xs:schema>]]></con:content><con:type>http://www.w3.org/2001/XMLSchema</con:type></con:part><con:part><con:url>http://localhost:11000/npoadapter/getcarecontacts?xsd=./clinicalprocess_logistics_logistics_enum_2.0.xsd</con:url><con:content><![CDATA[<!--Licensed to the Apache Software Foundation (ASF) under one
 or more contributor license agreements. See the NOTICE file
 distributed with this work for additional information
 regarding copyright ownership. Sveriges Kommuner och Landsting licenses this file
 to you under the Apache License, Version 2.0 (the
 "License"); you may not use this file except in compliance
 with the License. You may obtain a copy of the License at
 
 http://www.apache.org/licenses/LICENSE-2.0
 
 Unless required by applicable law or agreed to in writing,
 software distributed under the License is distributed on an
 "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 KIND, either express or implied. See the License for the
 specific language governing permissions and limitations
 under the License.-->
<xs:schema attributeFormDefault="unqualified" elementFormDefault="qualified" targetNamespace="urn:riv:clinicalprocess:logistics:logistics:enums:2" version="2.0" xmlns:tns="urn:riv:clinicalprocess:logistics:logistics:enums:2" xmlns:xs="http://www.w3.org/2001/XMLSchema">
  <xs:simpleType name="CareContactCodeEnum">
    <xs:restriction base="xs:int">
      <xs:enumeration value="1">
        <xs:annotation>
          <xs:documentation>Besök</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="2">
        <xs:annotation>
          <xs:documentation>Telefon</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="3">
        <xs:annotation>
          <xs:documentation>Vårdtillfälle</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="4">
        <xs:annotation>
          <xs:documentation>Dagsjukvård</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="5">
        <xs:annotation>
          <xs:documentation>Annan</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="CareContactStatusEnum">
    <xs:restriction base="xs:int">
      <xs:enumeration value="1">
        <xs:annotation>
          <xs:documentation>Ej påbörjad</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="2">
        <xs:annotation>
          <xs:documentation>Inställd</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="3">
        <xs:annotation>
          <xs:documentation>Pågående</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="4">
        <xs:annotation>
          <xs:documentation>Avbruten</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="5">
        <xs:annotation>
          <xs:documentation>Avslutad</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>
</xs:schema>]]></con:content><con:type>http://www.w3.org/2001/XMLSchema</con:type></con:part><con:part><con:url>http://localhost:11000/npoadapter/getcarecontacts?xsd=../../core_components/clinicalprocess_logistics_logistics_enum_2.0.xsd</con:url><con:content><![CDATA[<!--Licensed to the Apache Software Foundation (ASF) under one
 or more contributor license agreements. See the NOTICE file
 distributed with this work for additional information
 regarding copyright ownership. Sveriges Kommuner och Landsting licenses this file
 to you under the Apache License, Version 2.0 (the
 "License"); you may not use this file except in compliance
 with the License. You may obtain a copy of the License at
 
 http://www.apache.org/licenses/LICENSE-2.0
 
 Unless required by applicable law or agreed to in writing,
 software distributed under the License is distributed on an
 "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 KIND, either express or implied. See the License for the
 specific language governing permissions and limitations
 under the License.-->
<xs:schema attributeFormDefault="unqualified" elementFormDefault="qualified" targetNamespace="urn:riv:clinicalprocess:logistics:logistics:enums:2" version="2.0" xmlns:tns="urn:riv:clinicalprocess:logistics:logistics:enums:2" xmlns:xs="http://www.w3.org/2001/XMLSchema">
  <xs:simpleType name="CareContactCodeEnum">
    <xs:restriction base="xs:int">
      <xs:enumeration value="1">
        <xs:annotation>
          <xs:documentation>Besök</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="2">
        <xs:annotation>
          <xs:documentation>Telefon</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="3">
        <xs:annotation>
          <xs:documentation>Vårdtillfälle</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="4">
        <xs:annotation>
          <xs:documentation>Dagsjukvård</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="5">
        <xs:annotation>
          <xs:documentation>Annan</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="CareContactStatusEnum">
    <xs:restriction base="xs:int">
      <xs:enumeration value="1">
        <xs:annotation>
          <xs:documentation>Ej påbörjad</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="2">
        <xs:annotation>
          <xs:documentation>Inställd</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="3">
        <xs:annotation>
          <xs:documentation>Pågående</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="4">
        <xs:annotation>
          <xs:documentation>Avbruten</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="5">
        <xs:annotation>
          <xs:documentation>Avslutad</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>
</xs:schema>]]></con:content><con:type>http://www.w3.org/2001/XMLSchema</con:type></con:part><con:part><con:url>http://localhost:11000/npoadapter/getcarecontacts?xsd=../../core_components/itintegration_registry_1.0.xsd</con:url><con:content><![CDATA[<xs:schema elementFormDefault="qualified" targetNamespace="urn:riv:itintegration:registry:1" version="1.0" xmlns="urn:riv:itintegration:registry:1" xmlns:xs="http://www.w3.org/2001/XMLSchema">
  <xs:annotation>
    <xs:documentation>Beskrivning: 	Grundläggande informationsobjekt för domänen itintegration:registry (adressering av tjänster)
			
			Revisionshistorik: 2011-06-27 Mats Ekhammar, Callista Enterprise AB
				Added ServiceContractType
			
			Datum:			2011-05-04
			Beskrivning:	Initial version
			Författare:		marcus.krantz@callistaenterprise.se</xs:documentation>
  </xs:annotation>
  <xs:element name="LogicalAddress" type="LogicalAddressType"/>
  <xs:element name="ServiceContract" type="ServiceContractType"/>
  <xs:simpleType name="LogicalAddressType">
    <xs:annotation>
      <xs:documentation>Defines the type for logical address according to national reference architecture.
				Superseeds wsa:To as type for logical address header in RIVTA 2.1.</xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:string"/>
  </xs:simpleType>
  <xs:complexType name="ServiceContractType">
    <xs:annotation>
      <xs:documentation>Type which describes a service contract. Used in interaction GetSupportedServiceContracts.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="ServiceContractNamespace" type="xs:anyURI"/>
      <xs:any maxOccurs="unbounded" minOccurs="0" serviceNamespace="##other" processContents="lax"/>
    </xs:sequence>
  </xs:complexType>
</xs:schema>]]></con:content><con:type>http://www.w3.org/2001/XMLSchema</con:type></con:part></con:definitionCache><con:endpoints><con:endpoint>http://localhost:11000/npoadapter/getcarecontacts</con:endpoint></con:endpoints><con:operation isOneWay="false" action="urn:riv:ehr:patientsummary:GetCareContactsResponder:2:GetCareContacts" name="GetCareContacts" bindingOperationName="GetCareContacts" type="Request-Response" inputName="" receivesAttachments="false" sendsAttachments="false" anonymous="optional"><con:settings/><con:call name="Request 1"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;xml-fragment/></con:setting></con:settings><con:encoding>UTF-8</con:encoding><con:endpoint>http://localhost:11000/npoadapter/getcarecontacts</con:endpoint><con:request><![CDATA[<soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/" xmlns:urn="urn:riv:itintegration:registry:1" xmlns:urn1="urn:riv:clinicalprocess:logistics:logistics:GetCareContactsResponder:2" xmlns:urn2="urn:riv:clinicalprocess:logistics:logistics:2">
   <soapenv:Header>
      <urn:LogicalAddress>VS-2</urn:LogicalAddress>
   </soapenv:Header>
   <soapenv:Body>
      <urn1:GetCareContacts>
         <!--Zero or more repetitions:-->
         <urn1:careUnitHSAId>?</urn1:careUnitHSAId>
         <urn1:patientId>
            <urn2:id>?</urn2:id>
            <urn2:type>?</urn2:type>
         </urn1:patientId>
         <!--Zero or more repetitions:-->
         <urn1:careContactId>?</urn1:careContactId>
         <!--You may enter ANY elements at this point-->
      </urn1:GetCareContacts>
   </soapenv:Body>
</soapenv:Envelope>]]></con:request><con:credentials><con:authType>Global HTTP Settings</con:authType></con:credentials><con:jmsConfig JMSDeliveryMode="PERSISTENT"/><con:jmsPropertyConfig/><con:wsaConfig mustUnderstand="NONE" version="200508" action="urn:riv:ehr:patientsummary:GetCareContactsResponder:2:GetCareContacts"/><con:wsrmConfig version="1.2"/></con:call></con:operation></con:interface><con:interface xsi:type="con:WsdlInterface" wsaVersion="NONE" name="GetEhrExtractResponderBinding" type="wsdl" bindingName="{urn:riv:ehr:patientsummary:GetEhrExtract:1:rivtabp21}GetEhrExtractResponderBinding" soapVersion="1_1" anonymous="optional" definition="http://localhost:11000/npoadapter/getehrextract/stub?wsdl" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"><con:settings/><con:definitionCache type="TEXT" rootPart="http://localhost:11000/npoadapter/getehrextract/stub?wsdl"><con:part><con:url>http://localhost:11000/npoadapter/getehrextract/stub?wsdl</con:url><con:content><![CDATA[<wsdl:definitions name="GetEhrExtractInteraction" targetNamespace="urn:riv:ehr:patientsummary:GetEhrExtract:1:rivtabp21" xmlns:itr="urn:riv:itintegration:registry:1" xmlns:soap="http://schemas.xmlsoap.org/wsdl/soap/" xmlns:tjsi="urn:riv:ehr:patientsummary:GetEhrExtractInitiator:1" xmlns:tjsr="urn:riv:ehr:patientsummary:GetEhrExtractResponder:1" xmlns:tns="urn:riv:ehr:patientsummary:GetEhrExtract:1:rivtabp21" xmlns:wsdl="http://schemas.xmlsoap.org/wsdl/" xmlns:xs="http://www.w3.org/2001/XMLSchema">
  <wsdl:types>
    <xs:schema targetNamespace="urn:riv:ehr:patientsummary:GetEhrExtract:1:rivtabp21">
      <xs:import namespace="urn:riv:ehr:patientsummary:GetEhrExtractResponder:1" schemaLocation="http://localhost:11000/npoadapter/getehrextract/stub?xsd=GetEhrExtractResponder_0.99.xsd"/>
      <xs:import namespace="urn:riv:itintegration:registry:1" schemaLocation="http://localhost:11000/npoadapter/getehrextract/stub?xsd=../../core_components/itintegration_registry_1.0.xsd"/>
    </xs:schema>
  </wsdl:types>
  <wsdl:message name="GetEhrExtractResponse">
    <wsdl:part element="tjsr:GetEhrExtractResponse" name="parameters"></wsdl:part>
  </wsdl:message>
  <wsdl:message name="GetEhrExtractRequest">
    <wsdl:part element="itr:LogicalAddress" name="LogicalAddress">
      <wsdl:documentation>the HSA-id of the service producer</wsdl:documentation>
    </wsdl:part>
    <wsdl:part element="tjsr:GetEhrExtract" name="parameters"></wsdl:part>
  </wsdl:message>
  <wsdl:portType name="GetEhrExtractResponderInterface">
    <wsdl:operation name="GetEhrExtract">
      <wsdl:input message="tns:GetEhrExtractRequest"></wsdl:input>
      <wsdl:output message="tns:GetEhrExtractResponse"></wsdl:output>
    </wsdl:operation>
  </wsdl:portType>
  <wsdl:binding name="GetEhrExtractResponderBinding" type="tns:GetEhrExtractResponderInterface">
    <soap:binding style="document" transport="http://schemas.xmlsoap.org/soap/http"/>
    <wsdl:operation name="GetEhrExtract">
      <soap:operation soapAction="urn:riv:ehr:patientsummary:GetEhrExtractResponder:1:GetEhrExtract" style="document"/>
      <wsdl:input>
        <soap:header message="tns:GetEhrExtractRequest" part="LogicalAddress" use="literal"></soap:header>
        <soap:body parts="parameters" use="literal"/>
      </wsdl:input>
      <wsdl:output>
        <soap:body use="literal"/>
      </wsdl:output>
    </wsdl:operation>
  </wsdl:binding>
  <wsdl:service name="GetEhrExtractResponderService">
    <wsdl:port binding="tns:GetEhrExtractResponderBinding" name="GetEhrExtractResponderPort">
      <soap:address location="http://localhost:11000/npoadapter/getehrextract/stub"/>
    </wsdl:port>
  </wsdl:service>
  <xs:annotation>
    <xs:documentation>Tjänsteinteraktionens namn: GetEhrExtractInteraction
			 Beskrivning: 
			   The responder delivers health records on the RIV13606 format
			 Revisioner: 
			 Tjänstedomän: ehr:patientsummary
			 Tjänsteinteraktionstyp: Fråga-Svar
			 WS-profil: RIVTABP21
			 Förvaltas av: Sveriges Kommuner och Landsting</xs:documentation>
  </xs:annotation>
</wsdl:definitions>]]></con:content><con:type>http://schemas.xmlsoap.org/wsdl/</con:type></con:part><con:part><con:url>http://localhost:11000/npoadapter/getehrextract/stub?xsd=GetEhrExtractResponder_0.99.xsd</con:url><con:content><![CDATA[<!--Licensed to the Apache Software Foundation (ASF) under one
 or more contributor license agreements. See the NOTICE file
 distributed with this work for additional information
 regarding copyright ownership. Sveriges Kommuner och Landsting licenses this file
 to you under the Apache License, Version 2.0 (the
 "License"); you may not use this file except in compliance
 with the License. You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing,
 software distributed under the License is distributed on an
 "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 KIND, either express or implied. See the License for the
 specific language governing permissions and limitations
 under the License.-->
<xs:schema attributeFormDefault="unqualified" elementFormDefault="qualified" targetNamespace="urn:riv:ehr:patientsummary:GetEhrExtractResponder:1" version="1.0" xmlns:core="urn:riv:ehr:patientsummary:1" xmlns:tns="urn:riv:ehr:patientsummary:GetEhrExtractResponder:1" xmlns:xs="http://www.w3.org/2001/XMLSchema">
  <xs:annotation>
    <xs:documentation>-----------------------------------------------------------------------------
		2012-06-18 Hjalmar Jacobson (Tieto) har skapat detta schema. Innehållet i
		detta schema kommer från schemafilen ”SE13606RequestEHRExtract.xsd".
		-----------------------------------------------------------------------------</xs:documentation>
  </xs:annotation>
  <xs:import namespace="urn:riv:ehr:patientsummary:1" schemaLocation="http://localhost:11000/npoadapter/getehrextract/stub?xsd=../../core_components/ehr_patientsummary_0.99.xsd"/>
  <xs:element name="GetEhrExtract" type="tns:GetEhrExtractType"/>
  <xs:element name="GetEhrExtractResponse" type="tns:GetEhrExtractResponseType"/>
  <xs:complexType name="GetEhrExtractType">
    <xs:sequence>
      <xs:element name="subject_of_care_id" type="core:II"/>
      <xs:element minOccurs="0" name="purpose" type="core:CD"/>
      <xs:element maxOccurs="unbounded" minOccurs="0" name="rc_ids" type="core:II"/>
      <xs:element minOccurs="0" name="time_period" type="core:IVL_TS"/>
      <xs:element minOccurs="0" name="max_sensitivity" type="core:INT"/>
      <xs:element minOccurs="0" name="all_versions" type="core:BL"/>
      <xs:element minOccurs="0" name="multimedia_included" type="core:BL"/>
      <xs:element maxOccurs="unbounded" minOccurs="0" name="archetype_ids" type="core:II"/>
      <xs:element maxOccurs="unbounded" minOccurs="0" name="meanings" type="core:CD"/>
      <xs:element minOccurs="0" name="max_records" type="core:INT"/>
      <xs:element maxOccurs="unbounded" minOccurs="0" name="parameters" type="tns:ParameterType"/>
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="GetEhrExtractResponseType">
    <xs:sequence>
      <xs:element maxOccurs="unbounded" minOccurs="0" name="ehr_extract" type="core:EHR_EXTRACT"/>
      <xs:element minOccurs="0" name="continuation_token" type="core:ST"/>
      <xs:element maxOccurs="unbounded" minOccurs="0" name="response_detail" type="tns:ResponseDetailType"/>
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="ParameterType">
    <xs:sequence>
      <xs:element minOccurs="0" name="code" type="core:CD"/>
      <xs:element name="name" type="core:ST"/>
      <xs:element name="value" type="core:ST"/>
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="ResponseDetailType">
    <xs:sequence>
      <xs:element minOccurs="0" name="code" type="core:CD"/>
      <xs:element name="text" type="core:ST"/>
    </xs:sequence>
    <xs:attribute name="type_code" type="tns:ResponseDetailTypeCodes"/>
  </xs:complexType>
  <xs:simpleType name="ResponseDetailTypeCodes">
    <xs:restriction base="xs:string">
      <xs:enumeration value="E"/>
      <xs:enumeration value="W"/>
      <xs:enumeration value="I"/>
      <!--Error-->
      <!--Warning-->
      <!--Information-->
    </xs:restriction>
  </xs:simpleType>
</xs:schema>]]></con:content><con:type>http://www.w3.org/2001/XMLSchema</con:type></con:part><con:part><con:url>http://localhost:11000/npoadapter/getehrextract/stub?xsd=../../core_components/ehr_patientsummary_0.99.xsd</con:url><con:content><![CDATA[<!--Licensed to the Apache Software Foundation (ASF) under one
 or more contributor license agreements. See the NOTICE file
 distributed with this work for additional information
 regarding copyright ownership. Sveriges Kommuner och Landsting licenses this file
 to you under the Apache License, Version 2.0 (the
 "License"); you may not use this file except in compliance
 with the License. You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing,
 software distributed under the License is distributed on an
 "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 KIND, either express or implied. See the License for the
 specific language governing permissions and limitations
 under the License.-->
<xs:schema attributeFormDefault="unqualified" elementFormDefault="qualified" targetNamespace="urn:riv:ehr:patientsummary:1" version="1.0" xmlns:tns="urn:riv:ehr:patientsummary:1" xmlns:xs="http://www.w3.org/2001/XMLSchema">
  <xs:annotation>
    <xs:documentation>
      --------------- original copyright -------------------------
       XML Schema equivalent  representation of  the  CEN/ISO 13606 
       part 1 model  for  Electronic  Healthcare  Record  Exchange. 
       This  version of the schema emphasises (1) fidelity  to  the 
       13606-1 standard  (even where  this leads to sub-optimal XML 
       representation)  and  (2)  maximum  use  of  W3C  XML Schema
       features (even where this increases parser complexity). This
       Schema definition conforms  to the 13606-1 version published
       February 2007.

       (c) 2008 CHIME, University College London.
       Created by Taher Hassan.
       --------------------------------------------------------------------------------------
       --------------------------------------------------------------------------------------
		Modified by Brainpool-Mawell to use ISO datatypes, split
		into separate schemas, corrected and simplified.
		Rodolfo Garcia
		Kristin Schoug
		Torbjorn Dahlin
		
		-----------------------------------------------------------------------------
		v1.1 2008-10-29. Modified by Andreas Ostberg - Arkitekturledningens T-grupp
		Modification of LINK-type. Additional optional attribute target_type. Holds a 
		code about the type of content of the target(s). There can only be 0-1 
		target_type in LINK, therefore it is not possible to use target_type if LINK 
		is referring to several different types of targets. If it is still necessary to set 
		target_type use one LINK for each type of target.
		
		v1.2 2009-02-03: Modified by Kristin Schoug Bertilsson. The attribute 
		elementFormDefault="qualified" was added because of problems with the 
		nameSpace validation.
		-----------------------------------------------------------------------------
       
		-----------------------------------------------------------------------------
		2012-06-18 Hjalmar Jacobson (Tieto) har skapat detta schema. Innehållet i
		detta schema kommer från schemafilerna ”SE13606-1.xsd” och ”SE13606-1_demographics.xsd” 
		-----------------------------------------------------------------------------
      <!---->
      <!--Demographics Types-->
      <!---->
      <!--The demographics package is provided on page 47  of the CEN/ISO
    13606 part 1 standard.
    
    Note possible shortcomings of the 13606-1 definition:
    (a) On several occasions in the standard a code is described as
    having a CS type, but only two of the necessary parts of the CS
    are provided by the documentation (usually a value and a human-
    readable   portion).   They  are  represented  here  as  simple
    enumerations (with whitespace removed as necessary).-->
    </xs:documentation>
  </xs:annotation>
  <xs:include schemaLocation="http://localhost:11000/npoadapter/getehrextract/stub?xsd=ISO_dt.xsd"/>
  <xs:complexType name="EHR_EXTRACT">
    <xs:annotation>
      <xs:documentation>The root node of an EHR Extract.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element minOccurs="0" name="authorising_party" type="tns:II"/>
      <xs:element name="ehr_id" type="tns:II"/>
      <xs:element name="ehr_system" type="tns:II"/>
      <xs:element fixed="EN 13606" name="rm_id"/>
      <xs:element name="subject_of_care" type="tns:II"/>
      <xs:element name="time_created" type="tns:TS"/>
      <xs:element maxOccurs="unbounded" minOccurs="0" name="all_compositions" type="tns:COMPOSITION"/>
      <xs:element maxOccurs="unbounded" minOccurs="0" name="criteria" type="tns:EXTRACT_CRITERIA"/>
      <xs:element maxOccurs="unbounded" minOccurs="0" name="folders" type="tns:FOLDER"/>
      <xs:element maxOccurs="unbounded" minOccurs="0" name="demographic_extract" type="tns:IDENTIFIED_ENTITY"/>
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="EXTRACT_CRITERIA">
    <xs:annotation>
      <xs:documentation>Restrictions or filters on the creation of the EHR Extract.
        The time_period  should be a  restriction on the data types
        of low and  high to  make them TS,  but this restriction is
        not permissible in XML  Schema and thus the IVL  properties
        are simply  copied here with the appropriate types.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element minOccurs="0" name="all_versions" type="tns:BL"/>
      <xs:element maxOccurs="unbounded" minOccurs="0" name="archetype_ids" type="tns:II"/>
      <xs:element minOccurs="0" name="max_sensitivity" type="tns:INT"/>
      <xs:element minOccurs="0" name="multimedia_included" type="tns:BL"/>
      <xs:element minOccurs="0" name="other_constraints" type="tns:ST"/>
      <xs:element minOccurs="0" name="time_period" type="tns:IVL_TS"/>
    </xs:sequence>
  </xs:complexType>
  <xs:complexType abstract="true" name="RECORD_COMPONENT">
    <xs:annotation>
      <xs:documentation>Superclass  of all concrete  aggregator classes in  the EHR
        hierarchy.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element minOccurs="0" name="archetype_id" type="tns:ST"/>
      <xs:element minOccurs="0" name="meaning" type="tns:CD"/>
      <xs:element name="name" type="tns:ST"/>
      <xs:element minOccurs="0" name="orig_parent_ref" type="tns:II"/>
      <xs:element maxOccurs="unbounded" minOccurs="0" name="policy_ids" type="tns:II"/>
      <xs:element name="rc_id" type="tns:II"/>
      <xs:element minOccurs="0" name="sensitivity" type="tns:INT"/>
      <xs:element name="synthesised" type="tns:BL"/>
      <xs:element maxOccurs="unbounded" minOccurs="0" name="links" type="tns:LINK"/>
      <xs:element minOccurs="0" name="feeder_audit" type="tns:AUDIT_INFO"/>
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="FOLDER">
    <xs:annotation>
      <xs:documentation>Organises and groups Compositions within an EHR Extract.</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="tns:RECORD_COMPONENT">
        <xs:sequence>
          <xs:element maxOccurs="unbounded" minOccurs="0" name="sub_folders" type="tns:FOLDER"/>
          <xs:element maxOccurs="unbounded" minOccurs="0" name="attestations" type="tns:ATTESTATION_INFO"/>
          <xs:element maxOccurs="unbounded" minOccurs="0" name="composition_rc_ids" type="tns:ST"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="COMPOSITION">
    <xs:annotation>
      <xs:documentation>Key  aggregation  class  representing  the  set  of  Record
        Components authored and committed during a  single clinical
        encounter.  Note the  values for  territory  will  indicate
        the legal  framework under which  the  data was  committed.
        The session_time should be a  restriction on the data types
        of low and  high to  make them TS,  but this restriction is
        not permissible in XML  Schema and thus the IVL  properties
        are simply copied here with the appropriate types.</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="tns:RECORD_COMPONENT">
        <xs:sequence>
          <xs:element minOccurs="0" name="contribution_id" type="tns:II"/>
          <xs:element minOccurs="0" name="session_time" type="tns:IVL_TS"/>
          <xs:element minOccurs="0" name="territory" type="tns:CS"/>
          <xs:element maxOccurs="unbounded" minOccurs="0" name="attestations" type="tns:ATTESTATION_INFO"/>
          <xs:element maxOccurs="unbounded" minOccurs="0" name="other_participations" type="tns:FUNCTIONAL_ROLE"/>
          <xs:element name="committal" type="tns:AUDIT_INFO"/>
          <xs:element minOccurs="0" name="composer" type="tns:FUNCTIONAL_ROLE"/>
          <xs:element maxOccurs="unbounded" minOccurs="0" name="content" type="tns:CONTENT"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType abstract="true" name="CONTENT">
    <xs:annotation>
      <xs:documentation>Superclass of Section and Entry that  enables the former to
        include instances of itself.</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="tns:RECORD_COMPONENT"/>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="SECTION">
    <xs:annotation>
      <xs:documentation>Represents  a heading  in the  record  under which  further
        Entry instances might be found.</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="tns:CONTENT">
        <xs:sequence>
          <xs:element maxOccurs="unbounded" minOccurs="0" name="members" type="tns:CONTENT"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="ENTRY">
    <xs:annotation>
      <xs:documentation>Represents the information  acquired for a  single clinical
        activity  or recording.  The  Entry  may be  nilled  if  it 
        corrects a previous erroneous version.</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="tns:CONTENT">
        <xs:sequence>
          <xs:element minOccurs="0" name="act_id" type="tns:ST"/>
          <xs:element minOccurs="0" name="act_status" type="tns:CS"/>
          <xs:element minOccurs="0" name="subject_of_information_category" type="tns:CS"/>
          <xs:element name="uncertainty_expressed" type="tns:BL"/>
          <xs:element maxOccurs="unbounded" minOccurs="0" name="items" nillable="true" type="tns:ITEM"/>
          <xs:element minOccurs="0" name="info_provider" type="tns:FUNCTIONAL_ROLE"/>
          <xs:element maxOccurs="unbounded" minOccurs="0" name="other_participations" type="tns:FUNCTIONAL_ROLE"/>
          <xs:element minOccurs="0" name="subject_of_information" type="tns:RELATED_PARTY"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType abstract="true" name="ITEM">
    <xs:annotation>
      <xs:documentation>Superclass of  Cluster and Element  that enables the former
        to include  instances of itself.  The obs_time  should be a
        restriction on the data types of low and high to make  them
        TS,  but this  restriction is not permissible in XML Schema
        and thus the IVL properties are simply copied here with the
        appropriate types.</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="tns:RECORD_COMPONENT">
        <xs:sequence>
          <xs:element minOccurs="0" name="emphasis" type="tns:CD"/>
          <xs:element minOccurs="0" name="item_category" type="tns:CS"/>
          <xs:element minOccurs="0" name="obs_time" type="tns:IVL_TS"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="CLUSTER">
    <xs:annotation>
      <xs:documentation>Represents hierarchical organisation of data values.</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="tns:ITEM">
        <xs:sequence>
          <xs:element name="structure_type" type="tns:CS"/>
          <xs:element maxOccurs="unbounded" minOccurs="0" name="parts" type="tns:ITEM"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="ELEMENT">
    <xs:annotation>
      <xs:documentation>The Data Value holder in the aggregation structure.</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="tns:ITEM">
        <xs:sequence>
          <xs:element minOccurs="0" name="value" type="tns:ANY"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="AUDIT_INFO">
    <xs:annotation>
      <xs:documentation>The  committal  and revision  data for a  Record Component.
        Note   that  the   invariant  is   incorrectly  stated   as 
        constraining  "attribute_version_status.coding_scheme_name"
        in the printed standard.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="committer" type="tns:II"/>
      <xs:element name="ehr_system" type="tns:II"/>
      <xs:element minOccurs="0" name="previous_version" type="tns:II"/>
      <xs:element minOccurs="0" name="reason_for_revision" type="tns:CD"/>
      <xs:element name="time_committed" type="tns:TS"/>
      <xs:element minOccurs="0" name="version_set_id" type="tns:II"/>
      <xs:element minOccurs="0" name="version_status" type="tns:CS"/>
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="ATTESTATION_INFO">
    <xs:annotation>
      <xs:documentation>Any  attestations  for a Record Component.  The proof field
        should be a  cryptographic  hash of the RECORD_COMPONENT it
        attests,  but it is recognised that in many implementations
        the components will change to  point to new components that
        revise  them.  In  that case,  the  proof  should sign  the
        unchanging parts of the component only.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element minOccurs="0" name="attested_view" type="tns:ED"/>
      <xs:element minOccurs="0" name="proof" type="tns:ED"/>
      <xs:element name="reason_for_attestation" type="tns:CD"/>
      <xs:element name="time" type="tns:TS"/>
      <xs:element maxOccurs="unbounded" name="target_rc_id" type="tns:II"/>
      <xs:element name="attester" type="tns:FUNCTIONAL_ROLE"/>
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="FUNCTIONAL_ROLE">
    <xs:annotation>
      <xs:documentation>The participation of an entity in the EHR.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element minOccurs="0" name="function" type="tns:CD"/>
      <xs:element minOccurs="0" name="healthcare_facility" type="tns:II"/>
      <xs:element minOccurs="0" name="mode" type="tns:CS"/>
      <xs:element name="performer" type="tns:II"/>
      <xs:element minOccurs="0" name="service_setting" type="tns:CD"/>
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="RELATED_PARTY">
    <xs:annotation>
      <xs:documentation>Identifies the relationship  of a person to the  subject of
        care. Specifically used in Entry.subject_of_information.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element minOccurs="0" name="party" type="tns:II"/>
      <xs:element name="relationship" type="tns:ED"/>
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="LINK">
    <xs:annotation>
      <xs:documentation>Creates a  relationship between  two Record Components that
        is orthogonal  to the common one of containment.  Note that
        if a recipient is not permitted to see the component linked
        to,  even revealing the  link constitutes an  inappropriate
        disclosure.  Role is  of type  CD so  that  the displayName
        property of that class can be used in place of any specific
        coding scheme.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="follow_link" type="tns:BL"/>
      <xs:element name="nature" type="tns:CS"/>
      <xs:element minOccurs="0" name="role" type="tns:CD"/>
      <xs:element minOccurs="0" name="target_type" type="tns:CD"/>
      <xs:element maxOccurs="unbounded" name="target_id" type="tns:II"/>
    </xs:sequence>
  </xs:complexType>
  <xs:complexType abstract="true" name="IDENTIFIED_ENTITY">
    <xs:annotation>
      <xs:documentation>Superclass of all  identified parties  to the record.  Note
        that the  type of  id is not  given  in the  printed  class
        description  but  is included  in the class diagram on page
        47 of the standard.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="extract_id" type="tns:II"/>
      <xs:element maxOccurs="unbounded" minOccurs="0" name="id" type="tns:II"/>
      <xs:element maxOccurs="unbounded" minOccurs="0" name="telecom" type="tns:TEL"/>
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="SOFTWARE_OR_DEVICE">
    <xs:annotation>
      <xs:documentation>A piece of equipment or a device.</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="tns:IDENTIFIED_ENTITY">
        <xs:sequence>
          <xs:element name="code" type="tns:CD"/>
          <xs:element name="desc" type="tns:ST"/>
          <xs:element name="manufacturerModelName" type="tns:ST"/>
          <xs:element minOccurs="0" name="version" type="tns:ST"/>
          <xs:element minOccurs="0" name="owningOrganisation_id" type="tns:ST"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="ORGANISATION">
    <xs:annotation>
      <xs:documentation>An  organisation  corresponding to GPIC 2.008  (2008 in the
        printed standard).</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="tns:IDENTIFIED_ENTITY">
        <xs:sequence>
          <xs:element name="code" type="tns:CD"/>
          <xs:element name="desc" type="tns:ST"/>
          <xs:element name="name" type="tns:ST"/>
          <xs:element maxOccurs="unbounded" minOccurs="0" name="addr" type="tns:AD"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="PERSON">
    <xs:annotation>
      <xs:documentation>General    demographic    information    about   a   person
        corresponding to GPIC 2.006.</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="tns:IDENTIFIED_ENTITY">
        <xs:sequence>
          <xs:element maxOccurs="unbounded" minOccurs="0" name="name" type="tns:EN"/>
          <xs:element maxOccurs="unbounded" minOccurs="0" name="addr" type="tns:AD"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="IDENTIFIED_HEALTHCARE_PROFESSIONAL">
    <xs:annotation>
      <xs:documentation>Reference to an identified healthcare professional, derived 
        from GPIC 2.034.</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="tns:PERSON">
        <xs:sequence>
          <xs:element maxOccurs="unbounded" minOccurs="0" name="role" type="tns:HEALTHCARE_PROFESSIONAL_ROLE"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="HEALTHCARE_PROFESSIONAL_ROLE">
    <xs:annotation>
      <xs:documentation>Describes the  role of  a  healthcare professional  in  the 
        record,  based on  the GPICS  class of the  same name. Note
        that the id instances  should refer to the  same identified
        individual,   but   might  be   needed  to  establish  that 
        individual's identity in different working environments.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element maxOccurs="unbounded" minOccurs="0" name="id" type="tns:II"/>
      <xs:element minOccurs="0" name="position_or_grade" type="tns:CD"/>
      <xs:element minOccurs="0" name="profession" type="tns:CD"/>
      <xs:element minOccurs="0" name="specialty" type="tns:CD"/>
      <xs:element minOccurs="0" name="scopingOrganisation_id" type="tns:II"/>
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="SUBJECT_OF_CARE_PERSON_IDENTIFICATION">
    <xs:annotation>
      <xs:documentation>Identification information about a person  corresponding to
        GPIC 2.015.</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="tns:PERSON">
        <xs:sequence>
          <xs:element name="administrativeGenderCode" type="tns:CS"/>
          <xs:element minOccurs="0" name="birthOrderNumber" type="tns:INT"/>
          <xs:element name="birthTime" type="tns:TS"/>
          <xs:element minOccurs="0" name="deceasedTime" type="tns:TS"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
</xs:schema>]]></con:content><con:type>http://www.w3.org/2001/XMLSchema</con:type></con:part><con:part><con:url>http://localhost:11000/npoadapter/getehrextract/stub?xsd=ISO_dt.xsd</con:url><con:content><![CDATA[<!--Fel identifierat och åtgärdat i regexp-uttrycket för TS. Schemat innehåller därmed en avvikelse från det schema som specificeras i WGI_N08-012_ISO 21090-ISOv2.pdf.
Felet identifierades inom projektet NPÖ och används nu inom nationella projekt i Sverige.-->
<xsd:schema elementFormDefault="qualified" xmlns:sch="http://www.ascc.net/xml/schematron" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <xsd:annotation>
    <xsd:documentation>From draft ISO 21090 May 2008.</xsd:documentation>
  </xsd:annotation>
  <xsd:simpleType name="NullFlavor">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="NI"/>
      <xsd:enumeration value="INV"/>
      <xsd:enumeration value="OTH"/>
      <xsd:enumeration value="NINF"/>
      <xsd:enumeration value="PINF"/>
      <xsd:enumeration value="UNC"/>
      <xsd:enumeration value="DER"/>
      <xsd:enumeration value="UNK"/>
      <xsd:enumeration value="ASKU"/>
      <xsd:enumeration value="NAV"/>
      <xsd:enumeration value="QS"/>
      <xsd:enumeration value="NASK"/>
      <xsd:enumeration value="TRC"/>
      <xsd:enumeration value="MSK"/>
      <xsd:enumeration value="NA"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="UpdateMode">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="A"/>
      <xsd:enumeration value="AU"/>
      <xsd:enumeration value="U"/>
      <xsd:enumeration value="R"/>
      <xsd:enumeration value="I"/>
      <xsd:enumeration value="D"/>
      <xsd:enumeration value="K"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="Compression">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="DF"/>
      <xsd:enumeration value="GZ"/>
      <xsd:enumeration value="ZL"/>
      <xsd:enumeration value="Z"/>
      <xsd:enumeration value="BZ"/>
      <xsd:enumeration value="Z7"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="IntegrityCheckAlgorithm">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="SHA1"/>
      <xsd:enumeration value="SHA256"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="TelecommunicationAddressUse">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="H"/>
      <xsd:enumeration value="HP"/>
      <xsd:enumeration value="HV"/>
      <xsd:enumeration value="WP"/>
      <xsd:enumeration value="DIR"/>
      <xsd:enumeration value="PUB"/>
      <xsd:enumeration value="BAD"/>
      <xsd:enumeration value="TMP"/>
      <xsd:enumeration value="AS"/>
      <xsd:enumeration value="EC"/>
      <xsd:enumeration value="MC"/>
      <xsd:enumeration value="PG"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="set_TelecommunicationAddressUse">
    <xsd:list itemType="TelecommunicationAddressUse"/>
  </xsd:simpleType>
  <xsd:simpleType name="IdentifierScope">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="BUSN"/>
      <xsd:enumeration value="OBJ"/>
      <xsd:enumeration value="VER"/>
      <xsd:enumeration value="VW"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="IdentifierReliability">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="ISS"/>
      <xsd:enumeration value="VER"/>
      <xsd:enumeration value="UNV"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="AddressPartType">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="AL"/>
      <xsd:enumeration value="ADL"/>
      <xsd:enumeration value="UNID"/>
      <xsd:enumeration value="UNIT"/>
      <xsd:enumeration value="DAL"/>
      <xsd:enumeration value="DINST"/>
      <xsd:enumeration value="DINSTA"/>
      <xsd:enumeration value="DINSTQ"/>
      <xsd:enumeration value="DMOD"/>
      <xsd:enumeration value="DMODID"/>
      <xsd:enumeration value="SAL"/>
      <xsd:enumeration value="BNR"/>
      <xsd:enumeration value="BNN"/>
      <xsd:enumeration value="BNS"/>
      <xsd:enumeration value="STR"/>
      <xsd:enumeration value="STB"/>
      <xsd:enumeration value="STTYP"/>
      <xsd:enumeration value="DIR"/>
      <xsd:enumeration value="INT"/>
      <xsd:enumeration value="CAR"/>
      <xsd:enumeration value="CEN"/>
      <xsd:enumeration value="CNT"/>
      <xsd:enumeration value="CPA"/>
      <xsd:enumeration value="CTY"/>
      <xsd:enumeration value="DEL"/>
      <xsd:enumeration value="POB"/>
      <xsd:enumeration value="PRE"/>
      <xsd:enumeration value="STA"/>
      <xsd:enumeration value="ZIP"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="PostalAddressUse">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="H"/>
      <xsd:enumeration value="HP"/>
      <xsd:enumeration value="HV"/>
      <xsd:enumeration value="WP"/>
      <xsd:enumeration value="DIR"/>
      <xsd:enumeration value="PUB"/>
      <xsd:enumeration value="BAD"/>
      <xsd:enumeration value="TMP"/>
      <xsd:enumeration value="PHYS"/>
      <xsd:enumeration value="PST"/>
      <xsd:enumeration value="ABC"/>
      <xsd:enumeration value="IDE"/>
      <xsd:enumeration value="SYL"/>
      <xsd:enumeration value="SRCH"/>
      <xsd:enumeration value="SNDX"/>
      <xsd:enumeration value="PHON"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="set_PostalAddressUse">
    <xsd:list itemType="PostalAddressUse"/>
  </xsd:simpleType>
  <xsd:simpleType name="EntityNamePartType">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="FAM"/>
      <xsd:enumeration value="GIV"/>
      <xsd:enumeration value="PFX"/>
      <xsd:enumeration value="SFX"/>
      <xsd:enumeration value="DEL"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="EntityNamePartQualifier">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="LS"/>
      <xsd:enumeration value="AC"/>
      <xsd:enumeration value="NB"/>
      <xsd:enumeration value="PR"/>
      <xsd:enumeration value="VV"/>
      <xsd:enumeration value="AD"/>
      <xsd:enumeration value="BR"/>
      <xsd:enumeration value="SP"/>
      <xsd:enumeration value="CL"/>
      <xsd:enumeration value="MID"/>
      <!--Hjalmar har lagt till MID 2010-04-19-->
      <xsd:enumeration value="IN"/>
      <xsd:enumeration value="TITLE"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="set_EntityNamePartQualifier">
    <xsd:list itemType="EntityNamePartQualifier"/>
  </xsd:simpleType>
  <xsd:simpleType name="EntityNameUse">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="C"/>
      <xsd:enumeration value="I"/>
      <xsd:enumeration value="L"/>
      <xsd:enumeration value="P"/>
      <xsd:enumeration value="A"/>
      <xsd:enumeration value="R"/>
      <xsd:enumeration value="OR"/>
      <xsd:enumeration value="SRCH"/>
      <xsd:enumeration value="PHON"/>
      <xsd:enumeration value="SNDX"/>
      <xsd:enumeration value="ABC"/>
      <xsd:enumeration value="SYL"/>
      <xsd:enumeration value="IDE"/>
      <xsd:enumeration value="ASGN"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="set_EntityNameUse">
    <xsd:list itemType="EntityNameUse"/>
  </xsd:simpleType>
  <xsd:simpleType name="CalendarCycle">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="CY"/>
      <xsd:enumeration value="MY"/>
      <xsd:enumeration value="CM"/>
      <xsd:enumeration value="CW"/>
      <xsd:enumeration value="WY"/>
      <xsd:enumeration value="DM"/>
      <xsd:enumeration value="CD"/>
      <xsd:enumeration value="DY"/>
      <xsd:enumeration value="DW"/>
      <xsd:enumeration value="HD"/>
      <xsd:enumeration value="CH"/>
      <xsd:enumeration value="NH"/>
      <xsd:enumeration value="CN"/>
      <xsd:enumeration value="SN"/>
      <xsd:enumeration value="CS"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="TimingEvent">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="HS"/>
      <xsd:enumeration value="AC"/>
      <xsd:enumeration value="ACM"/>
      <xsd:enumeration value="ACD"/>
      <xsd:enumeration value="ACV"/>
      <xsd:enumeration value="IC"/>
      <xsd:enumeration value="ICM"/>
      <xsd:enumeration value="ICD"/>
      <xsd:enumeration value="ICV"/>
      <xsd:enumeration value="PC"/>
      <xsd:enumeration value="PCM"/>
      <xsd:enumeration value="PCD"/>
      <xsd:enumeration value="PCV"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="CodingRationale">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="O"/>
      <xsd:enumeration value="P"/>
      <xsd:enumeration value="R"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="set_CodingRationale">
    <xsd:list itemType="CodingRationale"/>
  </xsd:simpleType>
  <xsd:simpleType name="UncertaintyType">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="U"/>
      <xsd:enumeration value="N"/>
      <xsd:enumeration value="LN"/>
      <xsd:enumeration value="G"/>
      <xsd:enumeration value="E"/>
      <xsd:enumeration value="X2"/>
      <xsd:enumeration value="T"/>
      <xsd:enumeration value="F"/>
      <xsd:enumeration value="B"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:complexType mixed="true" name="StrucDoc.Text">
    <xsd:sequence>
      <xsd:choice maxOccurs="unbounded" minOccurs="0">
        <xsd:element name="footnote" type="StrucDoc.Footnote"/>
        <xsd:element name="footnoteRef" type="StrucDoc.FootnoteRef"/>
        <xsd:element name="linkHtml" type="StrucDoc.LinkHtml"/>
        <xsd:element name="sub" type="StrucDoc.Sub"/>
        <xsd:element name="sup" type="StrucDoc.Sup"/>
        <xsd:element name="content" type="StrucDoc.Content"/>
        <xsd:element name="br" type="StrucDoc.Br"/>
        <xsd:element name="renderMultiMedia" type="StrucDoc.RenderMultiMedia"/>
        <xsd:element name="paragraph" type="StrucDoc.Paragraph"/>
        <xsd:element name="list" type="StrucDoc.List"/>
        <xsd:element name="table" type="StrucDoc.Table"/>
      </xsd:choice>
    </xsd:sequence>
    <xsd:attributeGroup ref="StrucDoc.Base"/>
  </xsd:complexType>
  <xsd:attributeGroup name="StrucDoc.Base">
    <xsd:attribute name="ID" type="xsd:ID" use="optional"/>
    <xsd:attribute name="language" type="Code" use="optional"/>
    <xsd:attribute name="styleCode" type="set_Code" use="optional"/>
  </xsd:attributeGroup>
  <xsd:simpleType name="XmlID">
    <xsd:restriction base="xsd:ID"/>
  </xsd:simpleType>
  <xsd:simpleType name="Code">
    <xsd:restriction base="xsd:string"/>
  </xsd:simpleType>
  <xsd:simpleType name="set_Code">
    <xsd:list itemType="Code"/>
  </xsd:simpleType>
  <xsd:complexType mixed="true" name="StrucDoc.Footnote">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="Some content required">
          <sch:rule abstract="true" id="StrucDoc.Footnote-0">
            <sch:assert test="count(*|text()[normalize-space(.)!=''])!=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:choice maxOccurs="unbounded" minOccurs="0">
        <xsd:element name="footnote" type="StrucDoc.Footnote"/>
        <xsd:element name="footnoteRef" type="StrucDoc.FootnoteRef"/>
        <xsd:element name="linkHtml" type="StrucDoc.LinkHtml"/>
        <xsd:element name="sub" type="StrucDoc.Sub"/>
        <xsd:element name="sup" type="StrucDoc.Sup"/>
        <xsd:element name="content" type="StrucDoc.Content"/>
        <xsd:element name="br" type="StrucDoc.Br"/>
        <xsd:element name="renderMultiMedia" type="StrucDoc.RenderMultiMedia"/>
        <xsd:element name="paragraph" type="StrucDoc.Paragraph"/>
        <xsd:element name="list" type="StrucDoc.List"/>
        <xsd:element name="table" type="StrucDoc.Table"/>
      </xsd:choice>
    </xsd:sequence>
    <xsd:attributeGroup ref="StrucDoc.Base"/>
  </xsd:complexType>
  <xsd:complexType name="StrucDoc.FootnoteRef">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="must have a reference">
          <sch:rule abstract="true" id="StrucDoc.FootnoteRef-0">
            <sch:assert test="@IDREF"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:attribute name="IDREF" type="xsd:IDREF" use="optional"/>
    <xsd:attributeGroup ref="StrucDoc.Base"/>
  </xsd:complexType>
  <xsd:simpleType name="XmlIDREF">
    <xsd:restriction base="xsd:IDREF"/>
  </xsd:simpleType>
  <xsd:complexType mixed="true" name="StrucDoc.LinkHtml">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="must have at least one item">
          <sch:rule abstract="true" id="StrucDoc.LinkHtml-0">
            <sch:assert test="count(*|text()[normalize-space(.)!=''])!=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:choice maxOccurs="unbounded" minOccurs="0">
        <xsd:element name="footnote" type="StrucDoc.Footnote"/>
        <xsd:element name="footnoteRef" type="StrucDoc.FootnoteRef"/>
      </xsd:choice>
    </xsd:sequence>
    <xsd:attribute name="name" type="xsd:string" use="optional"/>
    <xsd:attribute name="href" type="xsd:string" use="optional"/>
    <xsd:attribute name="rel" type="xsd:string" use="optional"/>
    <xsd:attribute name="rev" type="xsd:string" use="optional"/>
    <xsd:attribute name="title" type="xsd:string" use="optional"/>
    <xsd:attributeGroup ref="StrucDoc.Base"/>
  </xsd:complexType>
  <xsd:complexType mixed="true" name="StrucDoc.Sub">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="text must not be empty">
          <sch:rule abstract="true" id="StrucDoc.Sub-0">
            <sch:assert test="string-length(text()) != 0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
  </xsd:complexType>
  <xsd:complexType mixed="true" name="StrucDoc.Sup">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="text must not be empty">
          <sch:rule abstract="true" id="StrucDoc.Sup-0">
            <sch:assert test="string-length(text()) != 0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
  </xsd:complexType>
  <xsd:complexType mixed="true" name="StrucDoc.Content">
    <xsd:sequence>
      <xsd:choice maxOccurs="unbounded" minOccurs="0">
        <xsd:element name="footnote" type="StrucDoc.Footnote"/>
        <xsd:element name="footnoteRef" type="StrucDoc.FootnoteRef"/>
        <xsd:element name="linkHtml" type="StrucDoc.LinkHtml"/>
        <xsd:element name="sub" type="StrucDoc.Sub"/>
        <xsd:element name="sup" type="StrucDoc.Sup"/>
        <xsd:element name="content" type="StrucDoc.Content"/>
        <xsd:element name="br" type="StrucDoc.Br"/>
        <xsd:element name="renderMultiMedia" type="StrucDoc.RenderMultiMedia"/>
      </xsd:choice>
    </xsd:sequence>
    <xsd:attribute name="revised" type="StrucDoc.Revised" use="optional"/>
    <xsd:attributeGroup ref="StrucDoc.Base"/>
  </xsd:complexType>
  <xsd:simpleType name="StrucDoc.Revised">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="insert"/>
      <xsd:enumeration value="delete"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:complexType name="StrucDoc.Br"/>
  <xsd:complexType name="StrucDoc.RenderMultiMedia">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="must have at least one reference">
          <sch:rule abstract="true" id="StrucDoc.RenderMultiMedia-0">
            <sch:assert test="@referencedObject"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element minOccurs="0" name="caption" type="StrucDoc.Caption"/>
    </xsd:sequence>
    <xsd:attribute name="referencedObject" type="set_IDREF" use="optional"/>
    <xsd:attributeGroup ref="StrucDoc.Base"/>
  </xsd:complexType>
  <xsd:complexType mixed="true" name="StrucDoc.Caption">
    <xsd:sequence>
      <xsd:choice maxOccurs="unbounded" minOccurs="0">
        <xsd:element name="footnote" type="StrucDoc.Footnote"/>
        <xsd:element name="footnoteRef" type="StrucDoc.FootnoteRef"/>
        <xsd:element name="linkHtml" type="StrucDoc.LinkHtml"/>
        <xsd:element name="sub" type="StrucDoc.Sub"/>
        <xsd:element name="sup" type="StrucDoc.Sup"/>
      </xsd:choice>
    </xsd:sequence>
    <xsd:attributeGroup ref="StrucDoc.Base"/>
  </xsd:complexType>
  <xsd:simpleType name="set_IDREF">
    <xsd:list itemType="xsd:IDREF"/>
  </xsd:simpleType>
  <xsd:complexType mixed="true" name="StrucDoc.Paragraph">
    <xsd:complexContent mixed="true">
      <xsd:extension base="StrucDoc.Captioned">
        <xsd:sequence>
          <xsd:choice maxOccurs="unbounded" minOccurs="0">
            <xsd:element name="footnote" type="StrucDoc.Footnote"/>
            <xsd:element name="footnoteRef" type="StrucDoc.FootnoteRef"/>
            <xsd:element name="linkHtml" type="StrucDoc.LinkHtml"/>
            <xsd:element name="sub" type="StrucDoc.Sub"/>
            <xsd:element name="sup" type="StrucDoc.Sup"/>
            <xsd:element name="content" type="StrucDoc.Content"/>
            <xsd:element name="br" type="StrucDoc.Br"/>
            <xsd:element name="renderMultiMedia" type="StrucDoc.RenderMultiMedia"/>
          </xsd:choice>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType mixed="true" name="StrucDoc.Captioned">
    <xsd:sequence>
      <xsd:element minOccurs="0" name="caption" type="StrucDoc.Caption"/>
    </xsd:sequence>
    <xsd:attributeGroup ref="StrucDoc.Base"/>
  </xsd:complexType>
  <xsd:complexType mixed="true" name="StrucDoc.List">
    <xsd:complexContent mixed="true">
      <xsd:extension base="StrucDoc.Captioned">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="StrucDoc.Item"/>
        </xsd:sequence>
        <xsd:attribute name="listType" type="StrucDoc.ListType" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:simpleType name="StrucDoc.ListType">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="ordered_"/>
      <xsd:enumeration value="unordered_"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:complexType mixed="true" name="StrucDoc.Item">
    <xsd:complexContent mixed="true">
      <xsd:extension base="StrucDoc.Captioned">
        <xsd:sequence>
          <xsd:choice maxOccurs="unbounded" minOccurs="0">
            <xsd:element name="footnote" type="StrucDoc.Footnote"/>
            <xsd:element name="footnoteRef" type="StrucDoc.FootnoteRef"/>
            <xsd:element name="linkHtml" type="StrucDoc.LinkHtml"/>
            <xsd:element name="sub" type="StrucDoc.Sub"/>
            <xsd:element name="sup" type="StrucDoc.Sup"/>
            <xsd:element name="content" type="StrucDoc.Content"/>
            <xsd:element name="br" type="StrucDoc.Br"/>
            <xsd:element name="renderMultiMedia" type="StrucDoc.RenderMultiMedia"/>
            <xsd:element name="paragraph" type="StrucDoc.Paragraph"/>
            <xsd:element name="list" type="StrucDoc.List"/>
            <xsd:element name="table" type="StrucDoc.Table"/>
          </xsd:choice>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType mixed="true" name="StrucDoc.Table">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="columns">
          <sch:rule abstract="true" id="StrucDoc.Table-0">
            <sch:assert test="not(col) or not(column)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent mixed="true">
      <xsd:extension base="StrucDoc.Captioned">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="col" type="StrucDoc.Col"/>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="colgroup" type="StrucDoc.ColGroup"/>
          <xsd:element minOccurs="0" name="thead" type="StrucDoc.TRowGroup"/>
          <xsd:element minOccurs="0" name="tfoot" type="StrucDoc.TRowGroup"/>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="tbody" type="StrucDoc.TRowGroup"/>
        </xsd:sequence>
        <xsd:attribute name="summary" type="xsd:string" use="optional"/>
        <xsd:attribute name="width" type="StrucDoc.Length" use="optional"/>
        <xsd:attribute name="border" type="StrucDoc.Length" use="optional"/>
        <xsd:attribute name="frame" type="StrucDoc.Frame" use="optional"/>
        <xsd:attribute name="rules" type="StrucDoc.Rules" use="optional"/>
        <xsd:attribute name="cellspacing" type="StrucDoc.Length" use="optional"/>
        <xsd:attribute name="cellpadding" type="StrucDoc.Length" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="StrucDoc.Col">
    <xsd:complexContent>
      <xsd:extension base="StrucDoc.ColItem"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="StrucDoc.ColItem">
    <xsd:complexContent>
      <xsd:extension base="StrucDoc.TableItem">
        <xsd:attribute default="1" name="span" type="xsd:int" use="optional"/>
        <xsd:attribute name="width" type="StrucDoc.Length" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="StrucDoc.TableItem">
    <xsd:attribute name="align" type="StrucDoc.Align" use="optional"/>
    <xsd:attribute name="char" type="xsd:string" use="optional"/>
    <xsd:attribute name="charoff" type="StrucDoc.Length" use="optional"/>
    <xsd:attribute name="valign" type="StrucDoc.VAlign" use="optional"/>
    <xsd:attributeGroup ref="StrucDoc.Base"/>
  </xsd:complexType>
  <xsd:simpleType name="StrucDoc.Align">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="left"/>
      <xsd:enumeration value="center"/>
      <xsd:enumeration value="right"/>
      <xsd:enumeration value="justify"/>
      <xsd:enumeration value="char"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="StrucDoc.Length">
    <xsd:restriction base="xsd:string"/>
  </xsd:simpleType>
  <xsd:simpleType name="StrucDoc.VAlign">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="top"/>
      <xsd:enumeration value="middle"/>
      <xsd:enumeration value="bottom"/>
      <xsd:enumeration value="baseline"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:complexType name="StrucDoc.ColGroup">
    <xsd:complexContent>
      <xsd:extension base="StrucDoc.ColItem">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="col" type="StrucDoc.Col"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="StrucDoc.TRowGroup">
    <xsd:complexContent>
      <xsd:extension base="StrucDoc.TableItem">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="tr" type="StrucDoc.TRow"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="StrucDoc.TRow">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="cells">
          <sch:rule abstract="true" id="StrucDoc.TRow-0">
            <sch:assert test="th|td"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="StrucDoc.TableItem">
        <xsd:sequence>
          <xsd:choice maxOccurs="unbounded" minOccurs="0">
            <xsd:element name="th" type="StrucDoc.TCell"/>
            <xsd:element name="td" type="StrucDoc.TCell"/>
          </xsd:choice>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType mixed="true" name="StrucDoc.TCell">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="no nested tables">
          <sch:rule abstract="true" id="StrucDoc.TCell-0">
            <sch:assert test="not(@table)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent mixed="true">
      <xsd:extension base="StrucDoc.TableItem">
        <xsd:sequence>
          <xsd:choice maxOccurs="unbounded" minOccurs="0">
            <xsd:element name="footnote" type="StrucDoc.Footnote"/>
            <xsd:element name="footnoteRef" type="StrucDoc.FootnoteRef"/>
            <xsd:element name="linkHtml" type="StrucDoc.LinkHtml"/>
            <xsd:element name="sub" type="StrucDoc.Sub"/>
            <xsd:element name="sup" type="StrucDoc.Sup"/>
            <xsd:element name="content" type="StrucDoc.Content"/>
            <xsd:element name="br" type="StrucDoc.Br"/>
            <xsd:element name="renderMultiMedia" type="StrucDoc.RenderMultiMedia"/>
            <xsd:element name="paragraph" type="StrucDoc.Paragraph"/>
            <xsd:element name="list" type="StrucDoc.List"/>
            <xsd:element name="table" type="StrucDoc.Table"/>
          </xsd:choice>
        </xsd:sequence>
        <xsd:attribute name="abbr" type="xsd:string" use="optional"/>
        <xsd:attribute name="axis" type="xsd:string" use="optional"/>
        <xsd:attribute name="headers" type="set_IDREF" use="optional"/>
        <xsd:attribute name="scope" type="StrucDoc.CellScope" use="optional"/>
        <xsd:attribute default="1" name="rowspan" type="xsd:int" use="optional"/>
        <xsd:attribute default="1" name="colspan" type="xsd:int" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:simpleType name="StrucDoc.CellScope">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="row"/>
      <xsd:enumeration value="col"/>
      <xsd:enumeration value="rowgroup"/>
      <xsd:enumeration value="colgroup"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="StrucDoc.Frame">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="void"/>
      <xsd:enumeration value="above"/>
      <xsd:enumeration value="below"/>
      <xsd:enumeration value="hsides"/>
      <xsd:enumeration value="lhs"/>
      <xsd:enumeration value="rhs"/>
      <xsd:enumeration value="vsides"/>
      <xsd:enumeration value="box"/>
      <xsd:enumeration value="border"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="StrucDoc.Rules">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="none"/>
      <xsd:enumeration value="groups"/>
      <xsd:enumeration value="rows"/>
      <xsd:enumeration value="cols"/>
      <xsd:enumeration value="all"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="Uid">
    <xsd:restriction base="xsd:string"/>
  </xsd:simpleType>
  <xsd:simpleType name="Uri">
    <xsd:restriction base="xsd:anyURI"/>
  </xsd:simpleType>
  <xsd:complexType name="BL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="value if not null">
          <sch:rule abstract="true" id="BL-0">
            <sch:assert test="@nullFlavor or (not(@nullFlavor) and @value)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:attribute name="value" type="xsd:boolean" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ANY">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="no ANY unless null">
          <sch:rule abstract="true" id="ANY-0">
            <sch:assert test="todo"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="HXIT">
        <xsd:attribute name="nullFlavor" type="NullFlavor" use="optional"/>
        <xsd:attribute name="flavorId" type="xsd:string" use="optional"/>
        <xsd:attribute name="updateMode" type="UpdateMode" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="HXIT">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="extension requires root">
          <sch:rule abstract="true" id="HXIT-0">
            <sch:assert test="not(@controlActExtension) or @controlActRoot"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:attribute name="validTimeLow" type="xsd:string" use="optional"/>
    <xsd:attribute name="validTimeHigh" type="xsd:string" use="optional"/>
    <xsd:attribute name="controlActRoot" type="Uid" use="optional"/>
    <xsd:attribute name="controlActExtension" type="xsd:string" use="optional"/>
  </xsd:complexType>
  <xsd:complexType name="BL.NONNULL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="BL.NONNULL cannot be null">
          <sch:rule abstract="true" id="BL.NONNULL-0">
            <sch:assert test="not(@nullFlavor)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="BL">
        <xsd:attribute name="nullFlavor" type="NullFlavor" use="prohibited"/>
        <xsd:attribute name="value" type="xsd:boolean" use="required"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ED">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="content is required if not null">
          <sch:rule abstract="true" id="ED-0">
            <sch:assert test="@nullFlavor or @value or xml or data"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="only one of value, data, xml">
          <sch:rule abstract="true" id="ED-1">
            <sch:assert test="count(*[self::value or self::xml or self::data])&lt;=1"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="integrityCheckAlgorithm required">
          <sch:rule abstract="true" id="ED-2">
            <sch:assert test="not(integrityCheck) or @integrityCheckAlgorithm"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="thumbnails do not use reference">
          <sch:rule abstract="true" id="ED-3">
            <sch:assert test="not(thumbnail) or thumbnail[not(@nullFlavor and reference)]"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="thumbnails do not have thumbnails">
          <sch:rule abstract="true" id="ED-4">
            <sch:assert test="not(thumbnail) or thumbnail[not(thumbnail)]"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="compression only on binary">
          <sch:rule abstract="true" id="ED-5">
            <sch:assert test="(@compression and data) or not(@compression or data)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="mediaType cannot be null">
          <sch:rule abstract="true" id="ED-6">
            <sch:assert test="@mediaType"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="value implies mediaType is text/plain">
          <sch:rule abstract="true" id="ED-7">
            <sch:assert test="not(@value) or (@value and (not(@mediaType) or @mediaType='text/plain'))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no charset for value or xml">
          <sch:rule abstract="true" id="ED-8">
            <sch:assert test="not(@value or xml) or not(@charset)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="ED-9">
            <sch:assert test="count(*[self::reference or self::thumbnail][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no nested translations">
          <sch:rule abstract="true" id="ED-10">
            <sch:assert test="not(translation) or thumbnail[not(translation)]"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no value if null">
          <sch:rule abstract="true" id="ED-11">
            <sch:assert test="not(@nullFlavor) or (@nullFlavor and not(@value))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no data if null">
          <sch:rule abstract="true" id="ED-12">
            <sch:assert test="not(@nullFlavor) or (@nullFlavor and not(@data))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no xml if null">
          <sch:rule abstract="true" id="ED-13">
            <sch:assert test="not(@nullFlavor) or (@nullFlavor and not(@xml))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no reference if null">
          <sch:rule abstract="true" id="ED-14">
            <sch:assert test="not(@nullFlavor) or (@nullFlavor and not(@reference))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no mediaType if null">
          <sch:rule abstract="true" id="ED-15">
            <sch:assert test="not(@nullFlavor) or (@nullFlavor and not(@mediaType))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no charset if null">
          <sch:rule abstract="true" id="ED-16">
            <sch:assert test="not(@nullFlavor) or (@nullFlavor and not(@charset))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no language if null">
          <sch:rule abstract="true" id="ED-17">
            <sch:assert test="not(@nullFlavor) or (@nullFlavor and not(@language))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no compression if null">
          <sch:rule abstract="true" id="ED-18">
            <sch:assert test="not(@nullFlavor) or (@nullFlavor and not(@compression))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no integrityCheck if null">
          <sch:rule abstract="true" id="ED-19">
            <sch:assert test="not(@nullFlavor) or (@nullFlavor and not(@integrityCheck))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no integrityCheckAlgorithm if null">
          <sch:rule abstract="true" id="ED-20">
            <sch:assert test="not(@nullFlavor) or (@nullFlavor and not(@integrityCheckAlgorithm))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no thumbnail if null">
          <sch:rule abstract="true" id="ED-21">
            <sch:assert test="not(@nullFlavor) or (not(thumbnail) or thumbnail\@nullFlavor)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no translation if null">
          <sch:rule abstract="true" id="ED-22">
            <sch:assert test="not(@nullFlavor) or (@nullFlavor and not(@translation))"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="data" type="xsd:base64Binary"/>
          <xsd:element minOccurs="0" name="xml" type="xsd:anyType"/>
          <xsd:element minOccurs="0" name="reference" type="TEL.URL"/>
          <xsd:element minOccurs="0" name="integrityCheck" type="xsd:base64Binary"/>
          <xsd:element minOccurs="0" name="thumbnail" type="ED"/>
          <xsd:element minOccurs="0" name="description" type="ST"/>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="translation" type="ED"/>
        </xsd:sequence>
        <xsd:attribute name="value" type="xsd:string" use="optional"/>
        <xsd:attribute default="text/plain" name="mediaType" type="xsd:string" use="optional"/>
        <xsd:attribute name="charset" type="Code" use="optional"/>
        <xsd:attribute name="language" type="Code" use="optional"/>
        <xsd:attribute name="compression" type="Compression" use="optional"/>
        <xsd:attribute name="integrityCheckAlgorithm" type="IntegrityCheckAlgorithm" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="TEL.URL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="no use">
          <sch:rule abstract="true" id="TEL.URL-0">
            <sch:assert test="not(use)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="schemes">
          <sch:rule abstract="true" id="TEL.URL-1">
            <sch:assert test="(starts-with(@value, &quot;file&quot;) or starts-with(@value, &quot;ftp&quot;) or starts-with(@value, &quot;http&quot;) or starts-with(@value, &quot;https&quot;) or starts-with(@value, &quot;nfs&quot;))"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="TEL">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="useablePeriod" type="QSET_TS"/>
        </xsd:sequence>
        <xsd:attribute name="use" type="TelecommunicationAddressUse" use="prohibited"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="TEL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="value is required">
          <sch:rule abstract="true" id="TEL-0">
            <sch:assert test="@nullFlavor or (not(@nullFlavor) and @value)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no value if null">
          <sch:rule abstract="true" id="TEL-1">
            <sch:assert test="not(@nullFlavor) or (@nullFlavor and not(@value))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no use if null">
          <sch:rule abstract="true" id="TEL-2">
            <sch:assert test="not(@nullFlavor) or (@nullFlavor and not(@use))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no useablePeriod if null">
          <sch:rule abstract="true" id="TEL-3">
            <sch:assert test="not(@nullFlavor) or (not(thumbnail) or useablePeriod\@nullFlavor)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on TEL attributes">
          <sch:rule abstract="true" id="TEL-4">
            <sch:assert test="count(*[self::useablePeriod][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="useablePeriod" type="QSET_TS"/>
        </xsd:sequence>
        <xsd:attribute name="value" type="xsd:anyURI" use="optional"/>
        <xsd:attribute name="use" type="set_TelecommunicationAddressUse" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="QSET_TS">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="QSET_TS-0">
            <sch:assert test="count(*[self::originalText][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ED.TEXT">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="text only">
          <sch:rule abstract="true" id="ED.TEXT-0">
            <sch:assert test="@mediaType = &quot;'text/plain'&quot;"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no xml">
          <sch:rule abstract="true" id="ED.TEXT-1">
            <sch:assert test="not(xml)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no data">
          <sch:rule abstract="true" id="ED.TEXT-2">
            <sch:assert test="not(data)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no integrityCheck">
          <sch:rule abstract="true" id="ED.TEXT-3">
            <sch:assert test="not(integrityCheck)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no thumbnail">
          <sch:rule abstract="true" id="ED.TEXT-4">
            <sch:assert test="not(thumbnail)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no compression">
          <sch:rule abstract="true" id="ED.TEXT-5">
            <sch:assert test="not(@compression)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no translations">
          <sch:rule abstract="true" id="ED.TEXT-6">
            <sch:assert test="not(translation)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="ED">
        <xsd:sequence>
          <xsd:element maxOccurs="0" minOccurs="0" name="data" type="xsd:base64Binary"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="xml" type="xsd:anyType"/>
          <xsd:element minOccurs="0" name="reference" type="TEL.URL"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="integrityCheck" type="xsd:base64Binary"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="thumbnail" type="ED"/>
          <xsd:element minOccurs="0" name="description" type="ST"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="translation" type="ED"/>
        </xsd:sequence>
        <xsd:attribute fixed="text/plain" name="mediaType" type="xsd:string" use="required"/>
        <xsd:attribute name="compression" type="Compression" use="prohibited"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ST">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="no nested translations">
          <sch:rule abstract="true" id="ST-0">
            <sch:assert test="not(translation) or thumbnail[not(translation)]"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="null or content">
          <sch:rule abstract="true" id="ST-1">
            <sch:assert test="(@nullFlavor or (@value and string-length(@value)&amp;gt;0)) and not(@nullFlavor and @value)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="translation" type="ST.NT"/>
        </xsd:sequence>
        <xsd:attribute name="value" type="xsd:string" use="optional"/>
        <xsd:attribute name="language" type="Code" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ST.NT">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="no translations">
          <sch:rule abstract="true" id="ST.NT-0">
            <sch:assert test="not(translation)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <!--<xsd:complexContent>
			<xsd:restriction base="ST">
				<xsd:sequence>
					<xsd:element name="translation" type="ST.NT" minOccurs="0" maxOccurs="0"/>
				</xsd:sequence>
			</xsd:restriction>
		</xsd:complexContent>-->
  </xsd:complexType>
  <xsd:complexType name="ED.IMAGE">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="fixed to image">
          <sch:rule abstract="true" id="ED.IMAGE-0">
            <sch:assert test="starts-with(@mediaType, &quot;image/&quot;)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no text">
          <sch:rule abstract="true" id="ED.IMAGE-1">
            <sch:assert test="not(@value)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no xml">
          <sch:rule abstract="true" id="ED.IMAGE-2">
            <sch:assert test="not(xml)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="ED">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="data" type="xsd:base64Binary"/>
          <xsd:element minOccurs="0" name="xml" type="xsd:anyType"/>
          <xsd:element minOccurs="0" name="reference" type="TEL.URL"/>
          <xsd:element minOccurs="0" name="integrityCheck" type="xsd:base64Binary"/>
          <xsd:element minOccurs="0" name="thumbnail" type="ED"/>
          <xsd:element minOccurs="0" name="description" type="ST"/>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="translation" type="ED"/>
        </xsd:sequence>
        <xsd:attribute name="value" type="xsd:string" use="prohibited"/>
        <xsd:attribute name="mediaType" type="xsd:string" use="required"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ED.DOC">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="mediaType">
          <sch:rule abstract="true" id="ED.DOC-0">
            <sch:assert test="mediaType = &quot;text/plain&quot; or mediaType = &quot;text/html&quot; or mediaType = &quot;text/xml&quot; or mediaType = &quot;application/pdf&quot;"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="ED">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="data" type="xsd:base64Binary"/>
          <xsd:element minOccurs="0" name="xml" type="xsd:anyType"/>
          <xsd:element minOccurs="0" name="reference" type="TEL.URL"/>
          <xsd:element minOccurs="0" name="integrityCheck" type="xsd:base64Binary"/>
          <xsd:element minOccurs="0" name="thumbnail" type="ED"/>
          <xsd:element minOccurs="0" name="description" type="ST"/>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="translation" type="ED"/>
        </xsd:sequence>
        <xsd:attribute name="mediaType" type="xsd:string" use="required"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ED.DOC.REF">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="reference required">
          <sch:rule abstract="true" id="ED.DOC.REF-0">
            <sch:assert test="not(@nullFlavor) or (reference and not(reference/@nullFlavor))"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="ED.DOC">
        <xsd:sequence>
          <xsd:element maxOccurs="0" minOccurs="0" name="data" type="xsd:base64Binary"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="xml" type="xsd:anyType"/>
          <xsd:element minOccurs="0" name="reference" type="TEL.URL"/>
          <xsd:element minOccurs="0" name="integrityCheck" type="xsd:base64Binary"/>
          <xsd:element minOccurs="0" name="thumbnail" type="ED"/>
          <xsd:element minOccurs="0" name="description" type="ST"/>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="translation" type="ED"/>
        </xsd:sequence>
        <xsd:attribute name="value" type="xsd:string" use="prohibited"/>
        <xsd:attribute name="mediaType" type="xsd:string" use="required"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ED.DOC.INLINE">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="no reference">
          <sch:rule abstract="true" id="ED.DOC.INLINE-0">
            <sch:assert test="not(reference)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="ED.DOC">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="data" type="xsd:base64Binary"/>
          <xsd:element minOccurs="0" name="xml" type="xsd:anyType"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="reference" type="TEL.URL"/>
          <xsd:element minOccurs="0" name="integrityCheck" type="xsd:base64Binary"/>
          <xsd:element minOccurs="0" name="thumbnail" type="ED"/>
          <xsd:element minOccurs="0" name="description" type="ST"/>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="translation" type="ED"/>
        </xsd:sequence>
        <xsd:attribute name="mediaType" type="xsd:string" use="required"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ED.SIGNATURE">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="no reference">
          <sch:rule abstract="true" id="ED.SIGNATURE-0">
            <sch:assert test="not(reference)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no value">
          <sch:rule abstract="true" id="ED.SIGNATURE-1">
            <sch:assert test="not(@value)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no data">
          <sch:rule abstract="true" id="ED.SIGNATURE-2">
            <sch:assert test="not(data)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no integrityCheck">
          <sch:rule abstract="true" id="ED.SIGNATURE-3">
            <sch:assert test="not(integrityCheck)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no thumbnail">
          <sch:rule abstract="true" id="ED.SIGNATURE-4">
            <sch:assert test="not(thumbnail)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no compression">
          <sch:rule abstract="true" id="ED.SIGNATURE-5">
            <sch:assert test="not(@compression)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no language">
          <sch:rule abstract="true" id="ED.SIGNATURE-6">
            <sch:assert test="not(@language)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="mediaType">
          <sch:rule abstract="true" id="ED.SIGNATURE-7">
            <sch:assert test="@mediaType = &quot;'text/xml'&quot;"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no translations">
          <sch:rule abstract="true" id="ED.SIGNATURE-8">
            <sch:assert test="not(translation)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="ED">
        <xsd:sequence>
          <xsd:element maxOccurs="0" minOccurs="0" name="data" type="xsd:base64Binary"/>
          <xsd:element minOccurs="0" name="xml" type="xsd:anyType"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="reference" type="TEL.URL"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="integrityCheck" type="xsd:base64Binary"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="thumbnail" type="ED"/>
          <xsd:element minOccurs="0" name="description" type="ST"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="translation" type="ED"/>
        </xsd:sequence>
        <xsd:attribute name="value" type="xsd:string" use="prohibited"/>
        <xsd:attribute fixed="text/xml" name="mediaType" type="xsd:string" use="required"/>
        <xsd:attribute name="language" type="Code" use="prohibited"/>
        <xsd:attribute name="compression" type="Compression" use="prohibited"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ED.STRUCTUREDTEXT">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="mediatype">
          <sch:rule abstract="true" id="ED.STRUCTUREDTEXT-0">
            <sch:assert test="@mediaType = &quot;'text/x-hl7-text+xml'&quot;"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no value">
          <sch:rule abstract="true" id="ED.STRUCTUREDTEXT-1">
            <sch:assert test="not(@value)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no data">
          <sch:rule abstract="true" id="ED.STRUCTUREDTEXT-2">
            <sch:assert test="not(data)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no translations">
          <sch:rule abstract="true" id="ED.STRUCTUREDTEXT-3">
            <sch:assert test="not(translation)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="ED">
        <xsd:sequence>
          <xsd:element maxOccurs="0" minOccurs="0" name="data" type="xsd:base64Binary"/>
          <xsd:element minOccurs="0" name="xml" type="StrucDoc.Text"/>
          <xsd:element minOccurs="0" name="reference" type="TEL.URL"/>
          <xsd:element minOccurs="0" name="integrityCheck" type="xsd:base64Binary"/>
          <xsd:element minOccurs="0" name="thumbnail" type="ED"/>
          <xsd:element minOccurs="0" name="description" type="ST"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="translation" type="ED"/>
        </xsd:sequence>
        <xsd:attribute name="value" type="xsd:string" use="prohibited"/>
        <xsd:attribute fixed="text/x-hl7-text+xml" name="mediaType" type="xsd:string" use="required"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ED.STRUCTUREDTITLE">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="mediatype">
          <sch:rule abstract="true" id="ED.STRUCTUREDTITLE-0">
            <sch:assert test="@mediaType = &quot;'text/x-hl7-text+xml'&quot;"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no value">
          <sch:rule abstract="true" id="ED.STRUCTUREDTITLE-1">
            <sch:assert test="not(@value)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no data">
          <sch:rule abstract="true" id="ED.STRUCTUREDTITLE-2">
            <sch:assert test="not(data)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no translations">
          <sch:rule abstract="true" id="ED.STRUCTUREDTITLE-3">
            <sch:assert test="not(translation)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="ED">
        <xsd:sequence>
          <xsd:element maxOccurs="0" minOccurs="0" name="data" type="xsd:base64Binary"/>
          <xsd:element minOccurs="0" name="xml" type="StrucDoc.Title"/>
          <xsd:element minOccurs="0" name="reference" type="TEL.URL"/>
          <xsd:element minOccurs="0" name="integrityCheck" type="xsd:base64Binary"/>
          <xsd:element minOccurs="0" name="thumbnail" type="ED"/>
          <xsd:element minOccurs="0" name="description" type="ST"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="translation" type="ED"/>
        </xsd:sequence>
        <xsd:attribute name="value" type="xsd:string" use="prohibited"/>
        <xsd:attribute fixed="text/x-hl7-text+xml" name="mediaType" type="xsd:string" use="required"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType mixed="true" name="StrucDoc.Title">
    <xsd:sequence>
      <xsd:choice maxOccurs="unbounded" minOccurs="0">
        <xsd:element name="footnote" type="StrucDoc.TitleFootnote"/>
        <xsd:element name="footnoteRef" type="StrucDoc.FootnoteRef"/>
        <xsd:element name="br" type="StrucDoc.Br"/>
        <xsd:element name="linkHtml" type="StrucDoc.LinkHtml"/>
        <xsd:element name="sub" type="StrucDoc.Sub"/>
        <xsd:element name="sup" type="StrucDoc.Sup"/>
        <xsd:element name="content" type="StrucDoc.CMTitle"/>
      </xsd:choice>
    </xsd:sequence>
    <xsd:attributeGroup ref="StrucDoc.Base"/>
  </xsd:complexType>
  <xsd:complexType mixed="true" name="StrucDoc.TitleFootnote">
    <xsd:sequence>
      <xsd:choice maxOccurs="unbounded" minOccurs="0">
        <xsd:element name="footnote" type="StrucDoc.TitleFootnote"/>
        <xsd:element name="footnoteRef" type="StrucDoc.FootnoteRef"/>
        <xsd:element name="br" type="StrucDoc.Br"/>
        <xsd:element name="linkHtml" type="StrucDoc.LinkHtml"/>
        <xsd:element name="sub" type="StrucDoc.Sub"/>
        <xsd:element name="sup" type="StrucDoc.Sup"/>
        <xsd:element name="content" type="StrucDoc.CMTitle"/>
      </xsd:choice>
    </xsd:sequence>
    <xsd:attributeGroup ref="StrucDoc.Base"/>
  </xsd:complexType>
  <xsd:complexType mixed="true" name="StrucDoc.CMTitle">
    <xsd:sequence>
      <xsd:element minOccurs="0" name="footnote" type="StrucDoc.TitleFootnote"/>
      <xsd:element minOccurs="0" name="footnoteRef" type="StrucDoc.FootnoteRef"/>
      <xsd:element minOccurs="0" name="br" type="StrucDoc.Br"/>
      <xsd:element minOccurs="0" name="linkHtml" type="StrucDoc.LinkHtml"/>
      <xsd:element minOccurs="0" name="sub" type="StrucDoc.Sub"/>
      <xsd:element minOccurs="0" name="sup" type="StrucDoc.Sup"/>
      <xsd:element minOccurs="0" name="content" type="StrucDoc.CMTitle"/>
    </xsd:sequence>
  </xsd:complexType>
  <xsd:complexType name="SC">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="no code if no value">
          <sch:rule abstract="true" id="SC-0">
            <sch:assert test="not(@nullFlavor) or (not(code) or (code/@nullFlavor))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on SC attributes">
          <sch:rule abstract="true" id="SC-1">
            <sch:assert test="count(*[self::code][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no originalText">
          <sch:rule abstract="true" id="SC-2">
            <sch:assert test="(not(originalText) or not(oroginalText/@nullFlavor)) or (not(code) or (code/@nullFlavor))"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ST">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="code" type="CD"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="CD">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or code and/or originalText">
          <sch:rule abstract="true" id="CD-0">
            <sch:assert test="@nullFlavor or @code or (originalText and not(originalText/@nullFlavor) or (originalTextReference and not(originalTextReference/@nullFlavor))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="other requires codeSystem or valueSet">
          <sch:rule abstract="true" id="CD-1">
            <sch:assert test="@nullFlavor != &quot;OTH&quot; or @codeSystem or @valueSet"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="code requires codeSystem">
          <sch:rule abstract="true" id="CD-2">
            <sch:assert test="@codeSystem or not(@code)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="codeSystemName only if codeSystem">
          <sch:rule abstract="true" id="CD-3">
            <sch:assert test="@codeSystem or not(@codeSystemName)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="codeSystemVersion only if codeSystem">
          <sch:rule abstract="true" id="CD-4">
            <sch:assert test="@codeSystem or not(@codeSystemVersion)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="displayName only if code">
          <sch:rule abstract="true" id="CD-5">
            <sch:assert test="@code or not(@displayName)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="valueSet requires valueSetVersion">
          <sch:rule abstract="true" id="CD-6">
            <sch:assert test="not(@valueSet) or (@valueSet and @valueSetVersion)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="No original text on translations">
          <sch:rule abstract="true" id="CD-7">
            <sch:assert test="not translation/originalText"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="Translations cannot have translations">
          <sch:rule abstract="true" id="CD-8">
            <sch:assert test="not translation/translation"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on CD elements">
          <sch:rule abstract="true" id="CD-9">
            <sch:assert test="count(*[self::displayName or self::originalText or self::originalTextReference or self::translation][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no code if null">
          <sch:rule abstract="true" id="CD-10">
            <sch:assert test="not(@nullFlavor) or (not(thumbnail) or code\@nullFlavor)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no displayName if null">
          <sch:rule abstract="true" id="CD-11">
            <sch:assert test="not(@nullFlavor) or (@nullFlavor and not(@displayName))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no source if null">
          <sch:rule abstract="true" id="CD-12">
            <sch:assert test="not(@nullFlavor) or (@nullFlavor and not(@source))"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="displayName" type="ST"/>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="translation" type="CD"/>
          <xsd:element minOccurs="0" name="source" type="XReference"/>
        </xsd:sequence>
        <xsd:attribute name="code" type="xsd:string" use="optional"/>
        <xsd:attribute name="codeSystem" type="Uid" use="optional"/>
        <xsd:attribute name="codeSystemName" type="xsd:string" use="optional"/>
        <xsd:attribute name="codeSystemVersion" type="xsd:string" use="optional"/>
        <xsd:attribute name="valueSet" type="xsd:string" use="optional"/>
        <xsd:attribute name="valueSetVersion" type="xsd:string" use="optional"/>
        <xsd:attribute name="codingRationale" type="set_CodingRationale" use="optional"/>
        <xsd:attribute name="id" type="xsd:ID" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="XReference">
    <xsd:attribute name="xref" type="xsd:IDREF" use="required"/>
  </xsd:complexType>
  <xsd:complexType name="SC.NT">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="no translations">
          <sch:rule abstract="true" id="SC.NT-0">
            <sch:assert test="not(translation)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="SC">
        <xsd:sequence>
          <xsd:element maxOccurs="0" minOccurs="0" name="translation" type="ST.NT"/>
          <xsd:element minOccurs="0" name="code" type="CD"/>
        </xsd:sequence>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="TEL.EMAIL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="email only">
          <sch:rule abstract="true" id="TEL.EMAIL-0">
            <sch:assert test="starts-with(@value, &quot;mailto&quot;)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="TEL.PERSON">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="useablePeriod" type="QSET_TS"/>
        </xsd:sequence>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="TEL.PERSON">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="Personal Address">
          <sch:rule abstract="true" id="TEL.PERSON-0">
            <sch:assert test="starts-with(@value, &quot;tel&quot;) or starts-with(@value, &quot;x-text-fax&quot;) or starts-with(@value, &quot;x-text-tel&quot;) or starts-with(@value, &quot;mailto&quot;)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="TEL">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="useablePeriod" type="QSET_TS"/>
        </xsd:sequence>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="TEL.PHONE">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="Phone">
          <sch:rule abstract="true" id="TEL.PHONE-0">
            <sch:assert test="starts-with(@value, &quot;tel&quot;) or starts-with(@value, &quot;x-text-fax&quot;) or starts-with(@value, &quot;x-text-tel&quot;)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="TEL.PERSON">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="useablePeriod" type="QSET_TS"/>
        </xsd:sequence>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="II">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="root is required">
          <sch:rule abstract="true" id="II-0">
            <sch:assert test="@nullFlavor or (not(@nullFlavor) and @root)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no root if null">
          <sch:rule abstract="true" id="II-1">
            <sch:assert test="not(@nullFlavor) or (@nullFlavor and not(@root))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no extension if null">
          <sch:rule abstract="true" id="II-2">
            <sch:assert test="not(@nullFlavor) or (@nullFlavor and not(@extension))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no identifierName if null">
          <sch:rule abstract="true" id="II-3">
            <sch:assert test="not(@nullFlavor) or (@nullFlavor and not(@identifierName))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no displayable if null">
          <sch:rule abstract="true" id="II-4">
            <sch:assert test="not(@nullFlavor) or (@nullFlavor and not(@displayable))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no reliability if null">
          <sch:rule abstract="true" id="II-5">
            <sch:assert test="not(@nullFlavor) or (@nullFlavor and not(@reliability))"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:attribute name="root" type="Uid" use="optional"/>
        <xsd:attribute name="extension" type="xsd:string" use="optional"/>
        <xsd:attribute name="identifierName" type="xsd:string" use="optional"/>
        <xsd:attribute name="displayable" type="xsd:boolean" use="optional"/>
        <xsd:attribute name="scope" type="IdentifierScope" use="optional"/>
        <xsd:attribute name="reliability" type="IdentifierReliability" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="CD.CV">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="no translations">
          <sch:rule abstract="true" id="CD.CV-0">
            <sch:assert test="not(translation)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no source">
          <sch:rule abstract="true" id="CD.CV-1">
            <sch:assert test="not(@source)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="CD">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="displayName" type="ST"/>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="translation" type="CD"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="source" type="XReference"/>
        </xsd:sequence>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="CO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="must have a code or a value">
          <sch:rule abstract="true" id="CO-0">
            <sch:assert test="@nullFlavor or (@value or (code and not(code/@nullFlavor)))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="CO-1">
            <sch:assert test="count(*[self::code][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no value if null">
          <sch:rule abstract="true" id="CO-2">
            <sch:assert test="not(@nullFlavor) or (@nullFlavor and not(@value))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no code if null">
          <sch:rule abstract="true" id="CO-3">
            <sch:assert test="not(@nullFlavor) or (not code or code/@nullFlavor)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QTY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="code" type="CD"/>
        </xsd:sequence>
        <xsd:attribute name="value" type="xsd:double" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="QTY">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="uncertainty">
          <sch:rule abstract="true" id="QTY-0">
            <sch:assert test="not(uncertainty/@expression) and not(uncertainty/@uncertainty) and not(uncertainty/@originalText)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="QTY-1">
            <sch:assert test="count(*[self::originalText or self::uncertainty or self::expression][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="expression" type="ED"/>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element minOccurs="0" name="uncertainty" type="QTY"/>
        </xsd:sequence>
        <xsd:attribute name="uncertaintyType" type="UncertaintyType" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="CS">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="code is required">
          <sch:rule abstract="true" id="CS-0">
            <sch:assert test="@nullFlavor or (not(@nullFlavor) and @code)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no code if null">
          <sch:rule abstract="true" id="CS-1">
            <sch:assert test="not(@nullFlavor) or (@nullFlavor and not(@code))"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:attribute name="code" type="xsd:string" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="AD">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or parts">
          <sch:rule abstract="true" id="AD-0">
            <sch:assert test="(@nullFlavor or part) and not(@nullFlavor and part)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no useablePeriod if null">
          <sch:rule abstract="true" id="AD-1">
            <sch:assert test="not(@nullFlavor) or (not(thumbnail) or useablePeriod\@nullFlavor)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on AD attributes">
          <sch:rule abstract="true" id="AD-2">
            <sch:assert test="count(*[self::useablePeriod][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:choice maxOccurs="unbounded" minOccurs="0">
            <xsd:element name="part" type="ADXP"/>
            <xsd:element name="br" type="ADXP.BR"/>
            <xsd:element name="addressLine" type="ADXP.AL"/>
            <xsd:element name="additionalLocator" type="ADXP.ADL"/>
            <xsd:element name="unitID" type="ADXP.UNID"/>
            <xsd:element name="unitType" type="ADXP.UNIT"/>
            <xsd:element name="deliveryAddressLine" type="ADXP.DAL"/>
            <xsd:element name="deliveryInstallationType" type="ADXP.DINST"/>
            <xsd:element name="deliveryInstallationArea" type="ADXP.DINSTA"/>
            <xsd:element name="deliveryInstallationQualifier" type="ADXP.DINSTQ"/>
            <xsd:element name="deliveryMode" type="ADXP.DMOD"/>
            <xsd:element name="deliveryModeIdentifier" type="ADXP.DMODID"/>
            <xsd:element name="streetAddressLine" type="ADXP.SAL"/>
            <xsd:element name="houseNumber" type="ADXP.BNR"/>
            <xsd:element name="houseNumberNumeric" type="ADXP.BNN"/>
            <xsd:element name="buildingNumberSuffix" type="ADXP.BNS"/>
            <xsd:element name="streetName" type="ADXP.STR"/>
            <xsd:element name="streetNameBase" type="ADXP.STB"/>
            <xsd:element name="streetType" type="ADXP.STTYP"/>
            <xsd:element name="intersection" type="ADXP.INT"/>
            <xsd:element name="direction" type="ADXP.DIR"/>
            <xsd:element name="careOf" type="ADXP.CAR"/>
            <xsd:element name="censusTract" type="ADXP.CEN"/>
            <xsd:element name="country" type="ADXP.CNT"/>
            <xsd:element name="county" type="ADXP.CPA"/>
            <xsd:element name="city" type="ADXP.CTY"/>
            <xsd:element name="postBox" type="ADXP.POB"/>
            <xsd:element name="precinct" type="ADXP.PRE"/>
            <xsd:element name="state" type="ADXP.STA"/>
            <xsd:element name="postalCode" type="ADXP.ZIP"/>
          </xsd:choice>
          <xsd:element minOccurs="0" name="useablePeriod" type="QSET_TS"/>
        </xsd:sequence>
        <xsd:attribute name="use" type="set_PostalAddressUse" use="optional"/>
        <xsd:attribute name="isNotOrdered" type="xsd:boolean" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType mixed="true" name="ADXP">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="value is required">
          <sch:rule abstract="true" id="ADXP-0">
            <sch:assert test="string-length(@value) > 0"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="code requires codeSystem">
          <sch:rule abstract="true" id="ADXP-1">
            <sch:assert test="@codeSystem or not(@code)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="codeSystemVersion only if codeSystem">
          <sch:rule abstract="true" id="ADXP-2">
            <sch:assert test="@codeSystem or not(@codeSystemVersion)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:attribute name="code" type="xsd:string" use="optional"/>
    <xsd:attribute name="codeSystem" type="xsd:string" use="optional"/>
    <xsd:attribute name="codeSystemVersion" type="xsd:string" use="optional"/>
    <xsd:attribute name="language" type="Code" use="optional"/>
    <xsd:attribute name="type" type="AddressPartType" use="optional"/>
  </xsd:complexType>
  <xsd:complexType name="ADXP.BR">
    <xsd:complexContent>
      <xsd:restriction base="ADXP">
        <xsd:attribute fixed="DEL" name="type" type="AddressPartType"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ADXP.AL">
    <xsd:complexContent>
      <xsd:restriction base="ADXP">
        <xsd:attribute fixed="AL" name="type" type="AddressPartType"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ADXP.ADL">
    <xsd:complexContent>
      <xsd:restriction base="ADXP">
        <xsd:attribute fixed="ADL" name="type" type="AddressPartType"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ADXP.UNID">
    <xsd:complexContent>
      <xsd:restriction base="ADXP">
        <xsd:attribute fixed="UNID" name="type" type="AddressPartType"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ADXP.UNIT">
    <xsd:complexContent>
      <xsd:restriction base="ADXP">
        <xsd:attribute fixed="UNIT" name="type" type="AddressPartType"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ADXP.DAL">
    <xsd:complexContent>
      <xsd:restriction base="ADXP">
        <xsd:attribute fixed="DAL" name="type" type="AddressPartType"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ADXP.DINST">
    <xsd:complexContent>
      <xsd:restriction base="ADXP">
        <xsd:attribute fixed="DINST" name="type" type="AddressPartType"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ADXP.DINSTA">
    <xsd:complexContent>
      <xsd:restriction base="ADXP">
        <xsd:attribute fixed="DINSTA" name="type" type="AddressPartType"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ADXP.DINSTQ">
    <xsd:complexContent>
      <xsd:restriction base="ADXP">
        <xsd:attribute fixed="DINSTQ" name="type" type="AddressPartType"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ADXP.DMOD">
    <xsd:complexContent>
      <xsd:restriction base="ADXP">
        <xsd:attribute fixed="DMOD" name="type" type="AddressPartType"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ADXP.DMODID">
    <xsd:complexContent>
      <xsd:restriction base="ADXP">
        <xsd:attribute fixed="DMODID" name="type" type="AddressPartType"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ADXP.SAL">
    <xsd:complexContent>
      <xsd:restriction base="ADXP">
        <xsd:attribute fixed="SAL" name="type" type="AddressPartType"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ADXP.BNR">
    <xsd:complexContent>
      <xsd:restriction base="ADXP">
        <xsd:attribute fixed="BNR" name="type" type="AddressPartType"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ADXP.BNN">
    <xsd:complexContent>
      <xsd:restriction base="ADXP">
        <xsd:attribute fixed="BNN" name="type" type="AddressPartType"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ADXP.BNS">
    <xsd:complexContent>
      <xsd:restriction base="ADXP">
        <xsd:attribute fixed="BNS" name="type" type="AddressPartType"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ADXP.STR">
    <xsd:complexContent>
      <xsd:restriction base="ADXP">
        <xsd:attribute fixed="STR" name="type" type="AddressPartType"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ADXP.STB">
    <xsd:complexContent>
      <xsd:restriction base="ADXP">
        <xsd:attribute fixed="STB" name="type" type="AddressPartType"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ADXP.STTYP">
    <xsd:complexContent>
      <xsd:restriction base="ADXP">
        <xsd:attribute fixed="STTYP" name="type" type="AddressPartType"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ADXP.INT">
    <xsd:complexContent>
      <xsd:restriction base="ADXP">
        <xsd:attribute fixed="INT" name="type" type="AddressPartType"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ADXP.DIR">
    <xsd:complexContent>
      <xsd:restriction base="ADXP">
        <xsd:attribute fixed="DIR" name="type" type="AddressPartType"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ADXP.CAR">
    <xsd:complexContent>
      <xsd:restriction base="ADXP">
        <xsd:attribute fixed="CAR" name="type" type="AddressPartType"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ADXP.CEN">
    <xsd:complexContent>
      <xsd:restriction base="ADXP">
        <xsd:attribute fixed="CEN" name="type" type="AddressPartType"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ADXP.CNT">
    <xsd:complexContent>
      <xsd:restriction base="ADXP">
        <xsd:attribute fixed="CNT" name="type" type="AddressPartType"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ADXP.CPA">
    <xsd:complexContent>
      <xsd:restriction base="ADXP">
        <xsd:attribute fixed="CPA" name="type" type="AddressPartType"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ADXP.CTY">
    <xsd:complexContent>
      <xsd:restriction base="ADXP">
        <xsd:attribute fixed="CTY" name="type" type="AddressPartType"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ADXP.POB">
    <xsd:complexContent>
      <xsd:restriction base="ADXP">
        <xsd:attribute fixed="POB" name="type" type="AddressPartType"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ADXP.PRE">
    <xsd:complexContent>
      <xsd:restriction base="ADXP">
        <xsd:attribute fixed="PRE" name="type" type="AddressPartType"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ADXP.STA">
    <xsd:complexContent>
      <xsd:restriction base="ADXP">
        <xsd:attribute fixed="STA" name="type" type="AddressPartType"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ADXP.ZIP">
    <xsd:complexContent>
      <xsd:restriction base="ADXP">
        <xsd:attribute fixed="ZIP" name="type" type="AddressPartType"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="EN">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or parts">
          <sch:rule abstract="true" id="EN-0">
            <sch:assert test="(@nullFlavor or part) and not(@nullFlavor and part)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="part" type="ENXP"/>
        </xsd:sequence>
        <xsd:attribute name="use" type="set_EntityNameUse" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ENXP">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="value is required">
          <sch:rule abstract="true" id="ENXP-0">
            <sch:assert test="string-length(@value) > 0"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="code requires codeSystem">
          <sch:rule abstract="true" id="ENXP-1">
            <sch:assert test="@codeSystem or not(@code)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="codeSystemVersion only if codeSystem">
          <sch:rule abstract="true" id="ENXP-2">
            © 229
ISO 2008  All rights reserved
            <sch:assert test="@codeSystem or not(@codeSystemVersion)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:attribute name="value" type="xsd:string" use="optional"/>
    <xsd:attribute name="code" type="xsd:string" use="optional"/>
    <xsd:attribute name="codeSystem" type="xsd:string" use="optional"/>
    <xsd:attribute name="codeSystemVersion" type="xsd:string" use="optional"/>
    <xsd:attribute name="language" type="Code" use="optional"/>
    <xsd:attribute name="type" type="EntityNamePartType" use="optional"/>
    <xsd:attribute name="qualifier" type="set_EntityNamePartQualifier" use="optional"/>
  </xsd:complexType>
  <xsd:complexType name="EN.TN">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="only one part with no type">
          <sch:rule abstract="true" id="EN.TN-0">
            <sch:assert test="@nullFlavor or (count(part) = 1 and not part/@type)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="EN"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="EN.PN">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="no parts are qualified by LS">
          <sch:rule abstract="true" id="EN.PN-0">
            <sch:assert test="count(part[contains(@qualifier, 'LS')])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="EN"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="EN.ON">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="no parts are person types">
          <sch:rule abstract="true" id="EN.ON-0">
            <sch:assert test="count(part[type = 'FAM' or type = 'GIV'])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="EN"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="TS">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or value">
          <sch:rule abstract="true" id="TS-0">
            <sch:assert test="(@nullFlavor or @value) and not(@nullFlavor and @value)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QTY">
        <xsd:attribute name="value" use="optional">
          <xsd:simpleType>
            <xsd:restriction base="xsd:string">
              <xsd:pattern value="[1-2][0-9]{3,3}(((0[1-9])|(1[0-2]))(((0[1-9])|([1-2][0-9]|3[0-1]))(([0-1][0-9]|2[0-3])([0-5][0-9]([0-5][0-9](\.[0-9]{1,4})?)?)?)?)?)?([+\-](0[0-9]|1[0-3])([0-5][0-9]))?"/>
              <!--Svensk rättning: Original string<xsd:pattern value="[1-2][0-9]{3,3}(((0[1-9])|(1[0-2]))((0[1-9])|([1-2][0-9]|3[0-1])(([0-1][0-9]|2[0-3])([0-5][0-9]([0-5][0-9](\.[0-9]{1,4})?)?)?)?)?)?([+\-](0[0-9]|1[0-3])([0-5][0-9]))?"/>-->
            </xsd:restriction>
          </xsd:simpleType>
        </xsd:attribute>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="TS.DATE">
    <xsd:complexContent>
      <xsd:restriction base="TS">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="expression" type="ED"/>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element minOccurs="0" name="uncertainty" type="QTY"/>
        </xsd:sequence>
      </xsd:restriction>
      <!--<xsd:attribute name="value" use="optional">
					<xsd:simpleType>
						<xsd:restriction base="xsd:string">
							<xsd:pattern value="[1-2][0-9]{3,3}((0[1-9])|(1[0-2])((0[1-9])|([1-2][0-9]|3[0-1]))?)?"/>
						</xsd:restriction>
					</xsd:simpleType>
				</xsd:attribute>-->
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="TS.DATE.FULL">
    <xsd:complexContent>
      <xsd:restriction base="TS.DATE">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="expression" type="ED"/>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element minOccurs="0" name="uncertainty" type="QTY"/>
        </xsd:sequence>
      </xsd:restriction>
      <!--<xsd:attribute name="value" use="optional">
					<xsd:simpleType>
						<xsd:restriction base="xsd:string">
							<xsd:pattern value="([1-2][0-9]{3,3}(0[1-9])|(1[0-2]))(0[1-9])|([1-2][0-9]|3[0-1])"/>
						</xsd:restriction>
					</xsd:simpleType>
				</xsd:attribute>-->
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="TS.DATETIME">
    <xsd:complexContent>
      <xsd:restriction base="TS">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="expression" type="ED"/>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element minOccurs="0" name="uncertainty" type="QTY"/>
        </xsd:sequence>
      </xsd:restriction>
      <!--<xsd:attribute name="value" use="optional">
					<xsd:simpleType>
						<xsd:restriction base="xsd:string">
							<xsd:pattern value="[1-2][0-9]{3,3}(((0[1-9])|(1[0-2]))((0[1-9])|([1-2][0-9]|3[0-1])(([0-1][0-9]|2[0-3])([0-5][0-9]([0-5][0-9])?)?)?)?)?([+\-](0[0-9]|1[0-3])([0-5][0-9]))?"/>
						</xsd:restriction>
					</xsd:simpleType>
				</xsd:attribute>-->
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="TS.DATETIME.FULL">
    <xsd:complexContent>
      <xsd:restriction base="TS.DATETIME">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="expression" type="ED"/>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element minOccurs="0" name="uncertainty" type="QTY"/>
        </xsd:sequence>
      </xsd:restriction>
      <!--<xsd:attribute name="value" use="optional">
					<xsd:simpleType>
						<xsd:restriction base="xsd:string">
							<xsd:pattern value="[1-2][0-9]{3,3}(0[1-9])|(1[0-2])(0[1-9])|([1-2][0-9]|3[0-1])([0-1][0-9]|2[0-3])[0-5][0-9][0-5][0-9]([+\-](0[0-9]|1[0-3])([0-5][0-9]))?"/>
						</xsd:restriction>
					</xsd:simpleType>
				</xsd:attribute>-->
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="TS.BIRTH">
    <xsd:complexContent>
      <xsd:restriction base="TS">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="expression" type="ED"/>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element minOccurs="0" name="uncertainty" type="QTY"/>
        </xsd:sequence>
      </xsd:restriction>
      <!--<xsd:attribute name="value" use="optional">
					<xsd:simpleType>
						<xsd:restriction base="xsd:string">
							<xsd:pattern value="[1-2][0-9]{3,3}(((0[1-9])|(1[0-2]))(0[1-9])|([1-2][0-9]|3[0-1])(([0-1][0-9]|2[0-3])([0-5][0-9]([0-5][0-9]))[+\-](0[0-9]|1[0-3])([0-5][0-9]))?)?"/>
						</xsd:restriction>
					</xsd:simpleType>
				</xsd:attribute>-->
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="RTO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="numerator and denominator required">
          <sch:rule abstract="true" id="RTO-0">
            <sch:assert test="@nullFlavor or ((numerator and not(numerator/@nullFlavor)) and (numerator and not(numerator/@nullFlavor)))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on RTO Attributes">
          <sch:rule abstract="true" id="RTO-1">
            <sch:assert test="count(*[self::numerator or self::denominator][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no uncertainty">
          <sch:rule abstract="true" id="RTO-2">
            <sch:assert test="not(uncertainty)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QTY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="numerator" type="QTY"/>
          <xsd:element minOccurs="0" name="denominator" type="QTY"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="MO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or value">
          <sch:rule abstract="true" id="MO-0">
            <sch:assert test="(@nullFlavor or @value) and not(@nullFlavor and @value)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="null or currency">
          <sch:rule abstract="true" id="MO-1">
            <sch:assert test="(@nullFlavor or @currency) and not(@nullFlavor and @currency)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no precision if null">
          <sch:rule abstract="true" id="MO-2">
            <sch:assert test="not(@nullFlavor) or (@nullFlavor and not(@precision))"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QTY">
        <xsd:attribute name="value" type="xsd:double" use="optional"/>
        <xsd:attribute name="precision" type="xsd:int" use="optional"/>
        <xsd:attribute name="currency" type="Code" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="PQ">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="no translation if null">
          <sch:rule abstract="true" id="PQ-0">
            <sch:assert test="not(@nullFlavor) or (@nullFlavor and not(@translation))"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="PQV">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="translation" type="PQR"/>
        </xsd:sequence>
        <xsd:attribute name="unit" type="Code" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="PQV">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or value">
          <sch:rule abstract="true" id="PQV-0">
            <sch:assert test="(@nullFlavor or @value) and not(@nullFlavor and @value)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no precision if null">
          <sch:rule abstract="true" id="PQV-1">
            <sch:assert test="not(@nullFlavor) or (@nullFlavor and not(@precision))"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QTY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="source" type="XReference"/>
        </xsd:sequence>
        <xsd:attribute name="value" type="xsd:double" use="optional"/>
        <xsd:attribute default="0" name="precision" type="xsd:int" use="optional"/>
        <xsd:attribute name="codingRationale" type="set_CodingRationale" use="optional"/>
        <xsd:attribute name="id" type="xsd:ID" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="PQR">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or unit">
          <sch:rule abstract="true" id="PQR-0">
            <sch:assert test="todo"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no originalText">
          <sch:rule abstract="true" id="PQR-1">
            <sch:assert test="not(@originalText)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on PQR">
          <sch:rule abstract="true" id="PQR-2">
            <sch:assert test="not(@validTimeLow) and not(@validTimeHigh) and not(@controlActRoot) and not(@controlActExtension) and not(@updateMode)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="PQV">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="unit" type="CD.CV"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="PQ.TIME">
    <xsd:complexContent>
      <xsd:restriction base="PQ">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="expression" type="ED"/>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element minOccurs="0" name="uncertainty" type="QTY"/>
          <xsd:element minOccurs="0" name="source" type="XReference"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="translation" type="PQR"/>
        </xsd:sequence>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="REAL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or value">
          <sch:rule abstract="true" id="REAL-0">
            <sch:assert test="(@nullFlavor or @value) and not(@nullFlavor and @value)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no precision if null">
          <sch:rule abstract="true" id="REAL-1">
            <sch:assert test="not(@nullFlavor) or (@nullFlavor and not(@precision))"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QTY">
        <xsd:attribute name="value" type="xsd:double" use="optional"/>
        <xsd:attribute default="0" name="precision" type="xsd:int" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="INT">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="no uncertainty">
          <sch:rule abstract="true" id="INT-0">
            <sch:assert test="not(uncertainty)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="null or value">
          <sch:rule abstract="true" id="INT-1">
            <sch:assert test="(@nullFlavor or @value) and not(@nullFlavor and @value)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QTY">
        <xsd:attribute name="value" type="xsd:int" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="INT.NONNEG">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not negative">
          <sch:rule abstract="true" id="INT.NONNEG-0">
            <sch:assert test="(@nullFlavor) or (@value >= 0)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="INT">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="expression" type="ED"/>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element minOccurs="0" name="uncertainty" type="QTY"/>
        </xsd:sequence>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="INT.POS">
    <xsd:complexContent>
      <xsd:restriction base="INT.NONNEG">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="expression" type="ED"/>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element minOccurs="0" name="uncertainty" type="QTY"/>
        </xsd:sequence>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="DSET_BL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="DSET_BL-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_BL">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="BL"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="COLL_BL">
    <xsd:complexContent>
      <xsd:extension base="ANY"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="DSET_BL.NONNULL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="DSET_BL.NONNULL-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
        © 235
ISO 2008  All rights reserved
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_BL.NONNULL">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="BL.NONNULL"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="COLL_BL.NONNULL">
    <xsd:complexContent>
      <xsd:extension base="ANY"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="DSET_ED">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="DSET_ED-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_ED">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="ED"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="COLL_ED">
    <xsd:complexContent>
      <xsd:extension base="ANY"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="DSET_ED.IMAGE">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="DSET_ED.IMAGE-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_ED.IMAGE">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="ED.IMAGE"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="COLL_ED.IMAGE">
    <xsd:complexContent>
      <xsd:extension base="ANY"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="DSET_ED.TEXT">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="DSET_ED.TEXT-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_ED.TEXT">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="ED.TEXT"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="COLL_ED.TEXT">
    <xsd:complexContent>
      <xsd:extension base="ANY"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="DSET_ED.DOC">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="DSET_ED.DOC-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_ED.DOC">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="ED.DOC"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="COLL_ED.DOC">
    <xsd:complexContent>
      <xsd:extension base="ANY"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="DSET_ED.DOC.REF">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="DSET_ED.DOC.REF-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_ED.DOC.REF">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="ED.DOC.REF"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="COLL_ED.DOC.REF">
    <xsd:complexContent>
      <xsd:extension base="ANY"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="DSET_ED.DOC.INLINE">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="DSET_ED.DOC.INLINE-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_ED.DOC.INLINE">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="ED.DOC.INLINE"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="COLL_ED.DOC.INLINE">
    <xsd:complexContent>
      <xsd:extension base="ANY"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="DSET_ED.SIGNATURE">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="DSET_ED.SIGNATURE-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_ED.SIGNATURE">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="ED.SIGNATURE"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="COLL_ED.SIGNATURE">
    <xsd:complexContent>
      <xsd:extension base="ANY"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="DSET_ED.STRUCTUREDTEXT">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="DSET_ED.STRUCTUREDTEXT-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_ED.STRUCTUREDTEXT">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="ED.STRUCTUREDTEXT"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="COLL_ED.STRUCTUREDTEXT">
    <xsd:complexContent>
      <xsd:extension base="ANY"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="DSET_ED.STRUCTUREDTITLE">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="DSET_ED.STRUCTUREDTITLE-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_ED.STRUCTUREDTITLE">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="ED.STRUCTUREDTITLE"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="COLL_ED.STRUCTUREDTITLE">
    <xsd:complexContent>
      <xsd:extension base="ANY"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="DSET_ST">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="DSET_ST-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_ST">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="ST"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="COLL_ST">
    <xsd:complexContent>
      <xsd:extension base="ANY"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="DSET_ST.NT">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="DSET_ST.NT-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_ST.NT">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="ST.NT"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="COLL_ST.NT">
    <xsd:complexContent>
      <xsd:extension base="ANY"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="DSET_SC">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="DSET_SC-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_SC">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="SC"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="COLL_SC">
    <xsd:complexContent>
      <xsd:extension base="ANY"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="DSET_SC.NT">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="DSET_SC.NT-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_SC.NT">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="SC.NT"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="COLL_SC.NT">
    <xsd:complexContent>
      <xsd:extension base="ANY"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="DSET_TEL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="DSET_TEL-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_TEL">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="TEL"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="COLL_TEL">
    <xsd:complexContent>
      <xsd:extension base="ANY"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="DSET_TEL.EMAIL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="DSET_TEL.EMAIL-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_TEL.EMAIL">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="TEL.EMAIL"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="COLL_TEL.EMAIL">
    <xsd:complexContent>
      <xsd:extension base="ANY"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="DSET_TEL.PERSON">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="DSET_TEL.PERSON-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_TEL.PERSON">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="TEL.PERSON"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="COLL_TEL.PERSON">
    <xsd:complexContent>
      <xsd:extension base="ANY"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="DSET_TEL.PHONE">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="DSET_TEL.PHONE-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_TEL.PHONE">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="TEL.PHONE"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="COLL_TEL.PHONE">
    <xsd:complexContent>
      <xsd:extension base="ANY"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="DSET_TEL.URL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="DSET_TEL.URL-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_TEL.URL">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="TEL.URL"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="COLL_TEL.URL">
    <xsd:complexContent>
      <xsd:extension base="ANY"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="DSET_II">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="DSET_II-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_II">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="II"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="COLL_II">
    <xsd:complexContent>
      <xsd:extension base="ANY"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="DSET_CD">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="DSET_CD-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_CD">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="CD"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="COLL_CD">
    <xsd:complexContent>
      <xsd:extension base="ANY"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="DSET_CD.CV">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="DSET_CD.CV-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_CD.CV">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="CD.CV"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="COLL_CD.CV">
    <xsd:complexContent>
      <xsd:extension base="ANY"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="DSET_CO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="DSET_CO-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_CO">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="CO"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="COLL_CO">
    <xsd:complexContent>
      <xsd:extension base="ANY"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="DSET_CS">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="DSET_CS-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_CS">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="CS"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="COLL_CS">
    <xsd:complexContent>
      <xsd:extension base="ANY"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="DSET_AD">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="DSET_AD-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_AD">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="AD"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="COLL_AD">
    <xsd:complexContent>
      <xsd:extension base="ANY"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="DSET_EN">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="DSET_EN-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_EN">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="EN"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="COLL_EN">
    <xsd:complexContent>
      <xsd:extension base="ANY"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="DSET_EN.TN">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="DSET_EN.TN-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_EN.TN">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="EN.TN"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="COLL_EN.TN">
    <xsd:complexContent>
      <xsd:extension base="ANY"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="DSET_EN.PN">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="DSET_EN.PN-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_EN.PN">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="EN.PN"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="COLL_EN.PN">
    <xsd:complexContent>
      <xsd:extension base="ANY"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="DSET_EN.ON">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="DSET_EN.ON-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_EN.ON">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="EN.ON"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="COLL_EN.ON">
    <xsd:complexContent>
      <xsd:extension base="ANY"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="DSET_TS">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="DSET_TS-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_TS">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="TS"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="COLL_TS">
    <xsd:complexContent>
      <xsd:extension base="ANY"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="DSET_TS.DATE">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="DSET_TS.DATE-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_TS.DATE">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="TS.DATE"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="COLL_TS.DATE">
    <xsd:complexContent>
      <xsd:extension base="ANY"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="DSET_TS.DATE.FULL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="DSET_TS.DATE.FULL-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_TS.DATE.FULL">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="TS.DATE.FULL"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="COLL_TS.DATE.FULL">
    <xsd:complexContent>
      <xsd:extension base="ANY"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="DSET_TS.DATETIME">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="DSET_TS.DATETIME-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_TS.DATETIME">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="TS.DATETIME"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="COLL_TS.DATETIME">
    <xsd:complexContent>
      <xsd:extension base="ANY"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="DSET_TS.DATETIME.FULL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="DSET_TS.DATETIME.FULL-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_TS.DATETIME.FULL">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="TS.DATETIME.FULL"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="COLL_TS.DATETIME.FULL">
    <xsd:complexContent>
      <xsd:extension base="ANY"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="DSET_TS.BIRTH">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="DSET_TS.BIRTH-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_TS.BIRTH">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="TS.BIRTH"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="COLL_TS.BIRTH">
    <xsd:complexContent>
      <xsd:extension base="ANY"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="DSET_RTO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="DSET_RTO-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_RTO">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="RTO"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="COLL_RTO">
    <xsd:complexContent>
      <xsd:extension base="ANY"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="DSET_MO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="DSET_MO-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_MO">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="MO"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="COLL_MO">
    <xsd:complexContent>
      <xsd:extension base="ANY"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="DSET_PQ">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="DSET_PQ-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_PQ">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="PQ"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="COLL_PQ">
    <xsd:complexContent>
      <xsd:extension base="ANY"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="DSET_PQ.TIME">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="DSET_PQ.TIME-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_PQ.TIME">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="PQ.TIME"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="COLL_PQ.TIME">
    <xsd:complexContent>
      <xsd:extension base="ANY"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="DSET_REAL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="DSET_REAL-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_REAL">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="REAL"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="COLL_REAL">
    <xsd:complexContent>
      <xsd:extension base="ANY"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="DSET_INT">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="DSET_INT-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_INT">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="INT"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="COLL_INT">
    <xsd:complexContent>
      <xsd:extension base="ANY"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="DSET_INT.NONNEG">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="DSET_INT.NONNEG-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_INT.NONNEG">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="INT.NONNEG"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="COLL_INT.NONNEG">
    <xsd:complexContent>
      <xsd:extension base="ANY"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="DSET_INT.POS">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="DSET_INT.POS-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_INT.POS">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="INT.POS"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="COLL_INT.POS">
    <xsd:complexContent>
      <xsd:extension base="ANY"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="BAG_BL">
    <xsd:complexContent>
      <xsd:extension base="COLL_BL">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="BL"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="BAG_BL.NONNULL">
    <xsd:complexContent>
      <xsd:extension base="COLL_BL.NONNULL">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="BL.NONNULL"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="BAG_ED">
    <xsd:complexContent>
      <xsd:extension base="COLL_ED">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="ED"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="BAG_ED.IMAGE">
    <xsd:complexContent>
      <xsd:extension base="COLL_ED.IMAGE">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="ED.IMAGE"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="BAG_ED.TEXT">
    <xsd:complexContent>
      <xsd:extension base="COLL_ED.TEXT">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="ED.TEXT"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="BAG_ED.DOC">
    <xsd:complexContent>
      <xsd:extension base="COLL_ED.DOC">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="ED.DOC"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="BAG_ED.DOC.REF">
    <xsd:complexContent>
      <xsd:extension base="COLL_ED.DOC.REF">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="ED.DOC.REF"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="BAG_ED.DOC.INLINE">
    <xsd:complexContent>
      <xsd:extension base="COLL_ED.DOC.INLINE">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="ED.DOC.INLINE"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="BAG_ED.SIGNATURE">
    <xsd:complexContent>
      <xsd:extension base="COLL_ED.SIGNATURE">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="ED.SIGNATURE"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="BAG_ED.STRUCTUREDTEXT">
    <xsd:complexContent>
      <xsd:extension base="COLL_ED.STRUCTUREDTEXT">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="ED.STRUCTUREDTEXT"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="BAG_ED.STRUCTUREDTITLE">
    <xsd:complexContent>
      <xsd:extension base="COLL_ED.STRUCTUREDTITLE">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="ED.STRUCTUREDTITLE"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="BAG_ST">
    <xsd:complexContent>
      <xsd:extension base="COLL_ST">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="ST"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="BAG_ST.NT">
    <xsd:complexContent>
      <xsd:extension base="COLL_ST.NT">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="ST.NT"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="BAG_SC">
    <xsd:complexContent>
      <xsd:extension base="COLL_SC">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="SC"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="BAG_SC.NT">
    <xsd:complexContent>
      <xsd:extension base="COLL_SC.NT">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="SC.NT"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="BAG_TEL">
    <xsd:complexContent>
      <xsd:extension base="COLL_TEL">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="TEL"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="BAG_TEL.EMAIL">
    <xsd:complexContent>
      <xsd:extension base="COLL_TEL.EMAIL">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="TEL.EMAIL"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="BAG_TEL.PERSON">
    <xsd:complexContent>
      <xsd:extension base="COLL_TEL.PERSON">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="TEL.PERSON"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="BAG_TEL.PHONE">
    <xsd:complexContent>
      <xsd:extension base="COLL_TEL.PHONE">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="TEL.PHONE"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="BAG_TEL.URL">
    <xsd:complexContent>
      <xsd:extension base="COLL_TEL.URL">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="TEL.URL"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="BAG_II">
    <xsd:complexContent>
      <xsd:extension base="COLL_II">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="II"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="BAG_CD">
    <xsd:complexContent>
      <xsd:extension base="COLL_CD">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="CD"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="BAG_CD.CV">
    <xsd:complexContent>
      <xsd:extension base="COLL_CD.CV">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="CD.CV"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="BAG_CO">
    <xsd:complexContent>
      <xsd:extension base="COLL_CO">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="CO"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="BAG_CS">
    <xsd:complexContent>
      <xsd:extension base="COLL_CS">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="CS"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="BAG_AD">
    <xsd:complexContent>
      <xsd:extension base="COLL_AD">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="AD"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="BAG_EN">
    <xsd:complexContent>
      <xsd:extension base="COLL_EN">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="EN"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="BAG_EN.TN">
    <xsd:complexContent>
      <xsd:extension base="COLL_EN.TN">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="EN.TN"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="BAG_EN.PN">
    <xsd:complexContent>
      <xsd:extension base="COLL_EN.PN">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="EN.PN"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="BAG_EN.ON">
    <xsd:complexContent>
      <xsd:extension base="COLL_EN.ON">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="EN.ON"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="BAG_TS">
    <xsd:complexContent>
      <xsd:extension base="COLL_TS">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="TS"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="BAG_TS.DATE">
    <xsd:complexContent>
      <xsd:extension base="COLL_TS.DATE">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="TS.DATE"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="BAG_TS.DATE.FULL">
    <xsd:complexContent>
      <xsd:extension base="COLL_TS.DATE.FULL">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="TS.DATE.FULL"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="BAG_TS.DATETIME">
    <xsd:complexContent>
      <xsd:extension base="COLL_TS.DATETIME">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="TS.DATETIME"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="BAG_TS.DATETIME.FULL">
    <xsd:complexContent>
      <xsd:extension base="COLL_TS.DATETIME.FULL">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="TS.DATETIME.FULL"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="BAG_TS.BIRTH">
    <xsd:complexContent>
      <xsd:extension base="COLL_TS.BIRTH">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="TS.BIRTH"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="BAG_RTO">
    <xsd:complexContent>
      <xsd:extension base="COLL_RTO">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="RTO"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="BAG_MO">
    <xsd:complexContent>
      <xsd:extension base="COLL_MO">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="MO"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="BAG_PQ">
    <xsd:complexContent>
      <xsd:extension base="COLL_PQ">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="PQ"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="BAG_PQ.TIME">
    <xsd:complexContent>
      <xsd:extension base="COLL_PQ.TIME">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="PQ.TIME"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="BAG_REAL">
    <xsd:complexContent>
      <xsd:extension base="COLL_REAL">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="REAL"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="BAG_INT">
    <xsd:complexContent>
      <xsd:extension base="COLL_INT">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="INT"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="BAG_INT.NONNEG">
    <xsd:complexContent>
      <xsd:extension base="COLL_INT.NONNEG">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="INT.NONNEG"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="BAG_INT.POS">
    <xsd:complexContent>
      <xsd:extension base="COLL_INT.POS">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="INT.POS"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="LIST_BL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="LIST_BL-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="BL"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="LIST_BL.NONNULL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="LIST_BL.NONNULL-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="BL.NONNULL"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="LIST_ED">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="LIST_ED-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="ED"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="LIST_ED.IMAGE">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="LIST_ED.IMAGE-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="ED.IMAGE"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="LIST_ED.TEXT">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="LIST_ED.TEXT-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="ED.TEXT"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="LIST_ED.DOC">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="LIST_ED.DOC-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="ED.DOC"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="LIST_ED.DOC.REF">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="LIST_ED.DOC.REF-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="ED.DOC.REF"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="LIST_ED.DOC.INLINE">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="LIST_ED.DOC.INLINE-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="ED.DOC.INLINE"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="LIST_ED.SIGNATURE">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="LIST_ED.SIGNATURE-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="ED.SIGNATURE"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="LIST_ED.STRUCTUREDTEXT">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="LIST_ED.STRUCTUREDTEXT-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="ED.STRUCTUREDTEXT"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="LIST_ED.STRUCTUREDTITLE">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="LIST_ED.STRUCTUREDTITLE-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="ED.STRUCTUREDTITLE"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="LIST_ST">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="LIST_ST-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="ST"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="LIST_ST.NT">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="LIST_ST.NT-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="ST.NT"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="LIST_SC">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="LIST_SC-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="SC"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="LIST_SC.NT">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="LIST_SC.NT-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="SC.NT"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="LIST_TEL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="LIST_TEL-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="TEL"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="LIST_TEL.EMAIL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="LIST_TEL.EMAIL-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="TEL.EMAIL"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="LIST_TEL.PERSON">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="LIST_TEL.PERSON-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="TEL.PERSON"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="LIST_TEL.PHONE">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="LIST_TEL.PHONE-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="TEL.PHONE"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="LIST_TEL.URL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="LIST_TEL.URL-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="TEL.URL"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="LIST_II">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="LIST_II-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="II"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="LIST_CD">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="LIST_CD-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="CD"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="LIST_CD.CV">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="LIST_CD.CV-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="CD.CV"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="LIST_CO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="LIST_CO-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="CO"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="LIST_CS">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="LIST_CS-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="CS"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="LIST_AD">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="LIST_AD-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="AD"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="LIST_EN">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="LIST_EN-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="EN"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="LIST_EN.TN">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="LIST_EN.TN-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="EN.TN"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="LIST_EN.PN">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="LIST_EN.PN-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="EN.PN"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="LIST_EN.ON">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="LIST_EN.ON-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="EN.ON"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="LIST_TS">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="LIST_TS-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="TS"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="LIST_TS.DATE">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="LIST_TS.DATE-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="TS.DATE"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="LIST_TS.DATE.FULL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="LIST_TS.DATE.FULL-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="TS.DATE.FULL"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="LIST_TS.DATETIME">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="LIST_TS.DATETIME-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="TS.DATETIME"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="LIST_TS.DATETIME.FULL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="LIST_TS.DATETIME.FULL-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="TS.DATETIME.FULL"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="LIST_TS.BIRTH">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="LIST_TS.BIRTH-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="TS.BIRTH"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="LIST_RTO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="LIST_RTO-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="RTO"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="LIST_MO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="LIST_MO-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="MO"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="LIST_PQ">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="LIST_PQ-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="PQ"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="LIST_PQ.TIME">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="LIST_PQ.TIME-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="PQ.TIME"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="LIST_REAL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="LIST_REAL-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="REAL"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="LIST_INT">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="LIST_INT-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="INT"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="LIST_INT.NONNEG">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="LIST_INT.NONNEG-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="INT.NONNEG"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="LIST_INT.POS">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="LIST_INT.POS-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="INT.POS"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL_CO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null rules">
          <sch:rule abstract="true" id="IVL_CO-0">
            <sch:assert test="(@nullFlavor and not(any|low|high|width)) or (not(@nullFlavor) and (any|low|high|width))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="co-occurence rules">
          <sch:rule abstract="true" id="IVL_CO-1">
            <sch:assert test="(((any and not(any/@nullFlavor)) and not((low and not(low/@nullFlavor)) or (high and not(high/@nullFlavor)) or (width and not(width/@nullFlavor)))) or (not(any) or any/@nullFlavor)) and ((any and not(any/@nullFlavor)) or (not(any) or any/@nullFlavor) and (((width and not(width/@nullFlavor)) and (not(low) or low/@nullFlavor) and (not(high) or high/@nullFlavor))) or ((not(width) or width/@nullFlavor) and ((low and not(low/@nullFlavor)) or (high and not(high/@nullFlavor))))))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="closed attributes only if limited">
          <sch:rule abstract="true" id="IVL_CO-2">
            <sch:assert test="not(low and @lowClosed) and not(high and @highClosed)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on IVL attributes">
          <sch:rule abstract="true" id="IVL_CO-3">
            <sch:assert test="count(*[self::low or self::high or self::width][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_CO">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="low" type="CO"/>
          <xsd:element minOccurs="0" name="high" type="CO"/>
          <xsd:element minOccurs="0" name="width" type="QTY"/>
          <xsd:element minOccurs="0" name="any" type="CO"/>
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="optional"/>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="QSET_CO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="QSET_CO-0">
            <sch:assert test="count(*[self::originalText][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL_TS">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null rules">
          <sch:rule abstract="true" id="IVL_TS-0">
            <sch:assert test="(@nullFlavor and not(any|low|high|width)) or (not(@nullFlavor) and (any|low|high|width))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="co-occurence rules">
          <sch:rule abstract="true" id="IVL_TS-1">
            <sch:assert test="(((any and not(any/@nullFlavor)) and not((low and not(low/@nullFlavor)) or (high and not(high/@nullFlavor)) or (width and not(width/@nullFlavor)))) or (not(any) or any/@nullFlavor)) and ((any and not(any/@nullFlavor)) or (not(any) or any/@nullFlavor) and (((width and not(width/@nullFlavor)) and (not(low) or low/@nullFlavor) and (not(high) or high/@nullFlavor))) or ((not(width) or width/@nullFlavor) and ((low and not(low/@nullFlavor)) or (high and not(high/@nullFlavor))))))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="closed attributes only if limited">
          <sch:rule abstract="true" id="IVL_TS-2">
            <sch:assert test="not(low and @lowClosed) and not(high and @highClosed)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on IVL attributes">
          <sch:rule abstract="true" id="IVL_TS-3">
            <sch:assert test="count(*[self::low or self::high or self::width][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_TS">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="low" type="TS"/>
          <xsd:element minOccurs="0" name="high" type="TS"/>
          <xsd:element minOccurs="0" name="width" type="QTY"/>
          <xsd:element minOccurs="0" name="any" type="TS"/>
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="optional"/>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL_TS.DATE">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null rules">
          <sch:rule abstract="true" id="IVL_TS.DATE-0">
            <sch:assert test="(@nullFlavor and not(any|low|high|width)) or (not(@nullFlavor) and (any|low|high|width))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="co-occurence rules">
          <sch:rule abstract="true" id="IVL_TS.DATE-1">
            <sch:assert test="(((any and not(any/@nullFlavor)) and not((low and not(low/@nullFlavor)) or (high and not(high/@nullFlavor)) or (width and not(width/@nullFlavor)))) or (not(any) or any/@nullFlavor)) and ((any and not(any/@nullFlavor)) or (not(any) or any/@nullFlavor) and (((width and not(width/@nullFlavor)) and (not(low) or low/@nullFlavor) and (not(high) or high/@nullFlavor))) or ((not(width) or width/@nullFlavor) and ((low and not(low/@nullFlavor)) or (high and not(high/@nullFlavor))))))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="closed attributes only if limited">
          <sch:rule abstract="true" id="IVL_TS.DATE-2">
            <sch:assert test="not(low and @lowClosed) and not(high and @highClosed)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on IVL attributes">
          <sch:rule abstract="true" id="IVL_TS.DATE-3">
            <sch:assert test="count(*[self::low or self::high or self::width][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_TS.DATE">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="low" type="TS.DATE"/>
          <xsd:element minOccurs="0" name="high" type="TS.DATE"/>
          <xsd:element minOccurs="0" name="width" type="QTY"/>
          <xsd:element minOccurs="0" name="any" type="TS.DATE"/>
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="optional"/>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="QSET_TS.DATE">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="QSET_TS.DATE-0">
            <sch:assert test="count(*[self::originalText][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL_TS.DATE.FULL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null rules">
          <sch:rule abstract="true" id="IVL_TS.DATE.FULL-0">
            <sch:assert test="(@nullFlavor and not(any|low|high|width)) or (not(@nullFlavor) and (any|low|high|width))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="co-occurence rules">
          <sch:rule abstract="true" id="IVL_TS.DATE.FULL-1">
            <sch:assert test="(((any and not(any/@nullFlavor)) and not((low and not(low/@nullFlavor)) or (high and not(high/@nullFlavor)) or (width and not(width/@nullFlavor)))) or (not(any) or any/@nullFlavor)) and ((any and not(any/@nullFlavor)) or (not(any) or any/@nullFlavor) and (((width and not(width/@nullFlavor)) and (not(low) or low/@nullFlavor) and (not(high) or high/@nullFlavor))) or ((not(width) or width/@nullFlavor) and ((low and not(low/@nullFlavor)) or (high and not(high/@nullFlavor))))))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="closed attributes only if limited">
          <sch:rule abstract="true" id="IVL_TS.DATE.FULL-2">
            <sch:assert test="not(low and @lowClosed) and not(high and @highClosed)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on IVL attributes">
          <sch:rule abstract="true" id="IVL_TS.DATE.FULL-3">
            <sch:assert test="count(*[self::low or self::high or self::width][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_TS.DATE.FULL">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="low" type="TS.DATE.FULL"/>
          <xsd:element minOccurs="0" name="high" type="TS.DATE.FULL"/>
          <xsd:element minOccurs="0" name="width" type="QTY"/>
          <xsd:element minOccurs="0" name="any" type="TS.DATE.FULL"/>
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="optional"/>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="QSET_TS.DATE.FULL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="QSET_TS.DATE.FULL-0">
            <sch:assert test="count(*[self::originalText][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL_TS.DATETIME">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null rules">
          <sch:rule abstract="true" id="IVL_TS.DATETIME-0">
            <sch:assert test="(@nullFlavor and not(any|low|high|width)) or (not(@nullFlavor) and (any|low|high|width))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="co-occurence rules">
          <sch:rule abstract="true" id="IVL_TS.DATETIME-1">
            © 269
ISO 2008  All rights reserved
            <sch:assert test="(((any and not(any/@nullFlavor)) and not((low and not(low/@nullFlavor)) or (high and not(high/@nullFlavor)) or (width and not(width/@nullFlavor)))) or (not(any) or any/@nullFlavor)) and ((any and not(any/@nullFlavor)) or (not(any) or any/@nullFlavor) and (((width and not(width/@nullFlavor)) and (not(low) or low/@nullFlavor) and (not(high) or high/@nullFlavor))) or ((not(width) or width/@nullFlavor) and ((low and not(low/@nullFlavor)) or (high and not(high/@nullFlavor))))))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="closed attributes only if limited">
          <sch:rule abstract="true" id="IVL_TS.DATETIME-2">
            <sch:assert test="not(low and @lowClosed) and not(high and @highClosed)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on IVL attributes">
          <sch:rule abstract="true" id="IVL_TS.DATETIME-3">
            <sch:assert test="count(*[self::low or self::high or self::width][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_TS.DATETIME">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="low" type="TS.DATETIME"/>
          <xsd:element minOccurs="0" name="high" type="TS.DATETIME"/>
          <xsd:element minOccurs="0" name="width" type="QTY"/>
          <xsd:element minOccurs="0" name="any" type="TS.DATETIME"/>
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="optional"/>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="QSET_TS.DATETIME">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="QSET_TS.DATETIME-0">
            <sch:assert test="count(*[self::originalText][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL_TS.DATETIME.FULL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null rules">
          <sch:rule abstract="true" id="IVL_TS.DATETIME.FULL-0">
            <sch:assert test="(@nullFlavor and not(any|low|high|width)) or (not(@nullFlavor) and (any|low|high|width))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="co-occurence rules">
          <sch:rule abstract="true" id="IVL_TS.DATETIME.FULL-1">
            <sch:assert test="(((any and not(any/@nullFlavor)) and not((low and not(low/@nullFlavor)) or (high and not(high/@nullFlavor)) or (width and not(width/@nullFlavor)))) or (not(any) or any/@nullFlavor)) and ((any and not(any/@nullFlavor)) or (not(any) or any/@nullFlavor) and (((width and not(width/@nullFlavor)) and (not(low) or low/@nullFlavor) and (not(high) or high/@nullFlavor))) or ((not(width) or width/@nullFlavor) and ((low and not(low/@nullFlavor)) or (high and not(high/@nullFlavor))))))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="closed attributes only if limited">
          <sch:rule abstract="true" id="IVL_TS.DATETIME.FULL-2">
            <sch:assert test="not(low and @lowClosed) and not(high and @highClosed)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on IVL attributes">
          <sch:rule abstract="true" id="IVL_TS.DATETIME.FULL-3">
            <sch:assert test="count(*[self::low or self::high or self::width][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_TS.DATETIME.FULL">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="low" type="TS.DATETIME.FULL"/>
          <xsd:element minOccurs="0" name="high" type="TS.DATETIME.FULL"/>
          <xsd:element minOccurs="0" name="width" type="QTY"/>
          <xsd:element minOccurs="0" name="any" type="TS.DATETIME.FULL"/>
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="optional"/>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="QSET_TS.DATETIME.FULL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="QSET_TS.DATETIME.FULL-0">
            <sch:assert test="count(*[self::originalText][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL_TS.BIRTH">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null rules">
          <sch:rule abstract="true" id="IVL_TS.BIRTH-0">
            <sch:assert test="(@nullFlavor and not(any|low|high|width)) or (not(@nullFlavor) and (any|low|high|width))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="co-occurence rules">
          <sch:rule abstract="true" id="IVL_TS.BIRTH-1">
            <sch:assert test="(((any and not(any/@nullFlavor)) and not((low and not(low/@nullFlavor)) or (high and not(high/@nullFlavor)) or (width and not(width/@nullFlavor)))) or (not(any) or any/@nullFlavor)) and ((any and not(any/@nullFlavor)) or (not(any) or any/@nullFlavor) and (((width and not(width/@nullFlavor)) and (not(low) or low/@nullFlavor) and (not(high) or high/@nullFlavor))) or ((not(width) or width/@nullFlavor) and ((low and not(low/@nullFlavor)) or (high and not(high/@nullFlavor))))))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="closed attributes only if limited">
          <sch:rule abstract="true" id="IVL_TS.BIRTH-2">
            <sch:assert test="not(low and @lowClosed) and not(high and @highClosed)"/>
            © 271
ISO 2008  All rights reserved
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on IVL attributes">
          <sch:rule abstract="true" id="IVL_TS.BIRTH-3">
            <sch:assert test="count(*[self::low or self::high or self::width][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_TS.BIRTH">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="low" type="TS.BIRTH"/>
          <xsd:element minOccurs="0" name="high" type="TS.BIRTH"/>
          <xsd:element minOccurs="0" name="width" type="QTY"/>
          <xsd:element minOccurs="0" name="any" type="TS.BIRTH"/>
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="optional"/>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="QSET_TS.BIRTH">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="QSET_TS.BIRTH-0">
            <sch:assert test="count(*[self::originalText][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL_RTO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null rules">
          <sch:rule abstract="true" id="IVL_RTO-0">
            <sch:assert test="(@nullFlavor and not(any|low|high|width)) or (not(@nullFlavor) and (any|low|high|width))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="co-occurence rules">
          <sch:rule abstract="true" id="IVL_RTO-1">
            <sch:assert test="(((any and not(any/@nullFlavor)) and not((low and not(low/@nullFlavor)) or (high and not(high/@nullFlavor)) or (width and not(width/@nullFlavor)))) or (not(any) or any/@nullFlavor)) and ((any and not(any/@nullFlavor)) or (not(any) or any/@nullFlavor) and (((width and not(width/@nullFlavor)) and (not(low) or low/@nullFlavor) and (not(high) or high/@nullFlavor))) or ((not(width) or width/@nullFlavor) and ((low and not(low/@nullFlavor)) or (high and not(high/@nullFlavor))))))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="closed attributes only if limited">
          <sch:rule abstract="true" id="IVL_RTO-2">
            <sch:assert test="not(low and @lowClosed) and not(high and @highClosed)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on IVL attributes">
          <sch:rule abstract="true" id="IVL_RTO-3">
            <sch:assert test="count(*[self::low or self::high or self::width][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_RTO">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="low" type="RTO"/>
          <xsd:element minOccurs="0" name="high" type="RTO"/>
          <xsd:element minOccurs="0" name="width" type="QTY"/>
          <xsd:element minOccurs="0" name="any" type="RTO"/>
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="optional"/>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="QSET_RTO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="QSET_RTO-0">
            <sch:assert test="count(*[self::originalText][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL_MO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null rules">
          <sch:rule abstract="true" id="IVL_MO-0">
            <sch:assert test="(@nullFlavor and not(any|low|high|width)) or (not(@nullFlavor) and (any|low|high|width))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="co-occurence rules">
          <sch:rule abstract="true" id="IVL_MO-1">
            <sch:assert test="(((any and not(any/@nullFlavor)) and not((low and not(low/@nullFlavor)) or (high and not(high/@nullFlavor)) or (width and not(width/@nullFlavor)))) or (not(any) or any/@nullFlavor)) and ((any and not(any/@nullFlavor)) or (not(any) or any/@nullFlavor) and (((width and not(width/@nullFlavor)) and (not(low) or low/@nullFlavor) and (not(high) or high/@nullFlavor))) or ((not(width) or width/@nullFlavor) and ((low and not(low/@nullFlavor)) or (high and not(high/@nullFlavor))))))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="closed attributes only if limited">
          <sch:rule abstract="true" id="IVL_MO-2">
            <sch:assert test="not(low and @lowClosed) and not(high and @highClosed)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on IVL attributes">
          <sch:rule abstract="true" id="IVL_MO-3">
            <sch:assert test="count(*[self::low or self::high or self::width][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_MO">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="low" type="MO"/>
          <xsd:element minOccurs="0" name="high" type="MO"/>
          <xsd:element minOccurs="0" name="width" type="QTY"/>
          <xsd:element minOccurs="0" name="any" type="MO"/>
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="optional"/>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="QSET_MO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="QSET_MO-0">
            <sch:assert test="count(*[self::originalText][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL_PQ">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null rules">
          <sch:rule abstract="true" id="IVL_PQ-0">
            <sch:assert test="(@nullFlavor and not(any|low|high|width)) or (not(@nullFlavor) and (any|low|high|width))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="co-occurence rules">
          <sch:rule abstract="true" id="IVL_PQ-1">
            <sch:assert test="(((any and not(any/@nullFlavor)) and not((low and not(low/@nullFlavor)) or (high and not(high/@nullFlavor)) or (width and not(width/@nullFlavor)))) or (not(any) or any/@nullFlavor)) and ((any and not(any/@nullFlavor)) or (not(any) or any/@nullFlavor) and (((width and not(width/@nullFlavor)) and (not(low) or low/@nullFlavor) and (not(high) or high/@nullFlavor))) or ((not(width) or width/@nullFlavor) and ((low and not(low/@nullFlavor)) or (high and not(high/@nullFlavor))))))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="closed attributes only if limited">
          <sch:rule abstract="true" id="IVL_PQ-2">
            <sch:assert test="not(low and @lowClosed) and not(high and @highClosed)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on IVL attributes">
          <sch:rule abstract="true" id="IVL_PQ-3">
            <sch:assert test="count(*[self::low or self::high or self::width][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_PQ">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="low" type="PQ"/>
          <xsd:element minOccurs="0" name="high" type="PQ"/>
          <xsd:element minOccurs="0" name="width" type="QTY"/>
          <xsd:element minOccurs="0" name="any" type="PQ"/>
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="optional"/>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="QSET_PQ">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="QSET_PQ-0">
            <sch:assert test="count(*[self::originalText][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL_PQ.TIME">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null rules">
          <sch:rule abstract="true" id="IVL_PQ.TIME-0">
            <sch:assert test="(@nullFlavor and not(any|low|high|width)) or (not(@nullFlavor) and (any|low|high|width))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="co-occurence rules">
          <sch:rule abstract="true" id="IVL_PQ.TIME-1">
            <sch:assert test="(((any and not(any/@nullFlavor)) and not((low and not(low/@nullFlavor)) or (high and not(high/@nullFlavor)) or (width and not(width/@nullFlavor)))) or (not(any) or any/@nullFlavor)) and ((any and not(any/@nullFlavor)) or (not(any) or any/@nullFlavor) and (((width and not(width/@nullFlavor)) and (not(low) or low/@nullFlavor) and (not(high) or high/@nullFlavor))) or ((not(width) or width/@nullFlavor) and ((low and not(low/@nullFlavor)) or (high and not(high/@nullFlavor))))))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="closed attributes only if limited">
          <sch:rule abstract="true" id="IVL_PQ.TIME-2">
            <sch:assert test="not(low and @lowClosed) and not(high and @highClosed)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on IVL attributes">
          <sch:rule abstract="true" id="IVL_PQ.TIME-3">
            <sch:assert test="count(*[self::low or self::high or self::width][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_PQ.TIME">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="low" type="PQ.TIME"/>
          <xsd:element minOccurs="0" name="high" type="PQ.TIME"/>
          <xsd:element minOccurs="0" name="width" type="QTY"/>
          <xsd:element minOccurs="0" name="any" type="PQ.TIME"/>
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="optional"/>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="QSET_PQ.TIME">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="QSET_PQ.TIME-0">
            <sch:assert test="count(*[self::originalText][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL_REAL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null rules">
          <sch:rule abstract="true" id="IVL_REAL-0">
            <sch:assert test="(@nullFlavor and not(any|low|high|width)) or (not(@nullFlavor) and (any|low|high|width))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="co-occurence rules">
          <sch:rule abstract="true" id="IVL_REAL-1">
            <sch:assert test="(((any and not(any/@nullFlavor)) and not((low and not(low/@nullFlavor)) or (high and not(high/@nullFlavor)) or (width and not(width/@nullFlavor)))) or (not(any) or any/@nullFlavor)) and ((any and not(any/@nullFlavor)) or (not(any) or any/@nullFlavor) and (((width and not(width/@nullFlavor)) and (not(low) or low/@nullFlavor) and (not(high) or high/@nullFlavor))) or ((not(width) or width/@nullFlavor) and ((low and not(low/@nullFlavor)) or (high and not(high/@nullFlavor))))))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="closed attributes only if limited">
          <sch:rule abstract="true" id="IVL_REAL-2">
            <sch:assert test="not(low and @lowClosed) and not(high and @highClosed)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on IVL attributes">
          <sch:rule abstract="true" id="IVL_REAL-3">
            <sch:assert test="count(*[self::low or self::high or self::width][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_REAL">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="low" type="REAL"/>
          <xsd:element minOccurs="0" name="high" type="REAL"/>
          <xsd:element minOccurs="0" name="width" type="QTY"/>
          <xsd:element minOccurs="0" name="any" type="REAL"/>
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="optional"/>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="QSET_REAL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="QSET_REAL-0">
            <sch:assert test="count(*[self::originalText][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL_INT">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null rules">
          <sch:rule abstract="true" id="IVL_INT-0">
            <sch:assert test="(@nullFlavor and not(any|low|high|width)) or (not(@nullFlavor) and (any|low|high|width))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="co-occurence rules">
          <sch:rule abstract="true" id="IVL_INT-1">
            <sch:assert test="(((any and not(any/@nullFlavor)) and not((low and not(low/@nullFlavor)) or (high and not(high/@nullFlavor)) or (width and not(width/@nullFlavor)))) or (not(any) or any/@nullFlavor)) and ((any and not(any/@nullFlavor)) or (not(any) or any/@nullFlavor) and (((width and not(width/@nullFlavor)) and (not(low) or low/@nullFlavor) and (not(high) or high/@nullFlavor))) or ((not(width) or width/@nullFlavor) and ((low and not(low/@nullFlavor)) or (high and not(high/@nullFlavor))))))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="closed attributes only if limited">
          <sch:rule abstract="true" id="IVL_INT-2">
            <sch:assert test="not(low and @lowClosed) and not(high and @highClosed)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on IVL attributes">
          <sch:rule abstract="true" id="IVL_INT-3">
            <sch:assert test="count(*[self::low or self::high or self::width][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_INT">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="low" type="INT"/>
          <xsd:element minOccurs="0" name="high" type="INT"/>
          <xsd:element minOccurs="0" name="width" type="QTY"/>
          <xsd:element minOccurs="0" name="any" type="INT"/>
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="optional"/>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="QSET_INT">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="QSET_INT-0">
            <sch:assert test="count(*[self::originalText][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL_INT.NONNEG">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null rules">
          <sch:rule abstract="true" id="IVL_INT.NONNEG-0">
            <sch:assert test="(@nullFlavor and not(any|low|high|width)) or (not(@nullFlavor) and (any|low|high|width))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="co-occurence rules">
          <sch:rule abstract="true" id="IVL_INT.NONNEG-1">
            <sch:assert test="(((any and not(any/@nullFlavor)) and not((low and not(low/@nullFlavor)) or (high and not(high/@nullFlavor)) or (width and not(width/@nullFlavor)))) or (not(any) or any/@nullFlavor)) and ((any and not(any/@nullFlavor)) or (not(any) or any/@nullFlavor) and (((width and not(width/@nullFlavor)) and (not(low) or low/@nullFlavor) and (not(high) or high/@nullFlavor))) or ((not(width) or width/@nullFlavor) and ((low and not(low/@nullFlavor)) or (high and not(high/@nullFlavor))))))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="closed attributes only if limited">
          <sch:rule abstract="true" id="IVL_INT.NONNEG-2">
            <sch:assert test="not(low and @lowClosed) and not(high and @highClosed)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on IVL attributes">
          <sch:rule abstract="true" id="IVL_INT.NONNEG-3">
            <sch:assert test="count(*[self::low or self::high or self::width][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_INT.NONNEG">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="low" type="INT.NONNEG"/>
          <xsd:element minOccurs="0" name="high" type="INT.NONNEG"/>
          <xsd:element minOccurs="0" name="width" type="QTY"/>
          <xsd:element minOccurs="0" name="any" type="INT.NONNEG"/>
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="optional"/>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="QSET_INT.NONNEG">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="QSET_INT.NONNEG-0">
            <sch:assert test="count(*[self::originalText][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL_INT.POS">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null rules">
          <sch:rule abstract="true" id="IVL_INT.POS-0">
            <sch:assert test="(@nullFlavor and not(any|low|high|width)) or (not(@nullFlavor) and (any|low|high|width))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="co-occurence rules">
          <sch:rule abstract="true" id="IVL_INT.POS-1">
            <sch:assert test="(((any and not(any/@nullFlavor)) and not((low and not(low/@nullFlavor)) or (high and not(high/@nullFlavor)) or (width and not(width/@nullFlavor)))) or (not(any) or any/@nullFlavor)) and ((any and not(any/@nullFlavor)) or (not(any) or any/@nullFlavor) and (((width and not(width/@nullFlavor)) and (not(low) or low/@nullFlavor) and (not(high) or high/@nullFlavor))) or ((not(width) or width/@nullFlavor) and ((low and not(low/@nullFlavor)) or (high and not(high/@nullFlavor))))))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="closed attributes only if limited">
          <sch:rule abstract="true" id="IVL_INT.POS-2">
            <sch:assert test="not(low and @lowClosed) and not(high and @highClosed)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on IVL attributes">
          <sch:rule abstract="true" id="IVL_INT.POS-3">
            <sch:assert test="count(*[self::low or self::high or self::width][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_INT.POS">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="low" type="INT.POS"/>
          <xsd:element minOccurs="0" name="high" type="INT.POS"/>
          <xsd:element minOccurs="0" name="width" type="QTY"/>
          <xsd:element minOccurs="0" name="any" type="INT.POS"/>
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="optional"/>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="QSET_INT.POS">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="QSET_INT.POS-0">
            <sch:assert test="count(*[self::originalText][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL.LOW_CO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="IVL.LOW_CO-0">
            <sch:assert test="low and not(low\@nullFlavor) and (@lowClosed = &quot;true&quot;)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="high">
          © 279
ISO 2008  All rights reserved
          <sch:rule abstract="true" id="IVL.LOW_CO-1">
            <sch:assert test="not(high) and not(@highClosed)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="IVL_CO">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element minOccurs="0" name="low" type="CO"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="high" type="CO"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="width" type="QTY"/>
          <xsd:element minOccurs="0" name="any" type="CO"/>
        </xsd:sequence>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="prohibited"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL.LOW_TS">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="IVL.LOW_TS-0">
            <sch:assert test="low and not(low\@nullFlavor) and (@lowClosed = &quot;true&quot;)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="IVL.LOW_TS-1">
            <sch:assert test="not(high) and not(@highClosed)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="IVL_TS">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element minOccurs="0" name="low" type="TS"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="high" type="TS"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="width" type="QTY"/>
          <xsd:element minOccurs="0" name="any" type="TS"/>
        </xsd:sequence>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="prohibited"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL.LOW_TS.DATE">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="IVL.LOW_TS.DATE-0">
            <sch:assert test="low and not(low\@nullFlavor) and (@lowClosed = &quot;true&quot;)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="IVL.LOW_TS.DATE-1">
            <sch:assert test="not(high) and not(@highClosed)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="IVL_TS.DATE">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element minOccurs="0" name="low" type="TS.DATE"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="high" type="TS.DATE"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="width" type="QTY"/>
          <xsd:element minOccurs="0" name="any" type="TS.DATE"/>
        </xsd:sequence>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="prohibited"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL.LOW_TS.DATE.FULL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="IVL.LOW_TS.DATE.FULL-0">
            <sch:assert test="low and not(low\@nullFlavor) and (@lowClosed = &quot;true&quot;)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="IVL.LOW_TS.DATE.FULL-1">
            <sch:assert test="not(high) and not(@highClosed)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="IVL_TS.DATE.FULL">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element minOccurs="0" name="low" type="TS.DATE.FULL"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="high" type="TS.DATE.FULL"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="width" type="QTY"/>
          <xsd:element minOccurs="0" name="any" type="TS.DATE.FULL"/>
        </xsd:sequence>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="prohibited"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL.LOW_TS.DATETIME">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="IVL.LOW_TS.DATETIME-0">
            <sch:assert test="low and not(low\@nullFlavor) and (@lowClosed = &quot;true&quot;)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="IVL.LOW_TS.DATETIME-1">
            <sch:assert test="not(high) and not(@highClosed)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="IVL_TS.DATETIME">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element minOccurs="0" name="low" type="TS.DATETIME"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="high" type="TS.DATETIME"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="width" type="QTY"/>
          <xsd:element minOccurs="0" name="any" type="TS.DATETIME"/>
        </xsd:sequence>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="prohibited"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL.LOW_TS.DATETIME.FULL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="IVL.LOW_TS.DATETIME.FULL-0">
            <sch:assert test="low and not(low\@nullFlavor) and (@lowClosed = &quot;true&quot;)"/>
          </sch:rule>
          © 281
ISO 2008  All rights reserved
        </sch:pattern>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="IVL.LOW_TS.DATETIME.FULL-1">
            <sch:assert test="not(high) and not(@highClosed)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="IVL_TS.DATETIME.FULL">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element minOccurs="0" name="low" type="TS.DATETIME.FULL"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="high" type="TS.DATETIME.FULL"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="width" type="QTY"/>
          <xsd:element minOccurs="0" name="any" type="TS.DATETIME.FULL"/>
        </xsd:sequence>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="prohibited"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL.LOW_TS.BIRTH">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="IVL.LOW_TS.BIRTH-0">
            <sch:assert test="low and not(low\@nullFlavor) and (@lowClosed = &quot;true&quot;)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="IVL.LOW_TS.BIRTH-1">
            <sch:assert test="not(high) and not(@highClosed)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="IVL_TS.BIRTH">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element minOccurs="0" name="low" type="TS.BIRTH"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="high" type="TS.BIRTH"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="width" type="QTY"/>
          <xsd:element minOccurs="0" name="any" type="TS.BIRTH"/>
        </xsd:sequence>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="prohibited"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL.LOW_RTO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="IVL.LOW_RTO-0">
            <sch:assert test="low and not(low\@nullFlavor) and (@lowClosed = &quot;true&quot;)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="IVL.LOW_RTO-1">
            <sch:assert test="not(high) and not(@highClosed)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="IVL_RTO">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element minOccurs="0" name="low" type="RTO"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="high" type="RTO"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="width" type="QTY"/>
          <xsd:element minOccurs="0" name="any" type="RTO"/>
        </xsd:sequence>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="prohibited"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL.LOW_MO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="IVL.LOW_MO-0">
            <sch:assert test="low and not(low\@nullFlavor) and (@lowClosed = &quot;true&quot;)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="IVL.LOW_MO-1">
            <sch:assert test="not(high) and not(@highClosed)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="IVL_MO">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element minOccurs="0" name="low" type="MO"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="high" type="MO"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="width" type="QTY"/>
          <xsd:element minOccurs="0" name="any" type="MO"/>
        </xsd:sequence>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="prohibited"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL.LOW_PQ">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="IVL.LOW_PQ-0">
            <sch:assert test="low and not(low\@nullFlavor) and (@lowClosed = &quot;true&quot;)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="IVL.LOW_PQ-1">
            <sch:assert test="not(high) and not(@highClosed)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="IVL_PQ">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element minOccurs="0" name="low" type="PQ"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="high" type="PQ"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="width" type="QTY"/>
          <xsd:element minOccurs="0" name="any" type="PQ"/>
        </xsd:sequence>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="prohibited"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL.LOW_PQ.TIME">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="IVL.LOW_PQ.TIME-0">
            © 283
ISO 2008  All rights reserved
            <sch:assert test="low and not(low\@nullFlavor) and (@lowClosed = &quot;true&quot;)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="IVL.LOW_PQ.TIME-1">
            <sch:assert test="not(high) and not(@highClosed)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="IVL_PQ.TIME">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element minOccurs="0" name="low" type="PQ.TIME"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="high" type="PQ.TIME"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="width" type="QTY"/>
          <xsd:element minOccurs="0" name="any" type="PQ.TIME"/>
        </xsd:sequence>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="prohibited"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL.LOW_REAL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="IVL.LOW_REAL-0">
            <sch:assert test="low and not(low\@nullFlavor) and (@lowClosed = &quot;true&quot;)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="IVL.LOW_REAL-1">
            <sch:assert test="not(high) and not(@highClosed)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="IVL_REAL">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element minOccurs="0" name="low" type="REAL"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="high" type="REAL"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="width" type="QTY"/>
          <xsd:element minOccurs="0" name="any" type="REAL"/>
        </xsd:sequence>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="prohibited"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL.LOW_INT">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="IVL.LOW_INT-0">
            <sch:assert test="low and not(low\@nullFlavor) and (@lowClosed = &quot;true&quot;)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="IVL.LOW_INT-1">
            <sch:assert test="not(high) and not(@highClosed)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="IVL_INT">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element minOccurs="0" name="low" type="INT"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="high" type="INT"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="width" type="QTY"/>
          <xsd:element minOccurs="0" name="any" type="INT"/>
        </xsd:sequence>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="prohibited"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL.LOW_INT.NONNEG">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="IVL.LOW_INT.NONNEG-0">
            <sch:assert test="low and not(low\@nullFlavor) and (@lowClosed = &quot;true&quot;)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="IVL.LOW_INT.NONNEG-1">
            <sch:assert test="not(high) and not(@highClosed)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="IVL_INT.NONNEG">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element minOccurs="0" name="low" type="INT.NONNEG"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="high" type="INT.NONNEG"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="width" type="QTY"/>
          <xsd:element minOccurs="0" name="any" type="INT.NONNEG"/>
        </xsd:sequence>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="prohibited"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL.LOW_INT.POS">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="IVL.LOW_INT.POS-0">
            <sch:assert test="low and not(low\@nullFlavor) and (@lowClosed = &quot;true&quot;)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="IVL.LOW_INT.POS-1">
            <sch:assert test="not(high) and not(@highClosed)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="IVL_INT.POS">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element minOccurs="0" name="low" type="INT.POS"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="high" type="INT.POS"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="width" type="QTY"/>
          <xsd:element minOccurs="0" name="any" type="INT.POS"/>
        </xsd:sequence>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="prohibited"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL.WIDTH_CO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="width">
          <sch:rule abstract="true" id="IVL.WIDTH_CO-0">
            <sch:assert test="width and not(width\@nullFlavor)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="IVL.WIDTH_CO-1">
            <sch:assert test="not(low) and not(@lowClosed)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="IVL.WIDTH_CO-2">
            <sch:assert test="not(high) and not(@highClosed)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="IVL_CO">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="low" type="CO"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="high" type="CO"/>
          <xsd:element minOccurs="0" name="width" type="QTY"/>
          <xsd:element minOccurs="0" name="any" type="CO"/>
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="prohibited"/>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="prohibited"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL.WIDTH_TS">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="width">
          <sch:rule abstract="true" id="IVL.WIDTH_TS-0">
            <sch:assert test="width and not(width\@nullFlavor)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="IVL.WIDTH_TS-1">
            <sch:assert test="not(low) and not(@lowClosed)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="IVL.WIDTH_TS-2">
            <sch:assert test="not(high) and not(@highClosed)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="IVL_TS">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="low" type="TS"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="high" type="TS"/>
          <xsd:element minOccurs="0" name="width" type="QTY"/>
          <xsd:element minOccurs="0" name="any" type="TS"/>
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="prohibited"/>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="prohibited"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL.WIDTH_TS.DATE">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="width">
          <sch:rule abstract="true" id="IVL.WIDTH_TS.DATE-0">
            <sch:assert test="width and not(width\@nullFlavor)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="IVL.WIDTH_TS.DATE-1">
            <sch:assert test="not(low) and not(@lowClosed)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="IVL.WIDTH_TS.DATE-2">
            <sch:assert test="not(high) and not(@highClosed)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="IVL_TS.DATE">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="low" type="TS.DATE"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="high" type="TS.DATE"/>
          <xsd:element minOccurs="0" name="width" type="QTY"/>
          <xsd:element minOccurs="0" name="any" type="TS.DATE"/>
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="prohibited"/>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="prohibited"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL.WIDTH_TS.DATE.FULL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="width">
          <sch:rule abstract="true" id="IVL.WIDTH_TS.DATE.FULL-0">
            <sch:assert test="width and not(width\@nullFlavor)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="IVL.WIDTH_TS.DATE.FULL-1">
            <sch:assert test="not(low) and not(@lowClosed)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="IVL.WIDTH_TS.DATE.FULL-2">
            <sch:assert test="not(high) and not(@highClosed)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="IVL_TS.DATE.FULL">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="low" type="TS.DATE.FULL"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="high" type="TS.DATE.FULL"/>
          <xsd:element minOccurs="0" name="width" type="QTY"/>
          <xsd:element minOccurs="0" name="any" type="TS.DATE.FULL"/>
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="prohibited"/>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="prohibited"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL.WIDTH_TS.DATETIME">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="width">
          <sch:rule abstract="true" id="IVL.WIDTH_TS.DATETIME-0">
            <sch:assert test="width and not(width\@nullFlavor)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="IVL.WIDTH_TS.DATETIME-1">
            <sch:assert test="not(low) and not(@lowClosed)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="IVL.WIDTH_TS.DATETIME-2">
            <sch:assert test="not(high) and not(@highClosed)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="IVL_TS.DATETIME">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="low" type="TS.DATETIME"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="high" type="TS.DATETIME"/>
          <xsd:element minOccurs="0" name="width" type="QTY"/>
          <xsd:element minOccurs="0" name="any" type="TS.DATETIME"/>
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="prohibited"/>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="prohibited"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL.WIDTH_TS.DATETIME.FULL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="width">
          <sch:rule abstract="true" id="IVL.WIDTH_TS.DATETIME.FULL-0">
            <sch:assert test="width and not(width\@nullFlavor)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="IVL.WIDTH_TS.DATETIME.FULL-1">
            <sch:assert test="not(low) and not(@lowClosed)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="IVL.WIDTH_TS.DATETIME.FULL-2">
            <sch:assert test="not(high) and not(@highClosed)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="IVL_TS.DATETIME.FULL">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="low" type="TS.DATETIME.FULL"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="high" type="TS.DATETIME.FULL"/>
          <xsd:element minOccurs="0" name="width" type="QTY"/>
          <xsd:element minOccurs="0" name="any" type="TS.DATETIME.FULL"/>
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="prohibited"/>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="prohibited"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL.WIDTH_TS.BIRTH">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="width">
          <sch:rule abstract="true" id="IVL.WIDTH_TS.BIRTH-0">
            <sch:assert test="width and not(width\@nullFlavor)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="IVL.WIDTH_TS.BIRTH-1">
            <sch:assert test="not(low) and not(@lowClosed)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="IVL.WIDTH_TS.BIRTH-2">
            <sch:assert test="not(high) and not(@highClosed)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="IVL_TS.BIRTH">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="low" type="TS.BIRTH"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="high" type="TS.BIRTH"/>
          <xsd:element minOccurs="0" name="width" type="QTY"/>
          <xsd:element minOccurs="0" name="any" type="TS.BIRTH"/>
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="prohibited"/>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="prohibited"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL.WIDTH_RTO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="width">
          <sch:rule abstract="true" id="IVL.WIDTH_RTO-0">
            <sch:assert test="width and not(width\@nullFlavor)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="IVL.WIDTH_RTO-1">
            <sch:assert test="not(low) and not(@lowClosed)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="IVL.WIDTH_RTO-2">
            <sch:assert test="not(high) and not(@highClosed)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="IVL_RTO">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="low" type="RTO"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="high" type="RTO"/>
          <xsd:element minOccurs="0" name="width" type="QTY"/>
          <xsd:element minOccurs="0" name="any" type="RTO"/>
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="prohibited"/>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="prohibited"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL.WIDTH_MO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="width">
          <sch:rule abstract="true" id="IVL.WIDTH_MO-0">
            <sch:assert test="width and not(width\@nullFlavor)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="IVL.WIDTH_MO-1">
            <sch:assert test="not(low) and not(@lowClosed)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="IVL.WIDTH_MO-2">
            <sch:assert test="not(high) and not(@highClosed)"/>
          </sch:rule>
          © 289
ISO 2008  All rights reserved
          <sch:assert test="width and not(width\@nullFlavor)"/>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="IVL_MO">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="low" type="MO"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="high" type="MO"/>
          <xsd:element minOccurs="0" name="width" type="QTY"/>
          <xsd:element minOccurs="0" name="any" type="MO"/>
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="prohibited"/>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="prohibited"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL.WIDTH_PQ">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="width">
          <sch:rule abstract="true" id="IVL.WIDTH_PQ-0">
            <sch:assert test="width and not(width\@nullFlavor)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="IVL.WIDTH_PQ-1">
            <sch:assert test="not(low) and not(@lowClosed)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="IVL.WIDTH_PQ-2">
            <sch:assert test="not(high) and not(@highClosed)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="IVL_PQ">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="low" type="PQ"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="high" type="PQ"/>
          <xsd:element minOccurs="0" name="width" type="QTY"/>
          <xsd:element minOccurs="0" name="any" type="PQ"/>
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="prohibited"/>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="prohibited"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL.WIDTH_PQ.TIME">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="width">
          <sch:rule abstract="true" id="IVL.WIDTH_PQ.TIME-0"></sch:rule>
        </sch:pattern>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="IVL.WIDTH_PQ.TIME-1">
            <sch:assert test="not(low) and not(@lowClosed)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="IVL.WIDTH_PQ.TIME-2">
            <sch:assert test="not(high) and not(@highClosed)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="IVL_PQ.TIME">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="low" type="PQ.TIME"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="high" type="PQ.TIME"/>
          <xsd:element minOccurs="0" name="width" type="QTY"/>
          <xsd:element minOccurs="0" name="any" type="PQ.TIME"/>
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="prohibited"/>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="prohibited"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL.WIDTH_REAL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="width">
          <sch:rule abstract="true" id="IVL.WIDTH_REAL-0">
            <sch:assert test="width and not(width\@nullFlavor)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="IVL.WIDTH_REAL-1">
            <sch:assert test="not(low) and not(@lowClosed)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="IVL.WIDTH_REAL-2">
            <sch:assert test="not(high) and not(@highClosed)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="IVL_REAL">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="low" type="REAL"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="high" type="REAL"/>
          <xsd:element minOccurs="0" name="width" type="QTY"/>
          <xsd:element minOccurs="0" name="any" type="REAL"/>
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="prohibited"/>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="prohibited"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL.WIDTH_INT">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="width">
          <sch:rule abstract="true" id="IVL.WIDTH_INT-0">
            <sch:assert test="width and not(width\@nullFlavor)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="IVL.WIDTH_INT-1">
            <sch:assert test="not(low) and not(@lowClosed)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="IVL.WIDTH_INT-2">
            <sch:assert test="not(high) and not(@highClosed)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="IVL_INT">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="low" type="INT"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="high" type="INT"/>
          <xsd:element minOccurs="0" name="width" type="QTY"/>
          <xsd:element minOccurs="0" name="any" type="INT"/>
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="prohibited"/>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="prohibited"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL.WIDTH_INT.NONNEG">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="width">
          <sch:rule abstract="true" id="IVL.WIDTH_INT.NONNEG-0">
            <sch:assert test="width and not(width\@nullFlavor)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="IVL.WIDTH_INT.NONNEG-1">
            <sch:assert test="not(low) and not(@lowClosed)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="IVL.WIDTH_INT.NONNEG-2">
            <sch:assert test="not(high) and not(@highClosed)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="IVL_INT.NONNEG">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="low" type="INT.NONNEG"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="high" type="INT.NONNEG"/>
          <xsd:element minOccurs="0" name="width" type="QTY"/>
          <xsd:element minOccurs="0" name="any" type="INT.NONNEG"/>
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="prohibited"/>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="prohibited"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL.WIDTH_INT.POS">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="width">
          <sch:rule abstract="true" id="IVL.WIDTH_INT.POS-0">
            <sch:assert test="width and not(width\@nullFlavor)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="IVL.WIDTH_INT.POS-1">
            <sch:assert test="not(low) and not(@lowClosed)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="IVL.WIDTH_INT.POS-2">
            <sch:assert test="not(high) and not(@highClosed)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="IVL_INT.POS">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="low" type="INT.POS"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="high" type="INT.POS"/>
          <xsd:element minOccurs="0" name="width" type="QTY"/>
          <xsd:element minOccurs="0" name="any" type="INT.POS"/>
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="prohibited"/>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="prohibited"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL.HIGH_CO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="IVL.HIGH_CO-0">
            <sch:assert test="high and not(high\@nullFlavor) and (@highClosed = &quot;true&quot;)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="IVL.HIGH_CO-1">
            <sch:assert test="not(low) and not(@lowClosed)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="IVL_CO">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="low" type="CO"/>
          <xsd:element minOccurs="0" name="high" type="CO"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="width" type="QTY"/>
          <xsd:element minOccurs="0" name="any" type="CO"/>
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="prohibited"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL.HIGH_TS">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="IVL.HIGH_TS-0">
            <sch:assert test="high and not(high\@nullFlavor) and (@highClosed = &quot;true&quot;)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="IVL.HIGH_TS-1">
            <sch:assert test="not(low) and not(@lowClosed)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="IVL_TS">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="low" type="TS"/>
          <xsd:element minOccurs="0" name="high" type="TS"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="width" type="QTY"/>
          <xsd:element minOccurs="0" name="any" type="TS"/>
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="prohibited"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL.HIGH_TS.DATE">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="IVL.HIGH_TS.DATE-0">
            <sch:assert test="high and not(high\@nullFlavor) and (@highClosed = &quot;true&quot;)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="IVL.HIGH_TS.DATE-1">
            <sch:assert test="not(low) and not(@lowClosed)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="IVL_TS.DATE">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="low" type="TS.DATE"/>
          <xsd:element minOccurs="0" name="high" type="TS.DATE"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="width" type="QTY"/>
          <xsd:element minOccurs="0" name="any" type="TS.DATE"/>
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="prohibited"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL.HIGH_TS.DATE.FULL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="IVL.HIGH_TS.DATE.FULL-0">
            <sch:assert test="high and not(high\@nullFlavor) and (@highClosed = &quot;true&quot;)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="IVL.HIGH_TS.DATE.FULL-1">
            <sch:assert test="not(low) and not(@lowClosed)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="IVL_TS.DATE.FULL">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="low" type="TS.DATE.FULL"/>
          <xsd:element minOccurs="0" name="high" type="TS.DATE.FULL"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="width" type="QTY"/>
          <xsd:element minOccurs="0" name="any" type="TS.DATE.FULL"/>
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="prohibited"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL.HIGH_TS.DATETIME">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="IVL.HIGH_TS.DATETIME-0">
            <sch:assert test="high and not(high\@nullFlavor) and (@highClosed = &quot;true&quot;)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="IVL.HIGH_TS.DATETIME-1">
            <sch:assert test="not(low) and not(@lowClosed)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="IVL_TS.DATETIME">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="low" type="TS.DATETIME"/>
          <xsd:element minOccurs="0" name="high" type="TS.DATETIME"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="width" type="QTY"/>
          <xsd:element minOccurs="0" name="any" type="TS.DATETIME"/>
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="prohibited"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL.HIGH_TS.DATETIME.FULL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="IVL.HIGH_TS.DATETIME.FULL-0">
            <sch:assert test="high and not(high\@nullFlavor) and (@highClosed = &quot;true&quot;)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="IVL.HIGH_TS.DATETIME.FULL-1">
            <sch:assert test="not(low) and not(@lowClosed)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="IVL_TS.DATETIME.FULL">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="low" type="TS.DATETIME.FULL"/>
          <xsd:element minOccurs="0" name="high" type="TS.DATETIME.FULL"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="width" type="QTY"/>
          <xsd:element minOccurs="0" name="any" type="TS.DATETIME.FULL"/>
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="prohibited"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL.HIGH_TS.BIRTH">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="IVL.HIGH_TS.BIRTH-0">
            <sch:assert test="high and not(high\@nullFlavor) and (@highClosed = &quot;true&quot;)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="IVL.HIGH_TS.BIRTH-1">
            <sch:assert test="not(low) and not(@lowClosed)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="IVL_TS.BIRTH">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="low" type="TS.BIRTH"/>
          <xsd:element minOccurs="0" name="high" type="TS.BIRTH"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="width" type="QTY"/>
          <xsd:element minOccurs="0" name="any" type="TS.BIRTH"/>
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="prohibited"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL.HIGH_RTO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="IVL.HIGH_RTO-0">
            © 295
ISO 2008  All rights reserved
            <sch:assert test="high and not(high\@nullFlavor) and (@highClosed = &quot;true&quot;)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="IVL.HIGH_RTO-1">
            <sch:assert test="not(low) and not(@lowClosed)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="IVL_RTO">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="low" type="RTO"/>
          <xsd:element minOccurs="0" name="high" type="RTO"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="width" type="QTY"/>
          <xsd:element minOccurs="0" name="any" type="RTO"/>
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="prohibited"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL.HIGH_MO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="IVL.HIGH_MO-0">
            <sch:assert test="high and not(high\@nullFlavor) and (@highClosed = &quot;true&quot;)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="IVL.HIGH_MO-1">
            <sch:assert test="not(low) and not(@lowClosed)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="IVL_MO">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="low" type="MO"/>
          <xsd:element minOccurs="0" name="high" type="MO"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="width" type="QTY"/>
          <xsd:element minOccurs="0" name="any" type="MO"/>
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="prohibited"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL.HIGH_PQ">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="IVL.HIGH_PQ-0">
            <sch:assert test="high and not(high\@nullFlavor) and (@highClosed = &quot;true&quot;)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="IVL.HIGH_PQ-1">
            <sch:assert test="not(low) and not(@lowClosed)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="IVL_PQ">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="low" type="PQ"/>
          <xsd:element minOccurs="0" name="high" type="PQ"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="width" type="QTY"/>
          <xsd:element minOccurs="0" name="any" type="PQ"/>
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="prohibited"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL.HIGH_PQ.TIME">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="IVL.HIGH_PQ.TIME-0">
            <sch:assert test="high and not(high\@nullFlavor) and (@highClosed = &quot;true&quot;)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="IVL.HIGH_PQ.TIME-1">
            <sch:assert test="not(low) and not(@lowClosed)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="IVL_PQ.TIME">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="low" type="PQ.TIME"/>
          <xsd:element minOccurs="0" name="high" type="PQ.TIME"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="width" type="QTY"/>
          <xsd:element minOccurs="0" name="any" type="PQ.TIME"/>
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="prohibited"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL.HIGH_REAL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="IVL.HIGH_REAL-0">
            <sch:assert test="high and not(high\@nullFlavor) and (@highClosed = &quot;true&quot;)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="IVL.HIGH_REAL-1">
            <sch:assert test="not(low) and not(@lowClosed)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="IVL_REAL">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="low" type="REAL"/>
          <xsd:element minOccurs="0" name="high" type="REAL"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="width" type="QTY"/>
          <xsd:element minOccurs="0" name="any" type="REAL"/>
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="prohibited"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL.HIGH_INT">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="IVL.HIGH_INT-0">
            <sch:assert test="high and not(high\@nullFlavor) and (@highClosed = &quot;true&quot;)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="IVL.HIGH_INT-1">
            <sch:assert test="not(low) and not(@lowClosed)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="IVL_INT">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="low" type="INT"/>
          <xsd:element minOccurs="0" name="high" type="INT"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="width" type="QTY"/>
          <xsd:element minOccurs="0" name="any" type="INT"/>
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="prohibited"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL.HIGH_INT.NONNEG">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="IVL.HIGH_INT.NONNEG-0">
            <sch:assert test="high and not(high\@nullFlavor) and (@highClosed = &quot;true&quot;)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="IVL.HIGH_INT.NONNEG-1">
            <sch:assert test="not(low) and not(@lowClosed)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="IVL_INT.NONNEG">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="low" type="INT.NONNEG"/>
          <xsd:element minOccurs="0" name="high" type="INT.NONNEG"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="width" type="QTY"/>
          <xsd:element minOccurs="0" name="any" type="INT.NONNEG"/>
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="prohibited"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL.HIGH_INT.POS">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="IVL.HIGH_INT.POS-0">
            <sch:assert test="high and not(high\@nullFlavor) and (@highClosed = &quot;true&quot;)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="IVL.HIGH_INT.POS-1">
            <sch:assert test="not(low) and not(@lowClosed)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="IVL_INT.POS">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="low" type="INT.POS"/>
          <xsd:element minOccurs="0" name="high" type="INT.POS"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="width" type="QTY"/>
          <xsd:element minOccurs="0" name="any" type="INT.POS"/>
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="prohibited"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="SLIST_CO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="required attributes">
          <sch:rule abstract="true" id="SLIST_CO-0">
            <sch:assert test="@nullFlavor or (origin and not(origin\@nullFlavor) and count(*[digits\not(@nullFlavor))>0)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on SLIST attributes">
          <sch:rule abstract="true" id="SLIST_CO-1">
            <sch:assert test="count(*[self::origin or self::scale or self::digits][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="origin" type="CO"/>
          <xsd:element minOccurs="0" name="scale" type="QTY"/>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="digit" type="INT"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="SLIST_TS">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="required attributes">
          <sch:rule abstract="true" id="SLIST_TS-0">
            <sch:assert test="@nullFlavor or (origin and not(origin\@nullFlavor) and count(*[digits\not(@nullFlavor))>0)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on SLIST attributes">
          <sch:rule abstract="true" id="SLIST_TS-1">
            <sch:assert test="count(*[self::origin or self::scale or self::digits][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="origin" type="TS"/>
          <xsd:element minOccurs="0" name="scale" type="QTY"/>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="digit" type="INT"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="SLIST_TS.DATE">
    <xsd:annotation>
      <xsd:appinfo>
        © 299
ISO 2008  All rights reserved
        <sch:pattern name="required attributes">
          <sch:rule abstract="true" id="SLIST_TS.DATE-0">
            <sch:assert test="@nullFlavor or (origin and not(origin\@nullFlavor) and count(*[digits\not(@nullFlavor))>0)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on SLIST attributes">
          <sch:rule abstract="true" id="SLIST_TS.DATE-1">
            <sch:assert test="count(*[self::origin or self::scale or self::digits][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="origin" type="TS.DATE"/>
          <xsd:element minOccurs="0" name="scale" type="QTY"/>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="digit" type="INT"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="SLIST_TS.DATE.FULL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="required attributes">
          <sch:rule abstract="true" id="SLIST_TS.DATE.FULL-0">
            <sch:assert test="@nullFlavor or (origin and not(origin\@nullFlavor) and count(*[digits\not(@nullFlavor))>0)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on SLIST attributes">
          <sch:rule abstract="true" id="SLIST_TS.DATE.FULL-1">
            <sch:assert test="count(*[self::origin or self::scale or self::digits][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="origin" type="TS.DATE.FULL"/>
          <xsd:element minOccurs="0" name="scale" type="QTY"/>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="digit" type="INT"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="SLIST_TS.DATETIME">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="required attributes">
          <sch:rule abstract="true" id="SLIST_TS.DATETIME-0">
            <sch:assert test="@nullFlavor or (origin and not(origin\@nullFlavor) and count(*[digits\not(@nullFlavor))>0)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on SLIST attributes">
          <sch:rule abstract="true" id="SLIST_TS.DATETIME-1">
            <sch:assert test="count(*[self::origin or self::scale or self::digits][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="origin" type="TS.DATETIME"/>
          <xsd:element minOccurs="0" name="scale" type="QTY"/>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="digit" type="INT"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="SLIST_TS.DATETIME.FULL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="required attributes">
          <sch:rule abstract="true" id="SLIST_TS.DATETIME.FULL-0">
            <sch:assert test="@nullFlavor or (origin and not(origin\@nullFlavor) and count(*[digits\not(@nullFlavor))>0)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on SLIST attributes">
          <sch:rule abstract="true" id="SLIST_TS.DATETIME.FULL-1">
            <sch:assert test="count(*[self::origin or self::scale or self::digits][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="origin" type="TS.DATETIME.FULL"/>
          <xsd:element minOccurs="0" name="scale" type="QTY"/>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="digit" type="INT"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="SLIST_TS.BIRTH">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="required attributes">
          <sch:rule abstract="true" id="SLIST_TS.BIRTH-0">
            <sch:assert test="@nullFlavor or (origin and not(origin\@nullFlavor) and count(*[digits\not(@nullFlavor))>0)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on SLIST attributes">
          <sch:rule abstract="true" id="SLIST_TS.BIRTH-1">
            <sch:assert test="count(*[self::origin or self::scale or self::digits][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="origin" type="TS.BIRTH"/>
          <xsd:element minOccurs="0" name="scale" type="QTY"/>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="digit" type="INT"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="SLIST_RTO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="required attributes">
          <sch:rule abstract="true" id="SLIST_RTO-0">
            <sch:assert test="@nullFlavor or (origin and not(origin\@nullFlavor) and count(*[digits\not(@nullFlavor))>0)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on SLIST attributes">
          <sch:rule abstract="true" id="SLIST_RTO-1">
            <sch:assert test="count(*[self::origin or self::scale or self::digits][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="origin" type="RTO"/>
          <xsd:element minOccurs="0" name="scale" type="QTY"/>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="digit" type="INT"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="SLIST_MO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="required attributes">
          <sch:rule abstract="true" id="SLIST_MO-0">
            <sch:assert test="@nullFlavor or (origin and not(origin\@nullFlavor) and count(*[digits\not(@nullFlavor))>0)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on SLIST attributes">
          <sch:rule abstract="true" id="SLIST_MO-1">
            <sch:assert test="count(*[self::origin or self::scale or self::digits][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="origin" type="MO"/>
          <xsd:element minOccurs="0" name="scale" type="QTY"/>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="digit" type="INT"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="SLIST_PQ">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="required attributes">
          <sch:rule abstract="true" id="SLIST_PQ-0">
            <sch:assert test="@nullFlavor or (origin and not(origin\@nullFlavor) and count(*[digits\not(@nullFlavor))>0)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on SLIST attributes">
          <sch:rule abstract="true" id="SLIST_PQ-1">
            <sch:assert test="count(*[self::origin or self::scale or self::digits][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="origin" type="PQ"/>
          <xsd:element minOccurs="0" name="scale" type="QTY"/>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="digit" type="INT"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="SLIST_PQ.TIME">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="required attributes">
          <sch:rule abstract="true" id="SLIST_PQ.TIME-0">
            <sch:assert test="@nullFlavor or (origin and not(origin\@nullFlavor) and count(*[digits\not(@nullFlavor))>0)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on SLIST attributes">
          <sch:rule abstract="true" id="SLIST_PQ.TIME-1">
            <sch:assert test="count(*[self::origin or self::scale or self::digits][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="origin" type="PQ.TIME"/>
          <xsd:element minOccurs="0" name="scale" type="QTY"/>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="digit" type="INT"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="SLIST_REAL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="required attributes">
          <sch:rule abstract="true" id="SLIST_REAL-0">
            <sch:assert test="@nullFlavor or (origin and not(origin\@nullFlavor) and count(*[digits\not(@nullFlavor))>0)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on SLIST attributes">
          <sch:rule abstract="true" id="SLIST_REAL-1">
            <sch:assert test="count(*[self::origin or self::scale or self::digits][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="origin" type="REAL"/>
          <xsd:element minOccurs="0" name="scale" type="QTY"/>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="digit" type="INT"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="SLIST_INT">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="required attributes">
          <sch:rule abstract="true" id="SLIST_INT-0">
            <sch:assert test="@nullFlavor or (origin and not(origin\@nullFlavor) and count(*[digits\not(@nullFlavor))>0)"/>
          </sch:rule>
          © 303
ISO 2008  All rights reserved
        </sch:pattern>
        <sch:pattern name="no updateMode or History on SLIST attributes">
          <sch:rule abstract="true" id="SLIST_INT-1">
            <sch:assert test="count(*[self::origin or self::scale or self::digits][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="origin" type="INT"/>
          <xsd:element minOccurs="0" name="scale" type="QTY"/>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="digit" type="INT"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="SLIST_INT.NONNEG">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="required attributes">
          <sch:rule abstract="true" id="SLIST_INT.NONNEG-0">
            <sch:assert test="@nullFlavor or (origin and not(origin\@nullFlavor) and count(*[digits\not(@nullFlavor))>0)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on SLIST attributes">
          <sch:rule abstract="true" id="SLIST_INT.NONNEG-1">
            <sch:assert test="count(*[self::origin or self::scale or self::digits][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="origin" type="INT.NONNEG"/>
          <xsd:element minOccurs="0" name="scale" type="QTY"/>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="digit" type="INT"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="SLIST_INT.POS">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="required attributes">
          <sch:rule abstract="true" id="SLIST_INT.POS-0">
            <sch:assert test="@nullFlavor or (origin and not(origin\@nullFlavor) and count(*[digits\not(@nullFlavor))>0)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on SLIST attributes">
          <sch:rule abstract="true" id="SLIST_INT.POS-1">
            <sch:assert test="count(*[self::origin or self::scale or self::digits][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="origin" type="INT.POS"/>
          <xsd:element minOccurs="0" name="scale" type="QTY"/>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="digit" type="INT"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="GLIST_CO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="required attributes">
          <sch:rule abstract="true" id="GLIST_CO-0">
            <sch:assert test="@nullFlavor or (head and not(head\@nullFlavor) and increment and not(increment\@nullFlavor) and @denominator)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="denominator must be positive">
          <sch:rule abstract="true" id="GLIST_CO-1">
            <sch:assert test="not(@denominator) or (@denominator > 0)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="period must be positive">
          <sch:rule abstract="true" id="GLIST_CO-2">
            <sch:assert test="todo"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on GLIST attributes">
          <sch:rule abstract="true" id="GLIST_CO-3">
            <sch:assert test="count(*[self::head or self::increment][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="head" type="CO"/>
          <xsd:element minOccurs="0" name="increment" type="QTY"/>
        </xsd:sequence>
        <xsd:attribute name="denominator" type="xsd:int" use="optional"/>
        <xsd:attribute name="period" type="xsd:int" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="GLIST_TS">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="required attributes">
          <sch:rule abstract="true" id="GLIST_TS-0">
            <sch:assert test="@nullFlavor or (head and not(head\@nullFlavor) and increment and not(increment\@nullFlavor) and @denominator)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="denominator must be positive">
          <sch:rule abstract="true" id="GLIST_TS-1">
            <sch:assert test="not(@denominator) or (@denominator > 0)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="period must be positive">
          <sch:rule abstract="true" id="GLIST_TS-2">
            <sch:assert test="todo"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on GLIST attributes">
          <sch:rule abstract="true" id="GLIST_TS-3">
            <sch:assert test="count(*[self::head or self::increment][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="head" type="TS"/>
          <xsd:element minOccurs="0" name="increment" type="QTY"/>
        </xsd:sequence>
        <xsd:attribute name="denominator" type="xsd:int" use="optional"/>
        <xsd:attribute name="period" type="xsd:int" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="GLIST_TS.DATE">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="required attributes">
          <sch:rule abstract="true" id="GLIST_TS.DATE-0">
            <sch:assert test="@nullFlavor or (head and not(head\@nullFlavor) and increment and not(increment\@nullFlavor) and @denominator)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="denominator must be positive">
          <sch:rule abstract="true" id="GLIST_TS.DATE-1">
            <sch:assert test="not(@denominator) or (@denominator > 0)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="period must be positive">
          <sch:rule abstract="true" id="GLIST_TS.DATE-2">
            <sch:assert test="todo"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on GLIST attributes">
          <sch:rule abstract="true" id="GLIST_TS.DATE-3">
            <sch:assert test="count(*[self::head or self::increment][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="head" type="TS.DATE"/>
          <xsd:element minOccurs="0" name="increment" type="QTY"/>
        </xsd:sequence>
        <xsd:attribute name="denominator" type="xsd:int" use="optional"/>
        <xsd:attribute name="period" type="xsd:int" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="GLIST_TS.DATE.FULL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="required attributes">
          <sch:rule abstract="true" id="GLIST_TS.DATE.FULL-0">
            <sch:assert test="@nullFlavor or (head and not(head\@nullFlavor) and increment and not(increment\@nullFlavor) and @denominator)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="denominator must be positive">
          <sch:rule abstract="true" id="GLIST_TS.DATE.FULL-1">
            <sch:assert test="not(@denominator) or (@denominator > 0)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="period must be positive">
          <sch:rule abstract="true" id="GLIST_TS.DATE.FULL-2">
            <sch:assert test="todo"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on GLIST attributes">
          <sch:rule abstract="true" id="GLIST_TS.DATE.FULL-3">
            <sch:assert test="count(*[self::head or self::increment][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="head" type="TS.DATE.FULL"/>
          <xsd:element minOccurs="0" name="increment" type="QTY"/>
        </xsd:sequence>
        <xsd:attribute name="denominator" type="xsd:int" use="optional"/>
        <xsd:attribute name="period" type="xsd:int" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="GLIST_TS.DATETIME">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="required attributes">
          <sch:rule abstract="true" id="GLIST_TS.DATETIME-0">
            <sch:assert test="@nullFlavor or (head and not(head\@nullFlavor) and increment and not(increment\@nullFlavor) and @denominator)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="denominator must be positive">
          <sch:rule abstract="true" id="GLIST_TS.DATETIME-1">
            <sch:assert test="not(@denominator) or (@denominator > 0)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="period must be positive">
          <sch:rule abstract="true" id="GLIST_TS.DATETIME-2">
            <sch:assert test="todo"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on GLIST attributes">
          <sch:rule abstract="true" id="GLIST_TS.DATETIME-3">
            <sch:assert test="count(*[self::head or self::increment][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="head" type="TS.DATETIME"/>
          <xsd:element minOccurs="0" name="increment" type="QTY"/>
        </xsd:sequence>
        <xsd:attribute name="denominator" type="xsd:int" use="optional"/>
        <xsd:attribute name="period" type="xsd:int" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="GLIST_TS.DATETIME.FULL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="required attributes">
          <sch:rule abstract="true" id="GLIST_TS.DATETIME.FULL-0">
            <sch:assert test="@nullFlavor or (head and not(head\@nullFlavor) and increment and not(increment\@nullFlavor) and @denominator)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="denominator must be positive">
          <sch:rule abstract="true" id="GLIST_TS.DATETIME.FULL-1">
            <sch:assert test="not(@denominator) or (@denominator > 0)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="period must be positive">
          <sch:rule abstract="true" id="GLIST_TS.DATETIME.FULL-2">
            <sch:assert test="todo"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on GLIST attributes">
          © 307
ISO 2008  All rights reserved
          <sch:rule abstract="true" id="GLIST_TS.DATETIME.FULL-3">
            <sch:assert test="count(*[self::head or self::increment][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="head" type="TS.DATETIME.FULL"/>
          <xsd:element minOccurs="0" name="increment" type="QTY"/>
        </xsd:sequence>
        <xsd:attribute name="denominator" type="xsd:int" use="optional"/>
        <xsd:attribute name="period" type="xsd:int" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="GLIST_TS.BIRTH">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="required attributes">
          <sch:rule abstract="true" id="GLIST_TS.BIRTH-0">
            <sch:assert test="@nullFlavor or (head and not(head\@nullFlavor) and increment and not(increment\@nullFlavor) and @denominator)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="denominator must be positive">
          <sch:rule abstract="true" id="GLIST_TS.BIRTH-1">
            <sch:assert test="not(@denominator) or (@denominator > 0)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="period must be positive">
          <sch:rule abstract="true" id="GLIST_TS.BIRTH-2">
            <sch:assert test="todo"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on GLIST attributes">
          <sch:rule abstract="true" id="GLIST_TS.BIRTH-3">
            <sch:assert test="count(*[self::head or self::increment][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="head" type="TS.BIRTH"/>
          <xsd:element minOccurs="0" name="increment" type="QTY"/>
        </xsd:sequence>
        <xsd:attribute name="denominator" type="xsd:int" use="optional"/>
        <xsd:attribute name="period" type="xsd:int" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="GLIST_RTO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="required attributes">
          <sch:rule abstract="true" id="GLIST_RTO-0">
            <sch:assert test="@nullFlavor or (head and not(head\@nullFlavor) and increment and not(increment\@nullFlavor) and @denominator)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="denominator must be positive">
          <sch:rule abstract="true" id="GLIST_RTO-1">
            <sch:assert test="not(@denominator) or (@denominator > 0)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="period must be positive">
          <sch:rule abstract="true" id="GLIST_RTO-2">
            <sch:assert test="todo"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on GLIST attributes">
          <sch:rule abstract="true" id="GLIST_RTO-3">
            <sch:assert test="count(*[self::head or self::increment][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="head" type="RTO"/>
          <xsd:element minOccurs="0" name="increment" type="QTY"/>
        </xsd:sequence>
        <xsd:attribute name="denominator" type="xsd:int" use="optional"/>
        <xsd:attribute name="period" type="xsd:int" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="GLIST_MO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="required attributes">
          <sch:rule abstract="true" id="GLIST_MO-0">
            <sch:assert test="@nullFlavor or (head and not(head\@nullFlavor) and increment and not(increment\@nullFlavor) and @denominator)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="denominator must be positive">
          <sch:rule abstract="true" id="GLIST_MO-1">
            <sch:assert test="not(@denominator) or (@denominator > 0)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="period must be positive">
          <sch:rule abstract="true" id="GLIST_MO-2">
            <sch:assert test="todo"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on GLIST attributes">
          <sch:rule abstract="true" id="GLIST_MO-3">
            <sch:assert test="count(*[self::head or self::increment][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="head" type="MO"/>
          <xsd:element minOccurs="0" name="increment" type="QTY"/>
        </xsd:sequence>
        <xsd:attribute name="denominator" type="xsd:int" use="optional"/>
        <xsd:attribute name="period" type="xsd:int" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="GLIST_PQ">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="required attributes">
          <sch:rule abstract="true" id="GLIST_PQ-0">
            <sch:assert test="@nullFlavor or (head and not(head\@nullFlavor) and increment and not(increment\@nullFlavor) and @denominator)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="denominator must be positive">
          <sch:rule abstract="true" id="GLIST_PQ-1">
            <sch:assert test="not(@denominator) or (@denominator > 0)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="period must be positive">
          <sch:rule abstract="true" id="GLIST_PQ-2">
            <sch:assert test="todo"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on GLIST attributes">
          <sch:rule abstract="true" id="GLIST_PQ-3">
            <sch:assert test="count(*[self::head or self::increment][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="head" type="PQ"/>
          <xsd:element minOccurs="0" name="increment" type="QTY"/>
        </xsd:sequence>
        <xsd:attribute name="denominator" type="xsd:int" use="optional"/>
        <xsd:attribute name="period" type="xsd:int" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="GLIST_PQ.TIME">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="required attributes">
          <sch:rule abstract="true" id="GLIST_PQ.TIME-0">
            <sch:assert test="@nullFlavor or (head and not(head\@nullFlavor) and increment and not(increment\@nullFlavor) and @denominator)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="denominator must be positive">
          <sch:rule abstract="true" id="GLIST_PQ.TIME-1">
            <sch:assert test="not(@denominator) or (@denominator > 0)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="period must be positive">
          <sch:rule abstract="true" id="GLIST_PQ.TIME-2">
            <sch:assert test="todo"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on GLIST attributes">
          <sch:rule abstract="true" id="GLIST_PQ.TIME-3">
            <sch:assert test="count(*[self::head or self::increment][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="head" type="PQ.TIME"/>
          <xsd:element minOccurs="0" name="increment" type="QTY"/>
        </xsd:sequence>
        <xsd:attribute name="denominator" type="xsd:int" use="optional"/>
        <xsd:attribute name="period" type="xsd:int" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="GLIST_REAL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="required attributes">
          <sch:rule abstract="true" id="GLIST_REAL-0">
            <sch:assert test="@nullFlavor or (head and not(head\@nullFlavor) and increment and not(increment\@nullFlavor) and @denominator)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="denominator must be positive">
          <sch:rule abstract="true" id="GLIST_REAL-1">
            <sch:assert test="not(@denominator) or (@denominator > 0)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="period must be positive">
          <sch:rule abstract="true" id="GLIST_REAL-2">
            <sch:assert test="todo"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on GLIST attributes">
          <sch:rule abstract="true" id="GLIST_REAL-3">
            <sch:assert test="count(*[self::head or self::increment][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="head" type="REAL"/>
          <xsd:element minOccurs="0" name="increment" type="QTY"/>
        </xsd:sequence>
        <xsd:attribute name="denominator" type="xsd:int" use="optional"/>
        <xsd:attribute name="period" type="xsd:int" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="GLIST_INT">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="required attributes">
          <sch:rule abstract="true" id="GLIST_INT-0">
            <sch:assert test="@nullFlavor or (head and not(head\@nullFlavor) and increment and not(increment\@nullFlavor) and @denominator)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="denominator must be positive">
          <sch:rule abstract="true" id="GLIST_INT-1">
            <sch:assert test="not(@denominator) or (@denominator > 0)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="period must be positive">
          <sch:rule abstract="true" id="GLIST_INT-2">
            <sch:assert test="todo"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on GLIST attributes">
          <sch:rule abstract="true" id="GLIST_INT-3">
            <sch:assert test="count(*[self::head or self::increment][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="head" type="INT"/>
          <xsd:element minOccurs="0" name="increment" type="QTY"/>
        </xsd:sequence>
        <xsd:attribute name="denominator" type="xsd:int" use="optional"/>
        <xsd:attribute name="period" type="xsd:int" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="GLIST_INT.NONNEG">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="required attributes">
          <sch:rule abstract="true" id="GLIST_INT.NONNEG-0">
            <sch:assert test="@nullFlavor or (head and not(head\@nullFlavor) and increment and not(increment\@nullFlavor) and @denominator)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="denominator must be positive">
          <sch:rule abstract="true" id="GLIST_INT.NONNEG-1">
            <sch:assert test="not(@denominator) or (@denominator > 0)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="period must be positive">
          <sch:rule abstract="true" id="GLIST_INT.NONNEG-2">
            <sch:assert test="todo"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on GLIST attributes">
          <sch:rule abstract="true" id="GLIST_INT.NONNEG-3">
            <sch:assert test="count(*[self::head or self::increment][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="head" type="INT.NONNEG"/>
          <xsd:element minOccurs="0" name="increment" type="QTY"/>
        </xsd:sequence>
        <xsd:attribute name="denominator" type="xsd:int" use="optional"/>
        <xsd:attribute name="period" type="xsd:int" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="GLIST_INT.POS">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="required attributes">
          <sch:rule abstract="true" id="GLIST_INT.POS-0">
            <sch:assert test="@nullFlavor or (head and not(head\@nullFlavor) and increment and not(increment\@nullFlavor) and @denominator)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="denominator must be positive">
          <sch:rule abstract="true" id="GLIST_INT.POS-1">
            <sch:assert test="not(@denominator) or (@denominator > 0)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="period must be positive">
          <sch:rule abstract="true" id="GLIST_INT.POS-2">
            <sch:assert test="todo"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on GLIST attributes">
          <sch:rule abstract="true" id="GLIST_INT.POS-3">
            <sch:assert test="count(*[self::head or self::increment][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="head" type="INT.POS"/>
          <xsd:element minOccurs="0" name="increment" type="QTY"/>
        </xsd:sequence>
        <xsd:attribute name="denominator" type="xsd:int" use="optional"/>
        <xsd:attribute name="period" type="xsd:int" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSD_CO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSD_CO-0">
            <sch:assert test="@nullFlavor or (not(first/@nullFlavor) and not(second/@nullFlavor))"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_CO">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="first" type="QSET_CO"/>
          <xsd:element minOccurs="0" name="second" type="QSET_CO"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSD_TS">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSD_TS-0">
            <sch:assert test="@nullFlavor or (not(first/@nullFlavor) and not(second/@nullFlavor))"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_TS">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="first" type="QSET_TS"/>
          <xsd:element minOccurs="0" name="second" type="QSET_TS"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSD_TS.DATE">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSD_TS.DATE-0">
            <sch:assert test="@nullFlavor or (not(first/@nullFlavor) and not(second/@nullFlavor))"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_TS.DATE">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="first" type="QSET_TS.DATE"/>
          <xsd:element minOccurs="0" name="second" type="QSET_TS.DATE"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSD_TS.DATE.FULL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSD_TS.DATE.FULL-0">
            <sch:assert test="@nullFlavor or (not(first/@nullFlavor) and not(second/@nullFlavor))"/>
          </sch:rule>
          © 313
ISO 2008  All rights reserved
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_TS.DATE.FULL">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="first" type="QSET_TS.DATE.FULL"/>
          <xsd:element minOccurs="0" name="second" type="QSET_TS.DATE.FULL"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSD_TS.DATETIME">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSD_TS.DATETIME-0">
            <sch:assert test="@nullFlavor or (not(first/@nullFlavor) and not(second/@nullFlavor))"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_TS.DATETIME">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="first" type="QSET_TS.DATETIME"/>
          <xsd:element minOccurs="0" name="second" type="QSET_TS.DATETIME"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSD_TS.DATETIME.FULL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSD_TS.DATETIME.FULL-0">
            <sch:assert test="@nullFlavor or (not(first/@nullFlavor) and not(second/@nullFlavor))"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_TS.DATETIME.FULL">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="first" type="QSET_TS.DATETIME.FULL"/>
          <xsd:element minOccurs="0" name="second" type="QSET_TS.DATETIME.FULL"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSD_TS.BIRTH">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSD_TS.BIRTH-0">
            <sch:assert test="@nullFlavor or (not(first/@nullFlavor) and not(second/@nullFlavor))"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_TS.BIRTH">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="first" type="QSET_TS.BIRTH"/>
          <xsd:element minOccurs="0" name="second" type="QSET_TS.BIRTH"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSD_RTO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSD_RTO-0">
            <sch:assert test="@nullFlavor or (not(first/@nullFlavor) and not(second/@nullFlavor))"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_RTO">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="first" type="QSET_RTO"/>
          <xsd:element minOccurs="0" name="second" type="QSET_RTO"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSD_MO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSD_MO-0">
            <sch:assert test="@nullFlavor or (not(first/@nullFlavor) and not(second/@nullFlavor))"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_MO">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="first" type="QSET_MO"/>
          <xsd:element minOccurs="0" name="second" type="QSET_MO"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSD_PQ">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSD_PQ-0">
            <sch:assert test="@nullFlavor or (not(first/@nullFlavor) and not(second/@nullFlavor))"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_PQ">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="first" type="QSET_PQ"/>
          <xsd:element minOccurs="0" name="second" type="QSET_PQ"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSD_PQ.TIME">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSD_PQ.TIME-0">
            <sch:assert test="@nullFlavor or (not(first/@nullFlavor) and not(second/@nullFlavor))"/>
          </sch:rule>
        </sch:pattern>
        © 315
ISO 2008  All rights reserved
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_PQ.TIME">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="first" type="QSET_PQ.TIME"/>
          <xsd:element minOccurs="0" name="second" type="QSET_PQ.TIME"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSD_REAL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSD_REAL-0">
            <sch:assert test="@nullFlavor or (not(first/@nullFlavor) and not(second/@nullFlavor))"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_REAL">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="first" type="QSET_REAL"/>
          <xsd:element minOccurs="0" name="second" type="QSET_REAL"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSD_INT">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSD_INT-0">
            <sch:assert test="@nullFlavor or (not(first/@nullFlavor) and not(second/@nullFlavor))"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_INT">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="first" type="QSET_INT"/>
          <xsd:element minOccurs="0" name="second" type="QSET_INT"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSD_INT.NONNEG">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSD_INT.NONNEG-0">
            <sch:assert test="@nullFlavor or (not(first/@nullFlavor) and not(second/@nullFlavor))"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_INT.NONNEG">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="first" type="QSET_INT.NONNEG"/>
          <xsd:element minOccurs="0" name="second" type="QSET_INT.NONNEG"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSD_INT.POS">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSD_INT.POS-0">
            <sch:assert test="@nullFlavor or (not(first/@nullFlavor) and not(second/@nullFlavor))"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_INT.POS">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="first" type="QSET_INT.POS"/>
          <xsd:element minOccurs="0" name="second" type="QSET_INT.POS"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSI_CO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSI_CO-0">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSI_CO-1">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) >= 2)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_CO">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="term" type="QSET_CO"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSI_TS">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSI_TS-0">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSI_TS-1">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) >= 2)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_TS">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="term" type="QSET_TS"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSI_TS.DATE">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSI_TS.DATE-0">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
            © 317
ISO 2008  All rights reserved
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSI_TS.DATE-1">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) >= 2)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_TS.DATE">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="term" type="QSET_TS.DATE"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSI_TS.DATE.FULL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSI_TS.DATE.FULL-0">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSI_TS.DATE.FULL-1">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) >= 2)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_TS.DATE.FULL">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="term" type="QSET_TS.DATE.FULL"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSI_TS.DATETIME">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSI_TS.DATETIME-0">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSI_TS.DATETIME-1">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) >= 2)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_TS.DATETIME">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="term" type="QSET_TS.DATETIME"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSI_TS.DATETIME.FULL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSI_TS.DATETIME.FULL-0">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSI_TS.DATETIME.FULL-1">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) >= 2)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_TS.DATETIME.FULL">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="term" type="QSET_TS.DATETIME.FULL"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSI_TS.BIRTH">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSI_TS.BIRTH-0">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSI_TS.BIRTH-1">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) >= 2)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_TS.BIRTH">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="term" type="QSET_TS.BIRTH"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSI_RTO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSI_RTO-0">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSI_RTO-1">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) >= 2)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_RTO">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="term" type="QSET_RTO"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSI_MO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSI_MO-0">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
          </sch:rule>
        </sch:pattern>
        © 319
ISO 2008  All rights reserved
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSI_MO-1">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) >= 2)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_MO">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="term" type="QSET_MO"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSI_PQ">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSI_PQ-0">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSI_PQ-1">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) >= 2)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_PQ">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="term" type="QSET_PQ"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSI_PQ.TIME">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSI_PQ.TIME-0">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSI_PQ.TIME-1">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) >= 2)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_PQ.TIME">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="term" type="QSET_PQ.TIME"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSI_REAL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSI_REAL-0">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSI_REAL-1">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) >= 2)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_REAL">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="term" type="QSET_REAL"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSI_INT">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSI_INT-0">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSI_INT-1">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) >= 2)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_INT">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="term" type="QSET_INT"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSI_INT.NONNEG">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSI_INT.NONNEG-0">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSI_INT.NONNEG-1">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) >= 2)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_INT.NONNEG">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="term" type="QSET_INT.NONNEG"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSI_INT.POS">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSI_INT.POS-0">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSI_INT.POS-1">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) >= 2)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_INT.POS">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="term" type="QSET_INT.POS"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSU_CO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSU_CO-0">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSU_CO-1">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) >= 2)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_CO">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="term" type="QSET_CO"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSU_TS">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSU_TS-0">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSU_TS-1">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) >= 2)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_TS">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="term" type="QSET_TS"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSU_TS.DATE">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSU_TS.DATE-0">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSU_TS.DATE-1">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) >= 2)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_TS.DATE">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="term" type="QSET_TS.DATE"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSU_TS.DATE.FULL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSU_TS.DATE.FULL-0">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSU_TS.DATE.FULL-1">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) >= 2)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_TS.DATE.FULL">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="term" type="QSET_TS.DATE.FULL"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSU_TS.DATETIME">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSU_TS.DATETIME-0">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSU_TS.DATETIME-1">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) >= 2)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_TS.DATETIME">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="term" type="QSET_TS.DATETIME"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSU_TS.DATETIME.FULL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSU_TS.DATETIME.FULL-0">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSU_TS.DATETIME.FULL-1">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) >= 2)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_TS.DATETIME.FULL">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="term" type="QSET_TS.DATETIME.FULL"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSU_TS.BIRTH">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSU_TS.BIRTH-0">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSU_TS.BIRTH-1">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) >= 2)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_TS.BIRTH">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="term" type="QSET_TS.BIRTH"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSU_RTO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSU_RTO-0">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSU_RTO-1">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) >= 2)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_RTO">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="term" type="QSET_RTO"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSU_MO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSU_MO-0">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSU_MO-1">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) >= 2)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_MO">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="term" type="QSET_MO"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSU_PQ">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSU_PQ-0">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSU_PQ-1">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) >= 2)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_PQ">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="term" type="QSET_PQ"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSU_PQ.TIME">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSU_PQ.TIME-0">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSU_PQ.TIME-1">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) >= 2)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_PQ.TIME">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="term" type="QSET_PQ.TIME"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSU_REAL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSU_REAL-0">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSU_REAL-1">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) >= 2)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_REAL">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="term" type="QSET_REAL"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSU_INT">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSU_INT-0">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSU_INT-1">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) >= 2)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_INT">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="term" type="QSET_INT"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSU_INT.NONNEG">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSU_INT.NONNEG-0">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSU_INT.NONNEG-1">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) >= 2)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_INT.NONNEG">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="term" type="QSET_INT.NONNEG"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSU_INT.POS">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSU_INT.POS-0">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSU_INT.POS-1">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) >= 2)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_INT.POS">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="term" type="QSET_INT.POS"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSP_CO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSP_CO-0">
            <sch:assert test="@nullFlavor or (not(first/@nullFlavor) and not(second/@nullFlavor))"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_CO">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="first" type="QSET_CO"/>
          <xsd:element minOccurs="0" name="second" type="QSET_CO"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSP_TS">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSP_TS-0">
            <sch:assert test="@nullFlavor or (not(first/@nullFlavor) and not(second/@nullFlavor))"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_TS">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="first" type="QSET_TS"/>
          <xsd:element minOccurs="0" name="second" type="QSET_TS"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSP_TS.DATE">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSP_TS.DATE-0">
            <sch:assert test="@nullFlavor or (not(first/@nullFlavor) and not(second/@nullFlavor))"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_TS.DATE">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="first" type="QSET_TS.DATE"/>
          <xsd:element minOccurs="0" name="second" type="QSET_TS.DATE"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSP_TS.DATE.FULL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSP_TS.DATE.FULL-0">
            <sch:assert test="@nullFlavor or (not(first/@nullFlavor) and not(second/@nullFlavor))"/>
          </sch:rule>
        </sch:pattern>
        © 327
ISO 2008  All rights reserved
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_TS.DATE.FULL">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="first" type="QSET_TS.DATE.FULL"/>
          <xsd:element minOccurs="0" name="second" type="QSET_TS.DATE.FULL"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSP_TS.DATETIME">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSP_TS.DATETIME-0">
            <sch:assert test="@nullFlavor or (not(first/@nullFlavor) and not(second/@nullFlavor))"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_TS.DATETIME">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="first" type="QSET_TS.DATETIME"/>
          <xsd:element minOccurs="0" name="second" type="QSET_TS.DATETIME"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSP_TS.DATETIME.FULL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSP_TS.DATETIME.FULL-0">
            <sch:assert test="@nullFlavor or (not(first/@nullFlavor) and not(second/@nullFlavor))"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_TS.DATETIME.FULL">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="first" type="QSET_TS.DATETIME.FULL"/>
          <xsd:element minOccurs="0" name="second" type="QSET_TS.DATETIME.FULL"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSP_TS.BIRTH">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSP_TS.BIRTH-0">
            <sch:assert test="@nullFlavor or (not(first/@nullFlavor) and not(second/@nullFlavor))"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_TS.BIRTH">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="first" type="QSET_TS.BIRTH"/>
          <xsd:element minOccurs="0" name="second" type="QSET_TS.BIRTH"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSP_RTO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSP_RTO-0">
            <sch:assert test="@nullFlavor or (not(first/@nullFlavor) and not(second/@nullFlavor))"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_RTO">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="first" type="QSET_RTO"/>
          <xsd:element minOccurs="0" name="second" type="QSET_RTO"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSP_MO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSP_MO-0">
            <sch:assert test="@nullFlavor or (not(first/@nullFlavor) and not(second/@nullFlavor))"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_MO">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="first" type="QSET_MO"/>
          <xsd:element minOccurs="0" name="second" type="QSET_MO"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSP_PQ">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSP_PQ-0">
            <sch:assert test="@nullFlavor or (not(first/@nullFlavor) and not(second/@nullFlavor))"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_PQ">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="first" type="QSET_PQ"/>
          <xsd:element minOccurs="0" name="second" type="QSET_PQ"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSP_PQ.TIME">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSP_PQ.TIME-0">
            <sch:assert test="@nullFlavor or (not(first/@nullFlavor) and not(second/@nullFlavor))"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_PQ.TIME">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="first" type="QSET_PQ.TIME"/>
          <xsd:element minOccurs="0" name="second" type="QSET_PQ.TIME"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSP_REAL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSP_REAL-0">
            <sch:assert test="@nullFlavor or (not(first/@nullFlavor) and not(second/@nullFlavor))"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_REAL">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="first" type="QSET_REAL"/>
          <xsd:element minOccurs="0" name="second" type="QSET_REAL"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSP_INT">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSP_INT-0">
            <sch:assert test="@nullFlavor or (not(first/@nullFlavor) and not(second/@nullFlavor))"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_INT">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="first" type="QSET_INT"/>
          <xsd:element minOccurs="0" name="second" type="QSET_INT"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSP_INT.NONNEG">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSP_INT.NONNEG-0">
            <sch:assert test="@nullFlavor or (not(first/@nullFlavor) and not(second/@nullFlavor))"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_INT.NONNEG">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="first" type="QSET_INT.NONNEG"/>
          <xsd:element minOccurs="0" name="second" type="QSET_INT.NONNEG"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSP_INT.POS">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSP_INT.POS-0">
            <sch:assert test="@nullFlavor or (not(first/@nullFlavor) and not(second/@nullFlavor))"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_INT.POS">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="first" type="QSET_INT.POS"/>
          <xsd:element minOccurs="0" name="second" type="QSET_INT.POS"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSS_CO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSS_CO-0">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSS_CO-1">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) >= 1)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSS_CO-2">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSS_CO-3">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) >= 1)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_CO">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="term" type="CO"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSS_TS">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSS_TS-0">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSS_TS-1">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) >= 1)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSS_TS-2">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSS_TS-3">
            © 331
ISO 2008  All rights reserved
            <sch:assert test="@nullFlavor or (count(*[self::terms]) >= 1)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_TS">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="term" type="TS"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSS_TS.DATE">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSS_TS.DATE-0">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSS_TS.DATE-1">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) >= 1)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSS_TS.DATE-2">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSS_TS.DATE-3">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) >= 1)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_TS.DATE">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="term" type="TS.DATE"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSS_TS.DATE.FULL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSS_TS.DATE.FULL-0">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSS_TS.DATE.FULL-1">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) >= 1)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSS_TS.DATE.FULL-2">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSS_TS.DATE.FULL-3">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) >= 1)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_TS.DATE.FULL">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="term" type="TS.DATE.FULL"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSS_TS.DATETIME">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSS_TS.DATETIME-0">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSS_TS.DATETIME-1">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) >= 1)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSS_TS.DATETIME-2">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSS_TS.DATETIME-3">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) >= 1)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_TS.DATETIME">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="term" type="TS.DATETIME"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSS_TS.DATETIME.FULL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSS_TS.DATETIME.FULL-0">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSS_TS.DATETIME.FULL-1">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) >= 1)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSS_TS.DATETIME.FULL-2">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSS_TS.DATETIME.FULL-3">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) >= 1)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_TS.DATETIME.FULL">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="term" type="TS.DATETIME.FULL"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSS_TS.BIRTH">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSS_TS.BIRTH-0">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSS_TS.BIRTH-1">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) >= 1)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSS_TS.BIRTH-2">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSS_TS.BIRTH-3">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) >= 1)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_TS.BIRTH">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="term" type="TS.BIRTH"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSS_RTO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSS_RTO-0">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSS_RTO-1">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) >= 1)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSS_RTO-2">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSS_RTO-3">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) >= 1)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_RTO">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="term" type="RTO"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSS_MO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSS_MO-0">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSS_MO-1">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) >= 1)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSS_MO-2">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSS_MO-3">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) >= 1)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_MO">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="term" type="MO"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSS_PQ">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSS_PQ-0">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSS_PQ-1">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) >= 1)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSS_PQ-2">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSS_PQ-3">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) >= 1)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_PQ">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="term" type="PQ"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSS_PQ.TIME">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSS_PQ.TIME-0">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSS_PQ.TIME-1">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) >= 1)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSS_PQ.TIME-2">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSS_PQ.TIME-3">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) >= 1)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_PQ.TIME">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="term" type="PQ.TIME"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSS_REAL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSS_REAL-0">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSS_REAL-1">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) >= 1)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSS_REAL-2">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSS_REAL-3">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) >= 1)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_REAL">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="term" type="REAL"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSS_INT">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSS_INT-0">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSS_INT-1">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) >= 1)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSS_INT-2">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSS_INT-3">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) >= 1)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_INT">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="term" type="INT"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSS_INT.NONNEG">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSS_INT.NONNEG-0">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSS_INT.NONNEG-1">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) >= 1)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSS_INT.NONNEG-2">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSS_INT.NONNEG-3">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) >= 1)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_INT.NONNEG">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="term" type="INT.NONNEG"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSS_INT.POS">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSS_INT.POS-0">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSS_INT.POS-1">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) >= 1)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSS_INT.POS-2">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSS_INT.POS-3">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) >= 1)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_INT.POS">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="term" type="INT.POS"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="PIVL_TS">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="period or frequency">
          <sch:rule abstract="true" id="PIVL_TS-0">
            <sch:assert test="not(period) or not(frequency)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on PIVL attributes">
          <sch:rule abstract="true" id="PIVL_TS-1">
            <sch:assert test="count(*[self::phase or self::period][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_TS">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="phase" type="IVL_TS"/>
          <xsd:element minOccurs="0" name="period" type="PQ"/>
          <xsd:element minOccurs="0" name="frequency" type="RTO"/>
          <xsd:element minOccurs="0" name="count" type="INT.POS"/>
        </xsd:sequence>
        <xsd:attribute name="alignment" type="CalendarCycle" use="optional"/>
        <xsd:attribute name="isFlexible" type="xsd:boolean" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="PIVL_TS.DATE">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="period or frequency">
          <sch:rule abstract="true" id="PIVL_TS.DATE-0">
            <sch:assert test="not(period) or not(frequency)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on PIVL attributes">
          <sch:rule abstract="true" id="PIVL_TS.DATE-1">
            <sch:assert test="count(*[self::phase or self::period][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_TS.DATE">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="phase" type="IVL_TS.DATE"/>
          <xsd:element minOccurs="0" name="period" type="PQ"/>
          <xsd:element minOccurs="0" name="frequency" type="RTO"/>
          <xsd:element minOccurs="0" name="count" type="INT.POS"/>
        </xsd:sequence>
        <xsd:attribute name="alignment" type="CalendarCycle" use="optional"/>
        <xsd:attribute name="isFlexible" type="xsd:boolean" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="PIVL_TS.DATE.FULL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="period or frequency">
          <sch:rule abstract="true" id="PIVL_TS.DATE.FULL-0">
            <sch:assert test="not(period) or not(frequency)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on PIVL attributes">
          <sch:rule abstract="true" id="PIVL_TS.DATE.FULL-1">
            <sch:assert test="count(*[self::phase or self::period][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_TS.DATE.FULL">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="phase" type="IVL_TS.DATE.FULL"/>
          <xsd:element minOccurs="0" name="period" type="PQ"/>
          <xsd:element minOccurs="0" name="frequency" type="RTO"/>
          <xsd:element minOccurs="0" name="count" type="INT.POS"/>
        </xsd:sequence>
        <xsd:attribute name="alignment" type="CalendarCycle" use="optional"/>
        <xsd:attribute name="isFlexible" type="xsd:boolean" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="PIVL_TS.DATETIME">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="period or frequency">
          <sch:rule abstract="true" id="PIVL_TS.DATETIME-0">
            <sch:assert test="not(period) or not(frequency)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on PIVL attributes">
          <sch:rule abstract="true" id="PIVL_TS.DATETIME-1">
            <sch:assert test="count(*[self::phase or self::period][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_TS.DATETIME">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="phase" type="IVL_TS.DATETIME"/>
          <xsd:element minOccurs="0" name="period" type="PQ"/>
          <xsd:element minOccurs="0" name="frequency" type="RTO"/>
          <xsd:element minOccurs="0" name="count" type="INT.POS"/>
        </xsd:sequence>
        <xsd:attribute name="alignment" type="CalendarCycle" use="optional"/>
        <xsd:attribute name="isFlexible" type="xsd:boolean" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="PIVL_TS.DATETIME.FULL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="period or frequency">
          <sch:rule abstract="true" id="PIVL_TS.DATETIME.FULL-0">
            <sch:assert test="not(period) or not(frequency)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on PIVL attributes">
          <sch:rule abstract="true" id="PIVL_TS.DATETIME.FULL-1">
            <sch:assert test="count(*[self::phase or self::period][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
          © 339
ISO 2008  All rights reserved
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_TS.DATETIME.FULL">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="phase" type="IVL_TS.DATETIME.FULL"/>
          <xsd:element minOccurs="0" name="period" type="PQ"/>
          <xsd:element minOccurs="0" name="frequency" type="RTO"/>
          <xsd:element minOccurs="0" name="count" type="INT.POS"/>
        </xsd:sequence>
        <xsd:attribute name="alignment" type="CalendarCycle" use="optional"/>
        <xsd:attribute name="isFlexible" type="xsd:boolean" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="PIVL_TS.BIRTH">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="period or frequency">
          <sch:rule abstract="true" id="PIVL_TS.BIRTH-0">
            <sch:assert test="not(period) or not(frequency)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on PIVL attributes">
          <sch:rule abstract="true" id="PIVL_TS.BIRTH-1">
            <sch:assert test="count(*[self::phase or self::period][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_TS.BIRTH">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="phase" type="IVL_TS.BIRTH"/>
          <xsd:element minOccurs="0" name="period" type="PQ"/>
          <xsd:element minOccurs="0" name="frequency" type="RTO"/>
          <xsd:element minOccurs="0" name="count" type="INT.POS"/>
        </xsd:sequence>
        <xsd:attribute name="alignment" type="CalendarCycle" use="optional"/>
        <xsd:attribute name="isFlexible" type="xsd:boolean" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="EIVL_TS">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="required attributes">
          <sch:rule abstract="true" id="EIVL_TS-0">
            <sch:assert test="@nullFlavor or (event)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on EIVL attributes">
          <sch:rule abstract="true" id="EIVL_TS-1">
            <sch:assert test="count(*[self::offset][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_TS">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="offset" type="IVL_PQ"/>
        </xsd:sequence>
        <xsd:attribute name="event" type="TimingEvent" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="EIVL_TS.DATE">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="required attributes">
          <sch:rule abstract="true" id="EIVL_TS.DATE-0">
            <sch:assert test="@nullFlavor or (event)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on EIVL attributes">
          <sch:rule abstract="true" id="EIVL_TS.DATE-1">
            <sch:assert test="count(*[self::offset][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_TS.DATE">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="offset" type="IVL_PQ"/>
        </xsd:sequence>
        <xsd:attribute name="event" type="TimingEvent" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="EIVL_TS.DATE.FULL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="required attributes">
          <sch:rule abstract="true" id="EIVL_TS.DATE.FULL-0">
            <sch:assert test="@nullFlavor or (event)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on EIVL attributes">
          <sch:rule abstract="true" id="EIVL_TS.DATE.FULL-1">
            <sch:assert test="count(*[self::offset][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_TS.DATE.FULL">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="offset" type="IVL_PQ"/>
        </xsd:sequence>
        <xsd:attribute name="event" type="TimingEvent" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="EIVL_TS.DATETIME">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="required attributes">
          <sch:rule abstract="true" id="EIVL_TS.DATETIME-0">
            <sch:assert test="@nullFlavor or (event)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on EIVL attributes">
          <sch:rule abstract="true" id="EIVL_TS.DATETIME-1">
            <sch:assert test="count(*[self::offset][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_TS.DATETIME">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="offset" type="IVL_PQ"/>
        </xsd:sequence>
        <xsd:attribute name="event" type="TimingEvent" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="EIVL_TS.DATETIME.FULL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="required attributes">
          <sch:rule abstract="true" id="EIVL_TS.DATETIME.FULL-0">
            <sch:assert test="@nullFlavor or (event)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on EIVL attributes">
          <sch:rule abstract="true" id="EIVL_TS.DATETIME.FULL-1">
            <sch:assert test="count(*[self::offset][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_TS.DATETIME.FULL">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="offset" type="IVL_PQ"/>
        </xsd:sequence>
        <xsd:attribute name="event" type="TimingEvent" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="EIVL_TS.BIRTH">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="required attributes">
          <sch:rule abstract="true" id="EIVL_TS.BIRTH-0">
            <sch:assert test="@nullFlavor or (event)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on EIVL attributes">
          <sch:rule abstract="true" id="EIVL_TS.BIRTH-1">
            <sch:assert test="count(*[self::offset][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_TS.BIRTH">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="offset" type="IVL_PQ"/>
        </xsd:sequence>
        <xsd:attribute name="event" type="TimingEvent" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="NPPD_BL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="must have at least one item">
          <sch:rule abstract="true" id="NPPD_BL-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="UVP_BL"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="UVP_BL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="value not null">
          <sch:rule abstract="true" id="UVP_BL-0">
            <sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="must have probability">
          <sch:rule abstract="true" id="UVP_BL-1">
            <sch:assert test="@nullFlavor or @probability"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="UVP_BL-2">
            <sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="value" type="BL"/>
        </xsd:sequence>
        <xsd:attribute name="probability" type="xsd:double" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="NPPD_BL.NONNULL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="must have at least one item">
          <sch:rule abstract="true" id="NPPD_BL.NONNULL-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="UVP_BL.NONNULL"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="UVP_BL.NONNULL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="value not null">
          <sch:rule abstract="true" id="UVP_BL.NONNULL-0">
            <sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="must have probability">
          <sch:rule abstract="true" id="UVP_BL.NONNULL-1">
            <sch:assert test="@nullFlavor or @probability"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="UVP_BL.NONNULL-2">
            <sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="value" type="BL.NONNULL"/>
        </xsd:sequence>
        <xsd:attribute name="probability" type="xsd:double" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="NPPD_ED">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="must have at least one item">
          <sch:rule abstract="true" id="NPPD_ED-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="UVP_ED"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="UVP_ED">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="value not null">
          <sch:rule abstract="true" id="UVP_ED-0">
            <sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="must have probability">
          <sch:rule abstract="true" id="UVP_ED-1">
            <sch:assert test="@nullFlavor or @probability"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="UVP_ED-2">
            <sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="value" type="ED"/>
        </xsd:sequence>
        <xsd:attribute name="probability" type="xsd:double" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="NPPD_ED.IMAGE">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="must have at least one item">
          <sch:rule abstract="true" id="NPPD_ED.IMAGE-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="UVP_ED.IMAGE"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="UVP_ED.IMAGE">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="value not null">
          <sch:rule abstract="true" id="UVP_ED.IMAGE-0">
            <sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="must have probability">
          <sch:rule abstract="true" id="UVP_ED.IMAGE-1">
            <sch:assert test="@nullFlavor or @probability"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="UVP_ED.IMAGE-2">
            <sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="value" type="ED.IMAGE"/>
        </xsd:sequence>
        <xsd:attribute name="probability" type="xsd:double" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="NPPD_ED.TEXT">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="must have at least one item">
          <sch:rule abstract="true" id="NPPD_ED.TEXT-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="UVP_ED.TEXT"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="UVP_ED.TEXT">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="value not null">
          <sch:rule abstract="true" id="UVP_ED.TEXT-0">
            <sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="must have probability">
          <sch:rule abstract="true" id="UVP_ED.TEXT-1">
            <sch:assert test="@nullFlavor or @probability"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="UVP_ED.TEXT-2">
            <sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="value" type="ED.TEXT"/>
        </xsd:sequence>
        <xsd:attribute name="probability" type="xsd:double" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="NPPD_ED.DOC">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="must have at least one item">
          <sch:rule abstract="true" id="NPPD_ED.DOC-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="UVP_ED.DOC"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="UVP_ED.DOC">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="value not null">
          <sch:rule abstract="true" id="UVP_ED.DOC-0">
            <sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="must have probability">
          <sch:rule abstract="true" id="UVP_ED.DOC-1">
            <sch:assert test="@nullFlavor or @probability"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="UVP_ED.DOC-2">
            <sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="value" type="ED.DOC"/>
        </xsd:sequence>
        <xsd:attribute name="probability" type="xsd:double" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="NPPD_ED.DOC.REF">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="must have at least one item">
          <sch:rule abstract="true" id="NPPD_ED.DOC.REF-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="UVP_ED.DOC.REF"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="UVP_ED.DOC.REF">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="value not null">
          <sch:rule abstract="true" id="UVP_ED.DOC.REF-0">
            <sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="must have probability">
          <sch:rule abstract="true" id="UVP_ED.DOC.REF-1">
            <sch:assert test="@nullFlavor or @probability"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="UVP_ED.DOC.REF-2">
            <sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="value" type="ED.DOC.REF"/>
        </xsd:sequence>
        <xsd:attribute name="probability" type="xsd:double" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="NPPD_ED.DOC.INLINE">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="must have at least one item">
          <sch:rule abstract="true" id="NPPD_ED.DOC.INLINE-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="UVP_ED.DOC.INLINE"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="UVP_ED.DOC.INLINE">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="value not null">
          <sch:rule abstract="true" id="UVP_ED.DOC.INLINE-0">
            <sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="must have probability">
          <sch:rule abstract="true" id="UVP_ED.DOC.INLINE-1">
            <sch:assert test="@nullFlavor or @probability"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="UVP_ED.DOC.INLINE-2">
            <sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="value" type="ED.DOC.INLINE"/>
        </xsd:sequence>
        <xsd:attribute name="probability" type="xsd:double" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="NPPD_ED.SIGNATURE">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="must have at least one item">
          <sch:rule abstract="true" id="NPPD_ED.SIGNATURE-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="UVP_ED.SIGNATURE"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="UVP_ED.SIGNATURE">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="value not null">
          <sch:rule abstract="true" id="UVP_ED.SIGNATURE-0">
            <sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="must have probability">
          <sch:rule abstract="true" id="UVP_ED.SIGNATURE-1">
            <sch:assert test="@nullFlavor or @probability"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="UVP_ED.SIGNATURE-2">
            <sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="value" type="ED.SIGNATURE"/>
        </xsd:sequence>
        <xsd:attribute name="probability" type="xsd:double" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="NPPD_ED.STRUCTUREDTEXT">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="must have at least one item">
          <sch:rule abstract="true" id="NPPD_ED.STRUCTUREDTEXT-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="UVP_ED.STRUCTUREDTEXT"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="UVP_ED.STRUCTUREDTEXT">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="value not null">
          <sch:rule abstract="true" id="UVP_ED.STRUCTUREDTEXT-0">
            <sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="must have probability">
          <sch:rule abstract="true" id="UVP_ED.STRUCTUREDTEXT-1">
            <sch:assert test="@nullFlavor or @probability"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="UVP_ED.STRUCTUREDTEXT-2">
            <sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="value" type="ED.STRUCTUREDTEXT"/>
        </xsd:sequence>
        <xsd:attribute name="probability" type="xsd:double" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="NPPD_ST">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="must have at least one item">
          <sch:rule abstract="true" id="NPPD_ST-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="UVP_ST"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="UVP_ST">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="value not null">
          <sch:rule abstract="true" id="UVP_ST-0">
            <sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="must have probability">
          <sch:rule abstract="true" id="UVP_ST-1">
            <sch:assert test="@nullFlavor or @probability"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="UVP_ST-2">
            <sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="value" type="ST"/>
        </xsd:sequence>
        <xsd:attribute name="probability" type="xsd:double" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="NPPD_ST.NT">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="must have at least one item">
          <sch:rule abstract="true" id="NPPD_ST.NT-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="UVP_ST.NT"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="UVP_ST.NT">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="value not null">
          <sch:rule abstract="true" id="UVP_ST.NT-0">
            <sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="must have probability">
          <sch:rule abstract="true" id="UVP_ST.NT-1">
            <sch:assert test="@nullFlavor or @probability"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="UVP_ST.NT-2">
            <sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="value" type="ST.NT"/>
        </xsd:sequence>
        <xsd:attribute name="probability" type="xsd:double" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="NPPD_SC">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="must have at least one item">
          <sch:rule abstract="true" id="NPPD_SC-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="UVP_SC"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="UVP_SC">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="value not null">
          <sch:rule abstract="true" id="UVP_SC-0">
            <sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="must have probability">
          <sch:rule abstract="true" id="UVP_SC-1">
            <sch:assert test="@nullFlavor or @probability"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="UVP_SC-2">
            <sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="value" type="SC"/>
        </xsd:sequence>
        <xsd:attribute name="probability" type="xsd:double" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="NPPD_SC.NT">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="must have at least one item">
          <sch:rule abstract="true" id="NPPD_SC.NT-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="UVP_SC.NT"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="UVP_SC.NT">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="value not null">
          <sch:rule abstract="true" id="UVP_SC.NT-0">
            <sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="must have probability">
          <sch:rule abstract="true" id="UVP_SC.NT-1">
            <sch:assert test="@nullFlavor or @probability"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="UVP_SC.NT-2">
            © 351
ISO 2008  All rights reserved
            <sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="value" type="SC.NT"/>
        </xsd:sequence>
        <xsd:attribute name="probability" type="xsd:double" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="NPPD_TEL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="must have at least one item">
          <sch:rule abstract="true" id="NPPD_TEL-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="UVP_TEL"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="UVP_TEL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="value not null">
          <sch:rule abstract="true" id="UVP_TEL-0">
            <sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="must have probability">
          <sch:rule abstract="true" id="UVP_TEL-1">
            <sch:assert test="@nullFlavor or @probability"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="UVP_TEL-2">
            <sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="value" type="TEL"/>
        </xsd:sequence>
        <xsd:attribute name="probability" type="xsd:double" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="NPPD_TEL.EMAIL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="must have at least one item">
          <sch:rule abstract="true" id="NPPD_TEL.EMAIL-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="UVP_TEL.EMAIL"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="UVP_TEL.EMAIL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="value not null">
          <sch:rule abstract="true" id="UVP_TEL.EMAIL-0">
            <sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="must have probability">
          <sch:rule abstract="true" id="UVP_TEL.EMAIL-1">
            <sch:assert test="@nullFlavor or @probability"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="UVP_TEL.EMAIL-2">
            <sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="value" type="TEL.EMAIL"/>
        </xsd:sequence>
        <xsd:attribute name="probability" type="xsd:double" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="NPPD_TEL.PERSON">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="must have at least one item">
          <sch:rule abstract="true" id="NPPD_TEL.PERSON-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="UVP_TEL.PERSON"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="UVP_TEL.PERSON">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="value not null">
          <sch:rule abstract="true" id="UVP_TEL.PERSON-0">
            <sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="must have probability">
          <sch:rule abstract="true" id="UVP_TEL.PERSON-1">
            <sch:assert test="@nullFlavor or @probability"/>
          </sch:rule>
        </sch:pattern>
        © 353
ISO 2008  All rights reserved
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="UVP_TEL.PERSON-2">
            <sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="value" type="TEL.PERSON"/>
        </xsd:sequence>
        <xsd:attribute name="probability" type="xsd:double" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="NPPD_TEL.PHONE">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="must have at least one item">
          <sch:rule abstract="true" id="NPPD_TEL.PHONE-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="UVP_TEL.PHONE"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="UVP_TEL.PHONE">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="value not null">
          <sch:rule abstract="true" id="UVP_TEL.PHONE-0">
            <sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="must have probability">
          <sch:rule abstract="true" id="UVP_TEL.PHONE-1">
            <sch:assert test="@nullFlavor or @probability"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="UVP_TEL.PHONE-2">
            <sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="value" type="TEL.PHONE"/>
        </xsd:sequence>
        <xsd:attribute name="probability" type="xsd:double" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="NPPD_TEL.URL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="must have at least one item">
          <sch:rule abstract="true" id="NPPD_TEL.URL-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="UVP_TEL.URL"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="UVP_TEL.URL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="value not null">
          <sch:rule abstract="true" id="UVP_TEL.URL-0">
            <sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="must have probability">
          <sch:rule abstract="true" id="UVP_TEL.URL-1">
            <sch:assert test="@nullFlavor or @probability"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="UVP_TEL.URL-2">
            <sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="value" type="TEL.URL"/>
        </xsd:sequence>
        <xsd:attribute name="probability" type="xsd:double" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="NPPD_II">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="must have at least one item">
          <sch:rule abstract="true" id="NPPD_II-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="UVP_II"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="UVP_II">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="value not null">
          <sch:rule abstract="true" id="UVP_II-0">
            <sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="must have probability">
          <sch:rule abstract="true" id="UVP_II-1">
            <sch:assert test="@nullFlavor or @probability"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="UVP_II-2">
            <sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="value" type="II"/>
        </xsd:sequence>
        <xsd:attribute name="probability" type="xsd:double" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="NPPD_CD">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="must have at least one item">
          <sch:rule abstract="true" id="NPPD_CD-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="UVP_CD"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="UVP_CD">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="value not null">
          <sch:rule abstract="true" id="UVP_CD-0">
            <sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="must have probability">
          <sch:rule abstract="true" id="UVP_CD-1">
            <sch:assert test="@nullFlavor or @probability"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="UVP_CD-2">
            <sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="value" type="CD"/>
        </xsd:sequence>
        <xsd:attribute name="probability" type="xsd:double" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="NPPD_CD.CV">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="must have at least one item">
          <sch:rule abstract="true" id="NPPD_CD.CV-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="UVP_CD.CV"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="UVP_CD.CV">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="value not null">
          <sch:rule abstract="true" id="UVP_CD.CV-0">
            <sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="must have probability">
          <sch:rule abstract="true" id="UVP_CD.CV-1">
            <sch:assert test="@nullFlavor or @probability"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="UVP_CD.CV-2">
            <sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="value" type="CD.CV"/>
        </xsd:sequence>
        <xsd:attribute name="probability" type="xsd:double" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="NPPD_CO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="must have at least one item">
          <sch:rule abstract="true" id="NPPD_CO-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="UVP_CO"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="UVP_CO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="value not null">
          <sch:rule abstract="true" id="UVP_CO-0">
            <sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="must have probability">
          <sch:rule abstract="true" id="UVP_CO-1">
            <sch:assert test="@nullFlavor or @probability"/>
            © 357
ISO 2008  All rights reserved
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="UVP_CO-2">
            <sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="value" type="CO"/>
        </xsd:sequence>
        <xsd:attribute name="probability" type="xsd:double" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="NPPD_CS">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="must have at least one item">
          <sch:rule abstract="true" id="NPPD_CS-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="UVP_CS"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="UVP_CS">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="value not null">
          <sch:rule abstract="true" id="UVP_CS-0">
            <sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="must have probability">
          <sch:rule abstract="true" id="UVP_CS-1">
            <sch:assert test="@nullFlavor or @probability"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="UVP_CS-2">
            <sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="value" type="CS"/>
        </xsd:sequence>
        <xsd:attribute name="probability" type="xsd:double" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="NPPD_AD">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="must have at least one item">
          <sch:rule abstract="true" id="NPPD_AD-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="UVP_AD"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="UVP_AD">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="value not null">
          <sch:rule abstract="true" id="UVP_AD-0">
            <sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="must have probability">
          <sch:rule abstract="true" id="UVP_AD-1">
            <sch:assert test="@nullFlavor or @probability"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="UVP_AD-2">
            <sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="value" type="AD"/>
        </xsd:sequence>
        <xsd:attribute name="probability" type="xsd:double" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="NPPD_EN">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="must have at least one item">
          <sch:rule abstract="true" id="NPPD_EN-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="UVP_EN"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="UVP_EN">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="value not null">
          <sch:rule abstract="true" id="UVP_EN-0">
            <sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="must have probability">
          <sch:rule abstract="true" id="UVP_EN-1">
            © 359
ISO 2008  All rights reserved
            <sch:assert test="@nullFlavor or @probability"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="UVP_EN-2">
            <sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="value" type="EN"/>
        </xsd:sequence>
        <xsd:attribute name="probability" type="xsd:double" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="NPPD_EN.TN">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="must have at least one item">
          <sch:rule abstract="true" id="NPPD_EN.TN-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="UVP_EN.TN"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="UVP_EN.TN">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="value not null">
          <sch:rule abstract="true" id="UVP_EN.TN-0">
            <sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="must have probability">
          <sch:rule abstract="true" id="UVP_EN.TN-1">
            <sch:assert test="@nullFlavor or @probability"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="UVP_EN.TN-2">
            <sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="value" type="EN.TN"/>
        </xsd:sequence>
        <xsd:attribute name="probability" type="xsd:double" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="NPPD_EN.PN">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="must have at least one item">
          <sch:rule abstract="true" id="NPPD_EN.PN-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="UVP_EN.PN"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="UVP_EN.PN">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="value not null">
          <sch:rule abstract="true" id="UVP_EN.PN-0">
            <sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="must have probability">
          <sch:rule abstract="true" id="UVP_EN.PN-1">
            <sch:assert test="@nullFlavor or @probability"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="UVP_EN.PN-2">
            <sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="value" type="EN.PN"/>
        </xsd:sequence>
        <xsd:attribute name="probability" type="xsd:double" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="NPPD_EN.ON">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="must have at least one item">
          <sch:rule abstract="true" id="NPPD_EN.ON-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="UVP_EN.ON"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="UVP_EN.ON">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="value not null">
          <sch:rule abstract="true" id="UVP_EN.ON-0">
            <sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="must have probability">
          © 361
ISO 2008  All rights reserved
          <sch:rule abstract="true" id="UVP_EN.ON-1">
            <sch:assert test="@nullFlavor or @probability"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="UVP_EN.ON-2">
            <sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="value" type="EN.ON"/>
        </xsd:sequence>
        <xsd:attribute name="probability" type="xsd:double" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="NPPD_TS">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="must have at least one item">
          <sch:rule abstract="true" id="NPPD_TS-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="UVP_TS"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="UVP_TS">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="value not null">
          <sch:rule abstract="true" id="UVP_TS-0">
            <sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="must have probability">
          <sch:rule abstract="true" id="UVP_TS-1">
            <sch:assert test="@nullFlavor or @probability"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="UVP_TS-2">
            <sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="value" type="TS"/>
        </xsd:sequence>
        <xsd:attribute name="probability" type="xsd:double" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="NPPD_TS.DATE">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="must have at least one item">
          <sch:rule abstract="true" id="NPPD_TS.DATE-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="UVP_TS.DATE"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="UVP_TS.DATE">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="value not null">
          <sch:rule abstract="true" id="UVP_TS.DATE-0">
            <sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="must have probability">
          <sch:rule abstract="true" id="UVP_TS.DATE-1">
            <sch:assert test="@nullFlavor or @probability"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="UVP_TS.DATE-2">
            <sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="value" type="TS.DATE"/>
        </xsd:sequence>
        <xsd:attribute name="probability" type="xsd:double" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="NPPD_TS.DATE.FULL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="must have at least one item">
          <sch:rule abstract="true" id="NPPD_TS.DATE.FULL-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="UVP_TS.DATE.FULL"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="UVP_TS.DATE.FULL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="value not null">
          <sch:rule abstract="true" id="UVP_TS.DATE.FULL-0">
            <sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="must have probability">
          <sch:rule abstract="true" id="UVP_TS.DATE.FULL-1">
            <sch:assert test="@nullFlavor or @probability"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="UVP_TS.DATE.FULL-2">
            <sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="value" type="TS.DATE.FULL"/>
        </xsd:sequence>
        <xsd:attribute name="probability" type="xsd:double" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="NPPD_TS.DATETIME">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="must have at least one item">
          <sch:rule abstract="true" id="NPPD_TS.DATETIME-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="UVP_TS.DATETIME"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="UVP_TS.DATETIME">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="value not null">
          <sch:rule abstract="true" id="UVP_TS.DATETIME-0">
            <sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="must have probability">
          <sch:rule abstract="true" id="UVP_TS.DATETIME-1">
            <sch:assert test="@nullFlavor or @probability"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="UVP_TS.DATETIME-2">
            <sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="value" type="TS.DATETIME"/>
        </xsd:sequence>
        <xsd:attribute name="probability" type="xsd:double" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="NPPD_TS.DATETIME.FULL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="must have at least one item">
          <sch:rule abstract="true" id="NPPD_TS.DATETIME.FULL-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="UVP_TS.DATETIME.FULL"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="UVP_TS.DATETIME.FULL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="value not null">
          <sch:rule abstract="true" id="UVP_TS.DATETIME.FULL-0">
            <sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="must have probability">
          <sch:rule abstract="true" id="UVP_TS.DATETIME.FULL-1">
            <sch:assert test="@nullFlavor or @probability"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="UVP_TS.DATETIME.FULL-2">
            <sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="value" type="TS.DATETIME.FULL"/>
        </xsd:sequence>
        <xsd:attribute name="probability" type="xsd:double" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="NPPD_TS.BIRTH">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="must have at least one item">
          <sch:rule abstract="true" id="NPPD_TS.BIRTH-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="UVP_TS.BIRTH"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="UVP_TS.BIRTH">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="value not null">
          © 365
ISO 2008  All rights reserved
          <sch:rule abstract="true" id="UVP_TS.BIRTH-0">
            <sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="must have probability">
          <sch:rule abstract="true" id="UVP_TS.BIRTH-1">
            <sch:assert test="@nullFlavor or @probability"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="UVP_TS.BIRTH-2">
            <sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="value" type="TS.BIRTH"/>
        </xsd:sequence>
        <xsd:attribute name="probability" type="xsd:double" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="NPPD_RTO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="must have at least one item">
          <sch:rule abstract="true" id="NPPD_RTO-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="UVP_RTO"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="UVP_RTO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="value not null">
          <sch:rule abstract="true" id="UVP_RTO-0">
            <sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="must have probability">
          <sch:rule abstract="true" id="UVP_RTO-1">
            <sch:assert test="@nullFlavor or @probability"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="UVP_RTO-2">
            <sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="value" type="RTO"/>
        </xsd:sequence>
        <xsd:attribute name="probability" type="xsd:double" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="NPPD_MO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="must have at least one item">
          <sch:rule abstract="true" id="NPPD_MO-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="UVP_MO"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="UVP_MO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="value not null">
          <sch:rule abstract="true" id="UVP_MO-0">
            <sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="must have probability">
          <sch:rule abstract="true" id="UVP_MO-1">
            <sch:assert test="@nullFlavor or @probability"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="UVP_MO-2">
            <sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="value" type="MO"/>
        </xsd:sequence>
        <xsd:attribute name="probability" type="xsd:double" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="NPPD_PQ">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="must have at least one item">
          <sch:rule abstract="true" id="NPPD_PQ-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="UVP_PQ"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="UVP_PQ">
    <xsd:annotation>
      <xsd:appinfo>
        © 367
ISO 2008  All rights reserved
        <sch:pattern name="value not null">
          <sch:rule abstract="true" id="UVP_PQ-0">
            <sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="must have probability">
          <sch:rule abstract="true" id="UVP_PQ-1">
            <sch:assert test="@nullFlavor or @probability"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="UVP_PQ-2">
            <sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="value" type="PQ"/>
        </xsd:sequence>
        <xsd:attribute name="probability" type="xsd:double" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="NPPD_PQ.TIME">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="must have at least one item">
          <sch:rule abstract="true" id="NPPD_PQ.TIME-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="UVP_PQ.TIME"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="UVP_PQ.TIME">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="value not null">
          <sch:rule abstract="true" id="UVP_PQ.TIME-0">
            <sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="must have probability">
          <sch:rule abstract="true" id="UVP_PQ.TIME-1">
            <sch:assert test="@nullFlavor or @probability"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="UVP_PQ.TIME-2">
            <sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="value" type="PQ.TIME"/>
        </xsd:sequence>
        <xsd:attribute name="probability" type="xsd:double" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="NPPD_REAL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="must have at least one item">
          <sch:rule abstract="true" id="NPPD_REAL-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="UVP_REAL"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="UVP_REAL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="value not null">
          <sch:rule abstract="true" id="UVP_REAL-0">
            <sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="must have probability">
          <sch:rule abstract="true" id="UVP_REAL-1">
            <sch:assert test="@nullFlavor or @probability"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="UVP_REAL-2">
            <sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="value" type="REAL"/>
        </xsd:sequence>
        <xsd:attribute name="probability" type="xsd:double" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="NPPD_INT">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="must have at least one item">
          <sch:rule abstract="true" id="NPPD_INT-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="UVP_INT"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="UVP_INT">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="value not null">
          <sch:rule abstract="true" id="UVP_INT-0">
            <sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="must have probability">
          <sch:rule abstract="true" id="UVP_INT-1">
            <sch:assert test="@nullFlavor or @probability"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="UVP_INT-2">
            <sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="value" type="INT"/>
        </xsd:sequence>
        <xsd:attribute name="probability" type="xsd:double" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="NPPD_INT.NONNEG">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="must have at least one item">
          <sch:rule abstract="true" id="NPPD_INT.NONNEG-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="UVP_INT.NONNEG"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="UVP_INT.NONNEG">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="value not null">
          <sch:rule abstract="true" id="UVP_INT.NONNEG-0">
            <sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="must have probability">
          <sch:rule abstract="true" id="UVP_INT.NONNEG-1">
            <sch:assert test="@nullFlavor or @probability"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="UVP_INT.NONNEG-2">
            <sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="value" type="INT.NONNEG"/>
        </xsd:sequence>
        <xsd:attribute name="probability" type="xsd:double" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="NPPD_INT.POS">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="must have at least one item">
          <sch:rule abstract="true" id="NPPD_INT.POS-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="item" type="UVP_INT.POS"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="UVP_INT.POS">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="value not null">
          <sch:rule abstract="true" id="UVP_INT.POS-0">
            <sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="must have probability">
          <sch:rule abstract="true" id="UVP_INT.POS-1">
            <sch:assert test="@nullFlavor or @probability"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="UVP_INT.POS-2">
            <sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="value" type="INT.POS"/>
        </xsd:sequence>
        <xsd:attribute name="probability" type="xsd:double" use="optional"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSET.BOUNDEDPIVL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="QSET.BOUNDEDPIVL 2">
          <sch:rule abstract="true" id="QSET.BOUNDEDPIVL-0">
            <sch:assert test="count(*)=2"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="QSI_TS">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element maxOccurs="unbounded" minOccurs="0" name="term" type="QSET_TS"/>
        </xsd:sequence>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="HIST_BL">
    <xsd:complexContent>
      <xsd:extension base="LIST_BL"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="HIST_BL.NONNULL">
    <xsd:complexContent>
      <xsd:extension base="LIST_BL.NONNULL"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="HIST_ED">
    <xsd:complexContent>
      <xsd:extension base="LIST_ED"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="HIST_ED.IMAGE">
    <xsd:complexContent>
      <xsd:extension base="LIST_ED.IMAGE"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="HIST_ED.TEXT">
    <xsd:complexContent>
      <xsd:extension base="LIST_ED.TEXT"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="HIST_ED.DOC">
    <xsd:complexContent>
      <xsd:extension base="LIST_ED.DOC"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="HIST_ED.DOC.REF">
    <xsd:complexContent>
      <xsd:extension base="LIST_ED.DOC.REF"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="HIST_ED.DOC.INLINE">
    <xsd:complexContent>
      <xsd:extension base="LIST_ED.DOC.INLINE"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="HIST_ED.SIGNATURE">
    <xsd:complexContent>
      <xsd:extension base="LIST_ED.SIGNATURE"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="HIST_ED.STRUCTUREDTEXT">
    <xsd:complexContent>
      <xsd:extension base="LIST_ED.STRUCTUREDTEXT"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="HIST_ED.STRUCTUREDTITLE">
    <xsd:complexContent>
      <xsd:extension base="LIST_ED.STRUCTUREDTITLE"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="HIST_ST">
    <xsd:complexContent>
      <xsd:extension base="LIST_ST"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="HIST_ST.NT">
    <xsd:complexContent>
      <xsd:extension base="LIST_ST.NT"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="HIST_SC">
    <xsd:complexContent>
      <xsd:extension base="LIST_SC"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="HIST_SC.NT">
    <xsd:complexContent>
      <xsd:extension base="LIST_SC.NT"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="HIST_TEL">
    <xsd:complexContent>
      <xsd:extension base="LIST_TEL"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="HIST_TEL.EMAIL">
    <xsd:complexContent>
      <xsd:extension base="LIST_TEL.EMAIL"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="HIST_TEL.PERSON">
    <xsd:complexContent>
      <xsd:extension base="LIST_TEL.PERSON"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="HIST_TEL.PHONE">
    <xsd:complexContent>
      <xsd:extension base="LIST_TEL.PHONE"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="HIST_TEL.URL">
    <xsd:complexContent>
      <xsd:extension base="LIST_TEL.URL"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="HIST_II">
    <xsd:complexContent>
      <xsd:extension base="LIST_II"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="HIST_CD">
    <xsd:complexContent>
      <xsd:extension base="LIST_CD"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="HIST_CD.CV">
    <xsd:complexContent>
      <xsd:extension base="LIST_CD.CV"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="HIST_CO">
    <xsd:complexContent>
      <xsd:extension base="LIST_CO"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="HIST_CS">
    <xsd:complexContent>
      <xsd:extension base="LIST_CS"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="HIST_AD">
    <xsd:complexContent>
      <xsd:extension base="LIST_AD"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="HIST_EN">
    <xsd:complexContent>
      <xsd:extension base="LIST_EN"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="HIST_EN.TN">
    <xsd:complexContent>
      <xsd:extension base="LIST_EN.TN"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="HIST_EN.PN">
    <xsd:complexContent>
      <xsd:extension base="LIST_EN.PN"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="HIST_EN.ON">
    <xsd:complexContent>
      <xsd:extension base="LIST_EN.ON"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="HIST_TS">
    <xsd:complexContent>
      <xsd:extension base="LIST_TS"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="HIST_TS.DATE">
    <xsd:complexContent>
      <xsd:extension base="LIST_TS.DATE"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="HIST_TS.DATE.FULL">
    <xsd:complexContent>
      <xsd:extension base="LIST_TS.DATE.FULL"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="HIST_TS.DATETIME">
    <xsd:complexContent>
      <xsd:extension base="LIST_TS.DATETIME"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="HIST_TS.DATETIME.FULL">
    <xsd:complexContent>
      <xsd:extension base="LIST_TS.DATETIME.FULL"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="HIST_TS.BIRTH">
    <xsd:complexContent>
      <xsd:extension base="LIST_TS.BIRTH"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="HIST_RTO">
    <xsd:complexContent>
      <xsd:extension base="LIST_RTO"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="HIST_MO">
    <xsd:complexContent>
      <xsd:extension base="LIST_MO"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="HIST_PQ">
    <xsd:complexContent>
      <xsd:extension base="LIST_PQ"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="HIST_PQ.TIME">
    <xsd:complexContent>
      <xsd:extension base="LIST_PQ.TIME"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="HIST_REAL">
    <xsd:complexContent>
      <xsd:extension base="LIST_REAL"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="HIST_INT">
    <xsd:complexContent>
      <xsd:extension base="LIST_INT"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="HIST_INT.NONNEG">
    <xsd:complexContent>
      <xsd:extension base="LIST_INT.NONNEG"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="HIST_INT.POS">
    <xsd:complexContent>
      <xsd:extension base="LIST_INT.POS"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="URG_CO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="no inner attributes">
          <sch:rule abstract="true" id="URG_CO-0">
            <sch:assert test="not(@validTimeLow) and not(@validTimeHigh) and not (@controlActRoot) and not(@controlActExtension) and not(@flavorId) and not(@nullFlavor) and not(@updateMode) and not(expression) and not(originalText) and not(uncertainty) and not(@uncertaintyType)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QTY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="low" type="CO"/>
          <xsd:element minOccurs="0" name="high" type="CO"/>
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="optional"/>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="optional"/>
      </xsd:extension>
      <!--<xsd:complexType name="URG_TS.DATETIME"> TODO-->
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="URG_TS">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="no inner attributes">
          <sch:rule abstract="true" id="URG_TS-0">
            <sch:assert test="not(@validTimeLow) and not(@validTimeHigh) and not (@controlActRoot) and not(@controlActExtension) and not(@flavorId) and not(@nullFlavor) and not(@updateMode) and not(expression) and not(originalText) and not(uncertainty) and not(@uncertaintyType)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QTY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="low" type="TS"/>
          <xsd:element minOccurs="0" name="high" type="TS"/>
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="optional"/>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="optional"/>
      </xsd:extension>
      <!--<xsd:attribute name="nullFlavor" type="NullFlavor" fixed="UNK" use="optional"/>-->
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="URG_TS.DATE">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="no inner attributes">
          <sch:rule abstract="true" id="URG_TS.DATE-0">
            <sch:assert test="not(@validTimeLow) and not(@validTimeHigh) and not (@controlActRoot) and not(@controlActExtension) and not(@flavorId) and not(@nullFlavor) and not(@updateMode) and not(expression) and not(originalText) and not(uncertainty) and not(@uncertaintyType)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QTY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="low" type="TS.DATE"/>
          <xsd:element minOccurs="0" name="high" type="TS.DATE"/>
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="optional"/>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="optional"/>
      </xsd:extension>
      <!--<xsd:attribute name="nullFlavor" type="NullFlavor" fixed="UNK" use="optional"/> TODO-->
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="URG_TS.DATE.FULL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="no inner attributes">
          <sch:rule abstract="true" id="URG_TS.DATE.FULL-0">
            <sch:assert test="not(@validTimeLow) and not(@validTimeHigh) and not (@controlActRoot) and not(@controlActExtension) and not(@flavorId) and not(@nullFlavor) and not(@updateMode) and not(expression) and not(originalText) and not(uncertainty) and not(@uncertaintyType)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QTY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="low" type="TS.DATE.FULL"/>
          <xsd:element minOccurs="0" name="high" type="TS.DATE.FULL"/>
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="optional"/>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="optional"/>
      </xsd:extension>
      <!--<xsd:attribute name="nullFlavor" type="NullFlavor" fixed="UNK" use="optional"/> OBS!!!!-->
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="URG_TS.DATETIME">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="no inner attributes">
          <sch:rule abstract="true" id="URG_TS.DATETIME-0">
            <sch:assert test="not(@validTimeLow) and not(@validTimeHigh) and not (@controlActRoot) and not(@controlActExtension) and not(@flavorId) and not(@nullFlavor) and not(@updateMode) and not(expression) and not(originalText) and not(uncertainty) and not(@uncertaintyType)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QTY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="low" type="TS.DATETIME"/>
          <xsd:element minOccurs="0" name="high" type="TS.DATETIME"/>
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="optional"/>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="optional"/>
      </xsd:extension>
      <!--<xsd:attribute name="nullFlavor" type="NullFlavor" fixed="UNK" use="optional"/>-->
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="URG_TS.DATETIME.FULL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="no inner attributes">
          <sch:rule abstract="true" id="URG_TS.DATETIME.FULL-0">
            <sch:assert test="not(@validTimeLow) and not(@validTimeHigh) and not (@controlActRoot) and not(@controlActExtension) and not(@flavorId) and not(@nullFlavor) and not(@updateMode) and not(expression) and not(originalText) and not(uncertainty) and not(@uncertaintyType)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QTY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="low" type="TS.DATETIME.FULL"/>
          <xsd:element minOccurs="0" name="high" type="TS.DATETIME.FULL"/>
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="optional"/>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="optional"/>
      </xsd:extension>
      <!--<xsd:complexType name="URG_TS.DATETIME"> TODO-->
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="URG_TS.BIRTH">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="no inner attributes">
          <sch:rule abstract="true" id="URG_TS.BIRTH-0">
            <sch:assert test="not(@validTimeLow) and not(@validTimeHigh) and not (@controlActRoot) and not(@controlActExtension) and not(@flavorId) and not(@nullFlavor) and not(@updateMode) and not(expression) and not(originalText) and not(uncertainty) and not(@uncertaintyType)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QTY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="low" type="TS.BIRTH"/>
          <xsd:element minOccurs="0" name="high" type="TS.BIRTH"/>
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="optional"/>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="optional"/>
      </xsd:extension>
      <!--<xsd:attribute name="nullFlavor" type="NullFlavor" fixed="UNK" use="optional"/> TODO-->
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="URG_RTO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="no inner attributes">
          <sch:rule abstract="true" id="URG_RTO-0">
            <sch:assert test="not(@validTimeLow) and not(@validTimeHigh) and not (@controlActRoot) and not(@controlActExtension) and not(@flavorId) and not(@nullFlavor) and not(@updateMode) and not(expression) and not(originalText) and not(uncertainty) and not(@uncertaintyType)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QTY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="low" type="RTO"/>
          <xsd:element minOccurs="0" name="high" type="RTO"/>
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="optional"/>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="optional"/>
      </xsd:extension>
      <!--<xsd:attribute name="nullFlavor" type="NullFlavor" fixed="UNK" use="optional"/>-->
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="URG_MO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="no inner attributes">
          <sch:rule abstract="true" id="URG_MO-0">
            <sch:assert test="not(@validTimeLow) and not(@validTimeHigh) and not (@controlActRoot) and not(@controlActExtension) and not(@flavorId) and not(@nullFlavor) and not(@updateMode) and not(expression) and not(originalText) and not(uncertainty) and not(@uncertaintyType)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QTY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="low" type="MO"/>
          <xsd:element minOccurs="0" name="high" type="MO"/>
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="optional"/>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="optional"/>
      </xsd:extension>
      <!--<xsd:attribute name="nullFlavor" type="NullFlavor" fixed="UNK" use="optional"/> TODO-->
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="URG_PQ">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="no inner attributes">
          <sch:rule abstract="true" id="URG_PQ-0">
            <sch:assert test="not(@validTimeLow) and not(@validTimeHigh) and not (@controlActRoot) and not(@controlActExtension) and not(@flavorId) and not(@nullFlavor) and not(@updateMode) and not(expression) and not(originalText) and not(uncertainty) and not(@uncertaintyType)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QTY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="low" type="PQ"/>
          <xsd:element minOccurs="0" name="high" type="PQ"/>
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="optional"/>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="optional"/>
      </xsd:extension>
      <!--<xsd:attribute name="nullFlavor" type="NullFlavor" fixed="UNK" use="optional"/> TODO-->
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="URG_PQ.TIME">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="no inner attributes">
          <sch:rule abstract="true" id="URG_PQ.TIME-0">
            <sch:assert test="not(@validTimeLow) and not(@validTimeHigh) and not (@controlActRoot) and not(@controlActExtension) and not(@flavorId) and not(@nullFlavor) and not(@updateMode) and not(expression) and not(originalText) and not(uncertainty) and not(@uncertaintyType)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QTY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="low" type="PQ.TIME"/>
          <xsd:element minOccurs="0" name="high" type="PQ.TIME"/>
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="optional"/>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="optional"/>
      </xsd:extension>
      <!--<xsd:complexType name="URG_TS.DATETIME"> TODO-->
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="URG_REAL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="no inner attributes">
          <sch:rule abstract="true" id="URG_REAL-0">
            <sch:assert test="not(@validTimeLow) and not(@validTimeHigh) and not (@controlActRoot) and not(@controlActExtension) and not(@flavorId) and not(@nullFlavor) and not(@updateMode) and not(expression) and not(originalText) and not(uncertainty) and not(@uncertaintyType)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QTY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="low" type="REAL"/>
          <xsd:element minOccurs="0" name="high" type="REAL"/>
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="optional"/>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="optional"/>
      </xsd:extension>
      <!--<xsd:complexType name="URG_TS.DATETIME"> TODO-->
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="URG_INT">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="no inner attributes">
          <sch:rule abstract="true" id="URG_INT-0">
            <sch:assert test="not(@validTimeLow) and not(@validTimeHigh) and not (@controlActRoot) and not(@controlActExtension) and not(@flavorId) and not(@nullFlavor) and not(@updateMode) and not(expression) and not(originalText) and not(uncertainty) and not(@uncertaintyType)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QTY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="low" type="INT"/>
          <xsd:element minOccurs="0" name="high" type="INT"/>
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="optional"/>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="optional"/>
      </xsd:extension>
      <!--<xsd:attribute name="nullFlavor" type="NullFlavor" fixed="UNK" use="optional"/>-->
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="URG_INT.NONNEG">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="no inner attributes">
          <sch:rule abstract="true" id="URG_INT.NONNEG-0">
            <sch:assert test="not(@validTimeLow) and not(@validTimeHigh) and not (@controlActRoot) and not(@controlActExtension) and not(@flavorId) and not(@nullFlavor) and not(@updateMode) and not(expression) and not(originalText) and not(uncertainty) and not(@uncertaintyType)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QTY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="low" type="INT.NONNEG"/>
          <xsd:element minOccurs="0" name="high" type="INT.NONNEG"/>
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="optional"/>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="optional"/>
      </xsd:extension>
      <!--<xsd:complexType name="URG_TS.DATETIME"> TODO-->
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="URG_INT.POS">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="no inner attributes">
          <sch:rule abstract="true" id="URG_INT.POS-0">
            <sch:assert test="not(@validTimeLow) and not(@validTimeHigh) and not (@controlActRoot) and not(@controlActExtension) and not(@flavorId) and not(@nullFlavor) and not(@updateMode) and not(expression) and not(originalText) and not(uncertainty) and not(@uncertaintyType)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QTY">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="low" type="INT.POS"/>
          <xsd:element minOccurs="0" name="high" type="INT.POS"/>
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="optional"/>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="optional"/>
      </xsd:extension>
      <!--<xsd:attribute name="nullFlavor" type="NullFlavor" fixed="UNK" use="optional"/>-->
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="URG.LOW_CO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="URG.LOW_CO-0">
            <sch:assert test="low and not(low\@nullFlavor) and (@lowClosed = &quot;true&quot;)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="URG.LOW_CO-1">
            <sch:assert test="not(high) and not(@highClosed)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="URG_CO">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="expression" type="ED"/>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element minOccurs="0" name="uncertainty" type="QTY"/>
          <xsd:element minOccurs="0" name="low" type="CO"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="high" type="CO"/>
        </xsd:sequence>
        <xsd:attribute fixed="UNK" name="nullFlavor" type="NullFlavor"/>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="prohibited"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="URG.LOW_TS">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="URG.LOW_TS-0">
            <sch:assert test="low and not(low\@nullFlavor) and (@lowClosed = &quot;true&quot;)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="URG.LOW_TS-1">
            <sch:assert test="not(high) and not(@highClosed)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="URG_TS">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="expression" type="ED"/>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element minOccurs="0" name="uncertainty" type="QTY"/>
          <xsd:element minOccurs="0" name="low" type="TS"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="high" type="TS"/>
        </xsd:sequence>
        <xsd:attribute fixed="UNK" name="nullFlavor" type="NullFlavor"/>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="prohibited"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="URG.LOW_TS.DATE">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="URG.LOW_TS.DATE-0">
            <sch:assert test="low and not(low\@nullFlavor) and (@lowClosed = &quot;true&quot;)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="URG.LOW_TS.DATE-1">
            <sch:assert test="not(high) and not(@highClosed)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="URG_TS.DATE">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="expression" type="ED"/>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element minOccurs="0" name="uncertainty" type="QTY"/>
          <xsd:element minOccurs="0" name="low" type="TS.DATE"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="high" type="TS.DATE"/>
        </xsd:sequence>
        <xsd:attribute fixed="UNK" name="nullFlavor" type="NullFlavor"/>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="prohibited"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="URG.LOW_TS.DATE.FULL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="URG.LOW_TS.DATE.FULL-0">
            <sch:assert test="low and not(low\@nullFlavor) and (@lowClosed = &quot;true&quot;)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="URG.LOW_TS.DATE.FULL-1">
            <sch:assert test="not(high) and not(@highClosed)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="URG_TS.DATE.FULL">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="expression" type="ED"/>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element minOccurs="0" name="uncertainty" type="QTY"/>
          <xsd:element minOccurs="0" name="low" type="TS.DATE.FULL"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="high" type="TS.DATE.FULL"/>
        </xsd:sequence>
        <xsd:attribute fixed="UNK" name="nullFlavor" type="NullFlavor"/>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="prohibited"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="URG.LOW_TS.DATETIME">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="URG.LOW_TS.DATETIME-0">
            <sch:assert test="low and not(low\@nullFlavor) and (@lowClosed = &quot;true&quot;)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="URG.LOW_TS.DATETIME-1">
            <sch:assert test="not(high) and not(@highClosed)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="URG_TS.DATETIME">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="expression" type="ED"/>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element minOccurs="0" name="uncertainty" type="QTY"/>
          <xsd:element minOccurs="0" name="low" type="TS.DATETIME"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="high" type="TS.DATETIME"/>
        </xsd:sequence>
        <xsd:attribute fixed="UNK" name="nullFlavor" type="NullFlavor"/>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="prohibited"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="URG.LOW_TS.DATETIME.FULL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="URG.LOW_TS.DATETIME.FULL-0">
            <sch:assert test="low and not(low\@nullFlavor) and (@lowClosed = &quot;true&quot;)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="URG.LOW_TS.DATETIME.FULL-1">
            <sch:assert test="not(high) and not(@highClosed)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="URG_TS.DATETIME.FULL">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="expression" type="ED"/>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element minOccurs="0" name="uncertainty" type="QTY"/>
          <xsd:element minOccurs="0" name="low" type="TS.DATETIME.FULL"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="high" type="TS.DATETIME.FULL"/>
        </xsd:sequence>
        <xsd:attribute fixed="UNK" name="nullFlavor" type="NullFlavor"/>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="prohibited"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="URG.LOW_TS.BIRTH">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="URG.LOW_TS.BIRTH-0">
            <sch:assert test="low and not(low\@nullFlavor) and (@lowClosed = &quot;true&quot;)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="URG.LOW_TS.BIRTH-1">
            <sch:assert test="not(high) and not(@highClosed)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="URG_TS.BIRTH">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="expression" type="ED"/>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element minOccurs="0" name="uncertainty" type="QTY"/>
          <xsd:element minOccurs="0" name="low" type="TS.BIRTH"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="high" type="TS.BIRTH"/>
        </xsd:sequence>
        <xsd:attribute fixed="UNK" name="nullFlavor" type="NullFlavor"/>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="prohibited"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="URG.LOW_RTO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="URG.LOW_RTO-0">
            <sch:assert test="low and not(low\@nullFlavor) and (@lowClosed = &quot;true&quot;)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="URG.LOW_RTO-1">
            <sch:assert test="not(high) and not(@highClosed)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="URG_RTO">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="expression" type="ED"/>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element minOccurs="0" name="uncertainty" type="QTY"/>
          <xsd:element minOccurs="0" name="low" type="RTO"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="high" type="RTO"/>
        </xsd:sequence>
        <xsd:attribute fixed="UNK" name="nullFlavor" type="NullFlavor"/>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="prohibited"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="URG.LOW_MO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="URG.LOW_MO-0">
            <sch:assert test="low and not(low\@nullFlavor) and (@lowClosed = &quot;true&quot;)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="URG.LOW_MO-1">
            <sch:assert test="not(high) and not(@highClosed)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="URG_MO">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="expression" type="ED"/>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element minOccurs="0" name="uncertainty" type="QTY"/>
          <xsd:element minOccurs="0" name="low" type="MO"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="high" type="MO"/>
        </xsd:sequence>
        <xsd:attribute fixed="UNK" name="nullFlavor" type="NullFlavor"/>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="prohibited"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="URG.LOW_PQ">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="URG.LOW_PQ-0">
            <sch:assert test="low and not(low\@nullFlavor) and (@lowClosed = &quot;true&quot;)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="URG.LOW_PQ-1">
            <sch:assert test="not(high) and not(@highClosed)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="URG_PQ">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="expression" type="ED"/>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element minOccurs="0" name="uncertainty" type="QTY"/>
          <xsd:element minOccurs="0" name="low" type="PQ"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="high" type="PQ"/>
        </xsd:sequence>
        <xsd:attribute fixed="UNK" name="nullFlavor" type="NullFlavor"/>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="prohibited"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="URG.LOW_PQ.TIME">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="URG.LOW_PQ.TIME-0">
            <sch:assert test="low and not(low\@nullFlavor) and (@lowClosed = &quot;true&quot;)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="URG.LOW_PQ.TIME-1">
            <sch:assert test="not(high) and not(@highClosed)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="URG_PQ.TIME">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="expression" type="ED"/>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element minOccurs="0" name="uncertainty" type="QTY"/>
          <xsd:element minOccurs="0" name="low" type="PQ.TIME"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="high" type="PQ.TIME"/>
        </xsd:sequence>
        <xsd:attribute fixed="UNK" name="nullFlavor" type="NullFlavor"/>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="prohibited"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="URG.LOW_REAL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="URG.LOW_REAL-0">
            <sch:assert test="low and not(low\@nullFlavor) and (@lowClosed = &quot;true&quot;)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="URG.LOW_REAL-1">
            <sch:assert test="not(high) and not(@highClosed)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="URG_REAL">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="expression" type="ED"/>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element minOccurs="0" name="uncertainty" type="QTY"/>
          <xsd:element minOccurs="0" name="low" type="REAL"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="high" type="REAL"/>
        </xsd:sequence>
        <xsd:attribute fixed="UNK" name="nullFlavor" type="NullFlavor"/>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="prohibited"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="URG.LOW_INT">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="URG.LOW_INT-0">
            <sch:assert test="low and not(low\@nullFlavor) and (@lowClosed = &quot;true&quot;)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="URG.LOW_INT-1">
            <sch:assert test="not(high) and not(@highClosed)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="URG_INT">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="expression" type="ED"/>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element minOccurs="0" name="uncertainty" type="QTY"/>
          <xsd:element minOccurs="0" name="low" type="INT"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="high" type="INT"/>
        </xsd:sequence>
        <xsd:attribute fixed="UNK" name="nullFlavor" type="NullFlavor"/>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="prohibited"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="URG.LOW_INT.NONNEG">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="URG.LOW_INT.NONNEG-0">
            <sch:assert test="low and not(low\@nullFlavor) and (@lowClosed = &quot;true&quot;)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="URG.LOW_INT.NONNEG-1">
            <sch:assert test="not(high) and not(@highClosed)"/>
          </sch:rule>
        </sch:pattern>
        © 385
ISO 2008  All rights reserved
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="URG_INT.NONNEG">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="expression" type="ED"/>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element minOccurs="0" name="uncertainty" type="QTY"/>
          <xsd:element minOccurs="0" name="low" type="INT.NONNEG"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="high" type="INT.NONNEG"/>
        </xsd:sequence>
        <xsd:attribute fixed="UNK" name="nullFlavor" type="NullFlavor"/>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="prohibited"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="URG.LOW_INT.POS">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="URG.LOW_INT.POS-0">
            <sch:assert test="low and not(low\@nullFlavor) and (@lowClosed = &quot;true&quot;)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="URG.LOW_INT.POS-1">
            <sch:assert test="not(high) and not(@highClosed)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="URG_INT.POS">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="expression" type="ED"/>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element minOccurs="0" name="uncertainty" type="QTY"/>
          <xsd:element minOccurs="0" name="low" type="INT.POS"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="high" type="INT.POS"/>
        </xsd:sequence>
        <xsd:attribute fixed="UNK" name="nullFlavor" type="NullFlavor"/>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="prohibited"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="URG.HIGH_CO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="URG.HIGH_CO-0">
            <sch:assert test="high and not(high\@nullFlavor) and (@highClosed = &quot;true&quot;)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="URG.HIGH_CO-1">
            <sch:assert test="not(low) and not(@lowClosed)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="URG_CO">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="expression" type="ED"/>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element minOccurs="0" name="uncertainty" type="QTY"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="low" type="CO"/>
          <xsd:element minOccurs="0" name="high" type="CO"/>
        </xsd:sequence>
        <xsd:attribute fixed="UNK" name="nullFlavor" type="NullFlavor"/>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="prohibited"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="URG.HIGH_TS">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="URG.HIGH_TS-0">
            <sch:assert test="high and not(high\@nullFlavor) and (@highClosed = &quot;true&quot;)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="URG.HIGH_TS-1">
            <sch:assert test="not(low) and not(@lowClosed)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="URG_TS">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="expression" type="ED"/>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element minOccurs="0" name="uncertainty" type="QTY"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="low" type="TS"/>
          <xsd:element minOccurs="0" name="high" type="TS"/>
        </xsd:sequence>
        <xsd:attribute fixed="UNK" name="nullFlavor" type="NullFlavor"/>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="prohibited"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="URG.HIGH_TS.DATE">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="URG.HIGH_TS.DATE-0">
            <sch:assert test="high and not(high\@nullFlavor) and (@highClosed = &quot;true&quot;)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="URG.HIGH_TS.DATE-1">
            <sch:assert test="not(low) and not(@lowClosed)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="URG_TS.DATE">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="expression" type="ED"/>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element minOccurs="0" name="uncertainty" type="QTY"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="low" type="TS.DATE"/>
          <xsd:element minOccurs="0" name="high" type="TS.DATE"/>
        </xsd:sequence>
        <xsd:attribute fixed="UNK" name="nullFlavor" type="NullFlavor"/>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="prohibited"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="URG.HIGH_TS.DATE.FULL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="URG.HIGH_TS.DATE.FULL-0">
            <sch:assert test="high and not(high\@nullFlavor) and (@highClosed = &quot;true&quot;)"/>
            © 387
ISO 2008  All rights reserved
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="URG.HIGH_TS.DATE.FULL-1">
            <sch:assert test="not(low) and not(@lowClosed)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="URG_TS.DATE.FULL">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="expression" type="ED"/>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element minOccurs="0" name="uncertainty" type="QTY"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="low" type="TS.DATE.FULL"/>
          <xsd:element minOccurs="0" name="high" type="TS.DATE.FULL"/>
        </xsd:sequence>
        <xsd:attribute fixed="UNK" name="nullFlavor" type="NullFlavor"/>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="prohibited"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="URG.HIGH_TS.DATETIME">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="URG.HIGH_TS.DATETIME-0">
            <sch:assert test="high and not(high\@nullFlavor) and (@highClosed = &quot;true&quot;)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="URG.HIGH_TS.DATETIME-1">
            <sch:assert test="not(low) and not(@lowClosed)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="URG_TS.DATETIME">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="expression" type="ED"/>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element minOccurs="0" name="uncertainty" type="QTY"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="low" type="TS.DATETIME"/>
          <xsd:element minOccurs="0" name="high" type="TS.DATETIME"/>
        </xsd:sequence>
        <xsd:attribute fixed="UNK" name="nullFlavor" type="NullFlavor"/>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="prohibited"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="URG.HIGH_TS.DATETIME.FULL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="URG.HIGH_TS.DATETIME.FULL-0">
            <sch:assert test="high and not(high\@nullFlavor) and (@highClosed = &quot;true&quot;)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="URG.HIGH_TS.DATETIME.FULL-1">
            <sch:assert test="not(low) and not(@lowClosed)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="URG_TS.DATETIME.FULL">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="expression" type="ED"/>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element minOccurs="0" name="uncertainty" type="QTY"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="low" type="TS.DATETIME.FULL"/>
          <xsd:element minOccurs="0" name="high" type="TS.DATETIME.FULL"/>
        </xsd:sequence>
        <xsd:attribute fixed="UNK" name="nullFlavor" type="NullFlavor"/>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="prohibited"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="URG.HIGH_TS.BIRTH">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="URG.HIGH_TS.BIRTH-0">
            <sch:assert test="high and not(high\@nullFlavor) and (@highClosed = &quot;true&quot;)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="URG.HIGH_TS.BIRTH-1">
            <sch:assert test="not(low) and not(@lowClosed)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="URG_TS.BIRTH">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="expression" type="ED"/>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element minOccurs="0" name="uncertainty" type="QTY"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="low" type="TS.BIRTH"/>
          <xsd:element minOccurs="0" name="high" type="TS.BIRTH"/>
        </xsd:sequence>
        <xsd:attribute fixed="UNK" name="nullFlavor" type="NullFlavor"/>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="prohibited"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="URG.HIGH_RTO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="URG.HIGH_RTO-0">
            <sch:assert test="high and not(high\@nullFlavor) and (@highClosed = &quot;true&quot;)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="URG.HIGH_RTO-1">
            <sch:assert test="not(low) and not(@lowClosed)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="URG_RTO">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="expression" type="ED"/>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element minOccurs="0" name="uncertainty" type="QTY"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="low" type="RTO"/>
          <xsd:element minOccurs="0" name="high" type="RTO"/>
        </xsd:sequence>
        <xsd:attribute fixed="UNK" name="nullFlavor" type="NullFlavor"/>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="prohibited"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="URG.HIGH_MO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="URG.HIGH_MO-0">
            <sch:assert test="high and not(high\@nullFlavor) and (@highClosed = &quot;true&quot;)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="URG.HIGH_MO-1">
            <sch:assert test="not(low) and not(@lowClosed)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="URG_MO">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="expression" type="ED"/>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element minOccurs="0" name="uncertainty" type="QTY"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="low" type="MO"/>
          <xsd:element minOccurs="0" name="high" type="MO"/>
        </xsd:sequence>
        <xsd:attribute fixed="UNK" name="nullFlavor" type="NullFlavor"/>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="prohibited"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="URG.HIGH_PQ">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="URG.HIGH_PQ-0">
            <sch:assert test="high and not(high\@nullFlavor) and (@highClosed = &quot;true&quot;)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="URG.HIGH_PQ-1">
            <sch:assert test="not(low) and not(@lowClosed)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="URG_PQ">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="expression" type="ED"/>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element minOccurs="0" name="uncertainty" type="QTY"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="low" type="PQ"/>
          <xsd:element minOccurs="0" name="high" type="PQ"/>
        </xsd:sequence>
        <xsd:attribute fixed="UNK" name="nullFlavor" type="NullFlavor"/>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="prohibited"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="URG.HIGH_PQ.TIME">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="URG.HIGH_PQ.TIME-0">
            <sch:assert test="high and not(high\@nullFlavor) and (@highClosed = &quot;true&quot;)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="URG.HIGH_PQ.TIME-1">
            <sch:assert test="not(low) and not(@lowClosed)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="URG_PQ.TIME">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="expression" type="ED"/>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element minOccurs="0" name="uncertainty" type="QTY"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="low" type="PQ.TIME"/>
          <xsd:element minOccurs="0" name="high" type="PQ.TIME"/>
        </xsd:sequence>
        <xsd:attribute fixed="UNK" name="nullFlavor" type="NullFlavor"/>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="prohibited"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="URG.HIGH_REAL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="URG.HIGH_REAL-0">
            <sch:assert test="high and not(high\@nullFlavor) and (@highClosed = &quot;true&quot;)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="URG.HIGH_REAL-1">
            <sch:assert test="not(low) and not(@lowClosed)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="URG_REAL">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="expression" type="ED"/>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element minOccurs="0" name="uncertainty" type="QTY"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="low" type="REAL"/>
          <xsd:element minOccurs="0" name="high" type="REAL"/>
        </xsd:sequence>
        <xsd:attribute fixed="UNK" name="nullFlavor" type="NullFlavor"/>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="prohibited"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="URG.HIGH_INT">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="URG.HIGH_INT-0">
            <sch:assert test="high and not(high\@nullFlavor) and (@highClosed = &quot;true&quot;)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="URG.HIGH_INT-1">
            <sch:assert test="not(low) and not(@lowClosed)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="URG_INT">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="expression" type="ED"/>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element minOccurs="0" name="uncertainty" type="QTY"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="low" type="INT"/>
          <xsd:element minOccurs="0" name="high" type="INT"/>
        </xsd:sequence>
        <xsd:attribute fixed="UNK" name="nullFlavor" type="NullFlavor"/>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="prohibited"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="URG.HIGH_INT.NONNEG">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="URG.HIGH_INT.NONNEG-0">
            <sch:assert test="high and not(high\@nullFlavor) and (@highClosed = &quot;true&quot;)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="URG.HIGH_INT.NONNEG-1">
            <sch:assert test="not(low) and not(@lowClosed)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="URG_INT.NONNEG">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="expression" type="ED"/>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element minOccurs="0" name="uncertainty" type="QTY"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="low" type="INT.NONNEG"/>
          <xsd:element minOccurs="0" name="high" type="INT.NONNEG"/>
        </xsd:sequence>
        <xsd:attribute fixed="UNK" name="nullFlavor" type="NullFlavor"/>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="prohibited"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="URG.HIGH_INT.POS">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="URG.HIGH_INT.POS-0">
            <sch:assert test="high and not(high\@nullFlavor) and (@highClosed=&quot;true&quot;)"/>
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="URG.HIGH_INT.POS-1">
            <sch:assert test="not(low) and not(@lowClosed)"/>
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="URG_INT.POS">
        <xsd:sequence>
          <xsd:element minOccurs="0" name="expression" type="ED"/>
          <xsd:element minOccurs="0" name="originalText" type="ED.TEXT"/>
          <xsd:element minOccurs="0" name="uncertainty" type="QTY"/>
          <xsd:element maxOccurs="0" minOccurs="0" name="low" type="INT.POS"/>
          <xsd:element minOccurs="0" name="high" type="INT.POS"/>
        </xsd:sequence>
        <xsd:attribute fixed="UNK" name="nullFlavor" type="NullFlavor"/>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="prohibited"/>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
</xsd:schema>]]></con:content><con:type>http://www.w3.org/2001/XMLSchema</con:type></con:part><con:part><con:url>http://localhost:11000/npoadapter/getehrextract/stub?xsd=../../core_components/itintegration_registry_1.0.xsd</con:url><con:content><![CDATA[<xs:schema elementFormDefault="qualified" targetNamespace="urn:riv:itintegration:registry:1" version="1.0" xmlns="urn:riv:itintegration:registry:1" xmlns:xs="http://www.w3.org/2001/XMLSchema">
  <xs:annotation>
    <xs:documentation>Beskrivning: 	Grundläggande informationsobjekt för domänen itintegration:registry (adressering av tjänster)
			
			Revisionshistorik: 2011-06-27 Mats Ekhammar, Callista Enterprise AB
				Added ServiceContractType
			
			Datum:			2011-05-04
			Beskrivning:	Initial version
			Författare:		marcus.krantz@callistaenterprise.se</xs:documentation>
  </xs:annotation>
  <xs:element name="LogicalAddress" type="LogicalAddressType"/>
  <xs:element name="ServiceContract" type="ServiceContractType"/>
  <xs:simpleType name="LogicalAddressType">
    <xs:annotation>
      <xs:documentation>Defines the type for logical address according to national reference architecture.
				Superseeds wsa:To as type for logical address header in RIVTA 2.1.</xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:string"/>
  </xs:simpleType>
  <xs:complexType name="ServiceContractType">
    <xs:annotation>
      <xs:documentation>Type which describes a service contract. Used in interaction GetSupportedServiceContracts.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="ServiceContractNamespace" type="xs:anyURI"/>
      <xs:any maxOccurs="unbounded" minOccurs="0" namespace="##other" processContents="lax"/>
    </xs:sequence>
  </xs:complexType>
</xs:schema>]]></con:content><con:type>http://www.w3.org/2001/XMLSchema</con:type></con:part></con:definitionCache><con:endpoints><con:endpoint>http://localhost:11000/npoadapter/getehrextract/stub</con:endpoint></con:endpoints><con:operation isOneWay="false" action="urn:riv:ehr:patientsummary:GetEhrExtractResponder:1:GetEhrExtract" name="GetEhrExtract" bindingOperationName="GetEhrExtract" type="Request-Response" inputName="" receivesAttachments="false" sendsAttachments="false" anonymous="optional"><con:settings/><con:call name="Request 1"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;xml-fragment/></con:setting></con:settings><con:encoding>UTF-8</con:encoding><con:endpoint>http://localhost:11000/npoadapter/getehrextract/stub</con:endpoint><con:request><![CDATA[<soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/" xmlns:urn="urn:riv:itintegration:registry:1" xmlns:urn1="urn:riv:ehr:patientsummary:GetEhrExtractResponder:1" xmlns:urn2="urn:riv:ehr:patientsummary:1">
   <soapenv:Header>
      <urn:LogicalAddress>?</urn:LogicalAddress>
   </soapenv:Header>
   <soapenv:Body>
      <urn1:GetEhrExtract>
 		<urn1:subject_of_care_id root="1.2.752.129.2.1.3.1" extension="193812217044"/>
		<urn1:time_period><urn2:low value="20080101"/><urn2:high value="20080520"/></urn1:time_period>	
		<urn1:meanings code="vko"/>
		<urn1:max_records value="100"/>		
		<urn1:parameters>
			<urn1:name value="hsa_id" />
			<urn1:value value="123456" />
		</urn1:parameters>
      </urn1:GetEhrExtract>
   </soapenv:Body>
</soapenv:Envelope>]]></con:request><con:credentials><con:authType>Global HTTP Settings</con:authType></con:credentials><con:jmsConfig JMSDeliveryMode="PERSISTENT"/><con:jmsPropertyConfig/><con:wsaConfig mustUnderstand="NONE" version="200508" action="urn:riv:ehr:patientsummary:GetEhrExtractResponder:1:GetEhrExtract"/><con:wsrmConfig version="1.2"/></con:call></con:operation></con:interface><con:interface xsi:type="con:WsdlInterface" wsaVersion="NONE" name="NPOSoap" type="wsdl" bindingName="{http://nationellpatientoversikt.se}NPOSoap" soapVersion="1_1" anonymous="optional" definition="http://localhost:11000/npoadapter/npo?wsdl" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"><con:settings/><con:definitionCache type="TEXT" rootPart="http://localhost:11000/npoadapter/npo?wsdl"><con:part><con:url>http://localhost:11000/npoadapter/npo?wsdl</con:url><con:content><![CDATA[<definitions targetNamespace="http://nationellpatientoversikt.se" xmlns="http://schemas.xmlsoap.org/wsdl/" xmlns:SOAP-ENC="http://schemas.xmlsoap.org/soap/encoding/" xmlns:mime="http://schemas.xmlsoap.org/wsdl/mime/" xmlns:s="http://www.w3.org/2001/XMLSchema" xmlns:s0="http://nationellpatientoversikt.se" xmlns:soap="http://schemas.xmlsoap.org/wsdl/soap/" xmlns:wsdl="http://schemas.xmlsoap.org/wsdl/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
  <types>
    <s:schema elementFormDefault="qualified" targetNamespace="http://nationellpatientoversikt.se">
      <s:element name="CheckConsistency">
        <s:complexType>
          <s:sequence>
            <s:element minOccurs="0" name="subject_of_care_id" type="s:string"/>
            <s:element minOccurs="0" name="from_time" type="s:dateTime"/>
            <s:element minOccurs="0" name="parameters" type="s0:ArrayOfparameternpoParameter_type"/>
          </s:sequence>
        </s:complexType>
      </s:element>
      <s:complexType name="ArrayOfparameternpoParameter_type">
        <s:sequence>
          <s:element maxOccurs="unbounded" minOccurs="0" name="parameter" nillable="true" type="s0:npoParameter_type"/>
        </s:sequence>
      </s:complexType>
      <s:complexType name="npoParameter_type">
        <s:sequence>
          <s:element minOccurs="0" name="name" type="s:string"/>
          <s:element minOccurs="0" name="value" type="s:string"/>
        </s:sequence>
      </s:complexType>
      <s:element name="CheckConsistencyResponse">
        <s:complexType>
          <s:sequence>
            <s:element minOccurs="0" name="updates" type="s0:ArrayOfcheck_consistencyCheckConsistency_type"/>
            <s:element minOccurs="0" name="response_details" type="s0:ArrayOfresponse_detailnpoResponse_detail_type"/>
          </s:sequence>
        </s:complexType>
      </s:element>
      <s:complexType name="ArrayOfcheck_consistencyCheckConsistency_type">
        <s:sequence>
          <s:element maxOccurs="unbounded" minOccurs="0" name="check_consistency" nillable="true" type="s0:CheckConsistency_type"/>
        </s:sequence>
      </s:complexType>
      <s:complexType name="CheckConsistency_type">
        <s:sequence>
          <s:element minOccurs="0" name="is_delete" type="s:boolean"/>
          <s:element minOccurs="0" name="transaction_id" type="s:string"/>
          <s:element minOccurs="0" name="registration_time" type="s:dateTime"/>
          <s:element minOccurs="0" name="rc_id" type="s:string"/>
        </s:sequence>
      </s:complexType>
      <s:complexType name="ArrayOfresponse_detailnpoResponse_detail_type">
        <s:sequence>
          <s:element maxOccurs="unbounded" minOccurs="0" name="response_detail" nillable="true" type="s0:npoResponse_detail_type"/>
        </s:sequence>
      </s:complexType>
      <s:complexType name="npoResponse_detail_type">
        <s:simpleContent>
          <s:extension base="s:string">
            <s:attribute name="kind">
              <s:simpleType>
                <s:restriction base="s:string">
                  <s:maxLength value="1"/>
                  <s:enumeration value="E"/>
                  <s:enumeration value="W"/>
                  <s:enumeration value="I"/>
                </s:restriction>
              </s:simpleType>
            </s:attribute>
            <s:attribute name="code" type="s:string"/>
          </s:extension>
        </s:simpleContent>
      </s:complexType>
      <s:element name="GetConsistencyList">
        <s:complexType>
          <s:sequence>
            <s:element minOccurs="0" name="parameters" type="s0:ArrayOfparameternpoParameter_type"/>
            <s:element minOccurs="0" name="from_time" type="s:dateTime"/>
          </s:sequence>
        </s:complexType>
      </s:element>
      <s:element name="GetConsistencyListResponse">
        <s:complexType>
          <s:sequence>
            <s:element minOccurs="0" name="subject_of_care_ids" type="s0:ArrayOfsubject_of_care_idString"/>
            <s:element minOccurs="0" name="response_details" type="s0:ArrayOfresponse_detailnpoResponse_detail_type"/>
          </s:sequence>
        </s:complexType>
      </s:element>
      <s:complexType name="ArrayOfsubject_of_care_idString">
        <s:sequence>
          <s:element maxOccurs="unbounded" minOccurs="0" name="subject_of_care_id" nillable="true" type="s:string"/>
        </s:sequence>
      </s:complexType>
      <s:element name="NotifyAlive">
        <s:complexType>
          <s:sequence>
            <s:element minOccurs="0" name="parameters" type="s0:ArrayOfparameternpoParameter_type"/>
          </s:sequence>
        </s:complexType>
      </s:element>
      <s:element name="NotifyAliveResponse">
        <s:complexType>
          <s:sequence>
            <s:element minOccurs="0" name="success" type="s:boolean"/>
          </s:sequence>
        </s:complexType>
      </s:element>
      <s:element name="SendDeletions">
        <s:complexType>
          <s:sequence>
            <s:element minOccurs="0" name="subject_of_care_id" type="s:string"/>
            <s:element minOccurs="0" name="deletions" type="s0:ArrayOfdeletionDeletion_type"/>
            <s:element minOccurs="0" name="parameters" type="s0:ArrayOfparameternpoParameter_type"/>
          </s:sequence>
        </s:complexType>
      </s:element>
      <s:complexType name="ArrayOfdeletionDeletion_type">
        <s:sequence>
          <s:element maxOccurs="unbounded" minOccurs="0" name="deletion" nillable="true" type="s0:Deletion_type"/>
        </s:sequence>
      </s:complexType>
      <s:complexType name="Deletion_type">
        <s:sequence>
          <s:element minOccurs="0" name="rc_id" type="s:string"/>
          <s:element minOccurs="0" name="info_type_id" type="s:string"/>
          <s:element minOccurs="0" name="registration_time" type="s:dateTime"/>
        </s:sequence>
      </s:complexType>
      <s:element name="SendDeletionsResponse">
        <s:complexType>
          <s:sequence>
            <s:element minOccurs="0" name="success" type="s:boolean"/>
          </s:sequence>
        </s:complexType>
      </s:element>
      <s:element name="SendIndex2">
        <s:complexType>
          <s:sequence>
            <s:element minOccurs="0" name="subject_of_care_id" type="s:string"/>
            <s:element minOccurs="0" name="index_updates" type="s0:ArrayOfindex_updateIndexUpdate_type"/>
            <s:element minOccurs="0" name="parameters" type="s0:ArrayOfparameternpoParameter_type"/>
          </s:sequence>
        </s:complexType>
      </s:element>
      <s:complexType name="ArrayOfindex_updateIndexUpdate_type">
        <s:sequence>
          <s:element maxOccurs="unbounded" minOccurs="0" name="index_update" nillable="true" type="s0:IndexUpdate_type"/>
        </s:sequence>
      </s:complexType>
      <s:complexType name="IndexUpdate_type">
        <s:sequence>
          <s:element minOccurs="0" name="info_type_id" type="s:string"/>
          <s:element minOccurs="0" name="from_date" type="s:date"/>
          <s:element minOccurs="0" name="to_date" type="s:date"/>
          <s:element minOccurs="0" name="registration_time" type="s:dateTime"/>
          <s:element minOccurs="0" name="rc_id" type="s:string"/>
          <!--The following three elements are added in order to support VG/VE-->
          <s:element minOccurs="0" name="care_giver" type="s:string"/>
          <s:element minOccurs="0" name="care_unit" type="s:string"/>
          <s:element minOccurs="0" name="org_unit" type="s:string"/>
        </s:sequence>
        <s:attribute name="action">
          <s:simpleType>
            <s:restriction base="s:string">
              <s:maxLength value="1"/>
              <s:enumeration value="U"/>
              <s:enumeration value="D"/>
            </s:restriction>
          </s:simpleType>
        </s:attribute>
      </s:complexType>
      <s:element name="SendIndex2Response">
        <s:complexType>
          <s:sequence>
            <s:element minOccurs="0" name="success" type="s:boolean"/>
          </s:sequence>
        </s:complexType>
      </s:element>
      <s:element name="SendSimpleIndex">
        <s:complexType>
          <s:sequence>
            <s:element minOccurs="0" name="subject_of_care_id" type="s:string"/>
            <s:element minOccurs="0" name="info_types" type="s0:ArrayOfinfo_typeInfoType_type"/>
            <s:element minOccurs="0" name="parameters" type="s0:ArrayOfparameternpoParameter_type"/>
          </s:sequence>
        </s:complexType>
      </s:element>
      <s:complexType name="ArrayOfinfo_typeInfoType_type">
        <s:sequence>
          <s:element maxOccurs="unbounded" minOccurs="0" name="info_type" nillable="true" type="s0:InfoType_type"/>
        </s:sequence>
      </s:complexType>
      <s:complexType name="InfoType_type">
        <s:attribute name="info_type_id" type="s:string"/>
        <s:attribute name="exists" type="s:boolean"/>
      </s:complexType>
      <s:element name="SendSimpleIndexResponse">
        <s:complexType>
          <s:sequence>
            <s:element minOccurs="0" name="success" type="s:boolean"/>
          </s:sequence>
        </s:complexType>
      </s:element>
    </s:schema>
  </types>
  <message name="SendIndex2SoapIn">
    <part element="s0:SendIndex2" name="parameters"></part>
  </message>
  <message name="GetConsistencyListSoapIn">
    <part element="s0:GetConsistencyList" name="parameters"></part>
  </message>
  <message name="SendDeletionsSoapIn">
    <part element="s0:SendDeletions" name="parameters"></part>
  </message>
  <message name="GetConsistencyListSoapOut">
    <part element="s0:GetConsistencyListResponse" name="parameters"></part>
  </message>
  <message name="CheckConsistencySoapOut">
    <part element="s0:CheckConsistencyResponse" name="parameters"></part>
  </message>
  <message name="SendDeletionsSoapOut">
    <part element="s0:SendDeletionsResponse" name="parameters"></part>
  </message>
  <message name="NotifyAliveSoapOut">
    <part element="s0:NotifyAliveResponse" name="parameters"></part>
  </message>
  <message name="NotifyAliveSoapIn">
    <part element="s0:NotifyAlive" name="parameters"></part>
  </message>
  <message name="SendSimpleIndexSoapOut">
    <part element="s0:SendSimpleIndexResponse" name="parameters"></part>
  </message>
  <message name="SendSimpleIndexSoapIn">
    <part element="s0:SendSimpleIndex" name="parameters"></part>
  </message>
  <message name="SendIndex2SoapOut">
    <part element="s0:SendIndex2Response" name="parameters"></part>
  </message>
  <message name="CheckConsistencySoapIn">
    <part element="s0:CheckConsistency" name="parameters"></part>
  </message>
  <portType name="NPOSoap">
    <operation name="CheckConsistency">
      <input message="s0:CheckConsistencySoapIn"></input>
      <output message="s0:CheckConsistencySoapOut"></output>
    </operation>
    <operation name="GetConsistencyList">
      <input message="s0:GetConsistencyListSoapIn"></input>
      <output message="s0:GetConsistencyListSoapOut"></output>
    </operation>
    <operation name="NotifyAlive">
      <input message="s0:NotifyAliveSoapIn"></input>
      <output message="s0:NotifyAliveSoapOut"></output>
    </operation>
    <operation name="SendDeletions">
      <input message="s0:SendDeletionsSoapIn"></input>
      <output message="s0:SendDeletionsSoapOut"></output>
    </operation>
    <operation name="SendIndex2">
      <input message="s0:SendIndex2SoapIn"></input>
      <output message="s0:SendIndex2SoapOut"></output>
    </operation>
    <operation name="SendSimpleIndex">
      <input message="s0:SendSimpleIndexSoapIn"></input>
      <output message="s0:SendSimpleIndexSoapOut"></output>
    </operation>
  </portType>
  <binding name="NPOSoap" type="s0:NPOSoap">
    <soap:binding style="document" transport="http://schemas.xmlsoap.org/soap/http"/>
    <operation name="CheckConsistency">
      <soap:operation soapAction="http://nationellpatientoversikt.se:CheckConsistency" style="document"/>
      <input>
        <soap:body use="literal"/>
      </input>
      <output>
        <soap:body use="literal"/>
      </output>
    </operation>
    <operation name="GetConsistencyList">
      <soap:operation soapAction="http://nationellpatientoversikt.se:GetConsistencyList" style="document"/>
      <input>
        <soap:body use="literal"/>
      </input>
      <output>
        <soap:body use="literal"/>
      </output>
    </operation>
    <operation name="NotifyAlive">
      <soap:operation soapAction="http://nationellpatientoversikt.se:NotifyAlive" style="document"/>
      <input>
        <soap:body use="literal"/>
      </input>
      <output>
        <soap:body use="literal"/>
      </output>
    </operation>
    <operation name="SendDeletions">
      <soap:operation soapAction="http://nationellpatientoversikt.se:SendDeletions" style="document"/>
      <input>
        <soap:body use="literal"/>
      </input>
      <output>
        <soap:body use="literal"/>
      </output>
    </operation>
    <operation name="SendIndex2">
      <soap:operation soapAction="http://nationellpatientoversikt.se:SendIndex2" style="document"/>
      <input>
        <soap:body use="literal"/>
      </input>
      <output>
        <soap:body use="literal"/>
      </output>
    </operation>
    <operation name="SendSimpleIndex">
      <soap:operation soapAction="http://nationellpatientoversikt.se:SendSimpleIndex" style="document"/>
      <input>
        <soap:body use="literal"/>
      </input>
      <output>
        <soap:body use="literal"/>
      </output>
    </operation>
  </binding>
  <service name="NPO">
    <port binding="s0:NPOSoap" name="NPOSoap">
      <soap:address location="http://localhost:11000/npoadapter/npo"/>
    </port>
  </service>
  <s:annotation>
    <s:documentation>-------------------------------------------------------------
		Hjalmar Jacobson
		Tieto
		
		Changes in NPO_1.1.2.wsdl compared to NPO_1.1.1.wsdl
		
		The service 'SendIndex' changed name to 'SendIndex2' (needed since the signature of the service
		changed in version 1.1.0 - the name should have been changed in that version).
    
    Version is 1.1.2
-------------------------------------------------------------
		Hjalmar Jacobson
		Tieto
		
		Changes in NPO_1.1.1.wsdl compared to NPO_1.1.0.wsdl
		
		Removed duplicate declaration of element 'care_giver' in the type 'IndexUpdate_type'.
    
    Version is 1.1.1
-------------------------------------------------------------
		Hjalmar Jacobson
		Tieto
		
		Changes in NPO_1.1.0.wsdl compared to NPO_1.0.0.wsdl
		
		Changes to support care giver (VG) and care unit (VE) - the change affects SendIndex
		  - The type IndexUpdate_type have three new elements: care_giver, care_unit and org_unit
    
    Version is 1.1.0
-------------------------------------------------------------</s:documentation>
  </s:annotation>
</definitions>]]></con:content><con:type>http://schemas.xmlsoap.org/wsdl/</con:type></con:part></con:definitionCache><con:endpoints><con:endpoint>http://localhost:11000/npoadapter/npo</con:endpoint></con:endpoints><con:operation isOneWay="false" action="http://nationellpatientoversikt.se:CheckConsistency" name="CheckConsistency" bindingOperationName="CheckConsistency" type="Request-Response" inputName="" receivesAttachments="false" sendsAttachments="false" anonymous="optional"><con:settings/><con:call name="Request 1"><con:settings/><con:encoding>UTF-8</con:encoding><con:endpoint>http://localhost:11000/npoadapter/npo</con:endpoint><con:request><![CDATA[<soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/" xmlns:nat="http://nationellpatientoversikt.se">
   <soapenv:Header/>
   <soapenv:Body>
      <nat:CheckConsistency>
         <!--Optional:-->
         <nat:subject_of_care_id>?</nat:subject_of_care_id>
         <!--Optional:-->
         <nat:from_time>?</nat:from_time>
         <!--Optional:-->
         <nat:parameters>
            <!--Zero or more repetitions:-->
            <nat:parameter>
               <!--Optional:-->
               <nat:name>?</nat:name>
               <!--Optional:-->
               <nat:value>?</nat:value>
            </nat:parameter>
         </nat:parameters>
      </nat:CheckConsistency>
   </soapenv:Body>
</soapenv:Envelope>]]></con:request><con:wsaConfig mustUnderstand="NONE" version="200508" action="http://nationellpatientoversikt.se:CheckConsistency"/></con:call></con:operation><con:operation isOneWay="false" action="http://nationellpatientoversikt.se:GetConsistencyList" name="GetConsistencyList" bindingOperationName="GetConsistencyList" type="Request-Response" inputName="" receivesAttachments="false" sendsAttachments="false" anonymous="optional"><con:settings/><con:call name="Request 1"><con:settings/><con:encoding>UTF-8</con:encoding><con:endpoint>http://localhost:11000/npoadapter/npo</con:endpoint><con:request><![CDATA[<soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/" xmlns:nat="http://nationellpatientoversikt.se">
   <soapenv:Header/>
   <soapenv:Body>
      <nat:GetConsistencyList>
         <!--Optional:-->
         <nat:parameters>
            <!--Zero or more repetitions:-->
            <nat:parameter>
               <!--Optional:-->
               <nat:name>?</nat:name>
               <!--Optional:-->
               <nat:value>?</nat:value>
            </nat:parameter>
         </nat:parameters>
         <!--Optional:-->
         <nat:from_time>?</nat:from_time>
      </nat:GetConsistencyList>
   </soapenv:Body>
</soapenv:Envelope>]]></con:request><con:wsaConfig mustUnderstand="NONE" version="200508" action="http://nationellpatientoversikt.se:GetConsistencyList"/></con:call></con:operation><con:operation isOneWay="false" action="http://nationellpatientoversikt.se:NotifyAlive" name="NotifyAlive" bindingOperationName="NotifyAlive" type="Request-Response" inputName="" receivesAttachments="false" sendsAttachments="false" anonymous="optional"><con:settings/><con:call name="Request 1"><con:settings/><con:encoding>UTF-8</con:encoding><con:endpoint>http://localhost:11000/npoadapter/npo</con:endpoint><con:request><![CDATA[<soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/" xmlns:nat="http://nationellpatientoversikt.se">
   <soapenv:Header/>
   <soapenv:Body>
      <nat:NotifyAlive>
         <!--Optional:-->
         <nat:parameters>
            <!--Zero or more repetitions:-->
            <nat:parameter>
               <!--Optional:-->
               <nat:name>?</nat:name>
               <!--Optional:-->
               <nat:value>?</nat:value>
            </nat:parameter>
         </nat:parameters>
      </nat:NotifyAlive>
   </soapenv:Body>
</soapenv:Envelope>]]></con:request><con:wsaConfig mustUnderstand="NONE" version="200508" action="http://nationellpatientoversikt.se:NotifyAlive"/></con:call></con:operation><con:operation isOneWay="false" action="http://nationellpatientoversikt.se:SendDeletions" name="SendDeletions" bindingOperationName="SendDeletions" type="Request-Response" inputName="" receivesAttachments="false" sendsAttachments="false" anonymous="optional"><con:settings/><con:call name="Request 1"><con:settings/><con:encoding>UTF-8</con:encoding><con:endpoint>http://localhost:11000/npoadapter/npo</con:endpoint><con:request><![CDATA[<soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/" xmlns:nat="http://nationellpatientoversikt.se">
   <soapenv:Header/>
   <soapenv:Body>
      <nat:SendDeletions>
         <!--Optional:-->
         <nat:subject_of_care_id>?</nat:subject_of_care_id>
         <!--Optional:-->
         <nat:deletions>
            <!--Zero or more repetitions:-->
            <nat:deletion>
               <!--Optional:-->
               <nat:rc_id>?</nat:rc_id>
               <!--Optional:-->
               <nat:info_type_id>?</nat:info_type_id>
               <!--Optional:-->
               <nat:registration_time>?</nat:registration_time>
            </nat:deletion>
         </nat:deletions>
         <!--Optional:-->
         <nat:parameters>
            <!--Zero or more repetitions:-->
            <nat:parameter>
               <!--Optional:-->
               <nat:name>?</nat:name>
               <!--Optional:-->
               <nat:value>?</nat:value>
            </nat:parameter>
         </nat:parameters>
      </nat:SendDeletions>
   </soapenv:Body>
</soapenv:Envelope>]]></con:request><con:wsaConfig mustUnderstand="NONE" version="200508" action="http://nationellpatientoversikt.se:SendDeletions"/></con:call></con:operation><con:operation isOneWay="false" action="http://nationellpatientoversikt.se:SendIndex2" name="SendIndex2" bindingOperationName="SendIndex2" type="Request-Response" inputName="" receivesAttachments="false" sendsAttachments="false" anonymous="optional"><con:settings/><con:call name="Request 1"><con:settings/><con:encoding>UTF-8</con:encoding><con:endpoint>http://localhost:11000/npoadapter/npo</con:endpoint><con:request><![CDATA[<soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/" xmlns:nat="http://nationellpatientoversikt.se">
   <soapenv:Header/>
   <soapenv:Body>
      <nat:SendIndex2>
         <!--Optional:-->
         <nat:subject_of_care_id>?</nat:subject_of_care_id>
         <!--Optional:-->
         <nat:index_updates>
            <!--Zero or more repetitions:-->
            <nat:index_update action="?">
               <!--Optional:-->
               <nat:info_type_id>?</nat:info_type_id>
               <!--Optional:-->
               <nat:from_date>?</nat:from_date>
               <!--Optional:-->
               <nat:to_date>?</nat:to_date>
               <!--Optional:-->
               <nat:registration_time>?</nat:registration_time>
               <!--Optional:-->
               <nat:rc_id>?</nat:rc_id>
               <!--Optional:-->
               <nat:care_giver>?</nat:care_giver>
               <!--Optional:-->
               <nat:care_unit>?</nat:care_unit>
               <!--Optional:-->
               <nat:org_unit>?</nat:org_unit>
            </nat:index_update>
         </nat:index_updates>
         <!--Optional:-->
         <nat:parameters>
            <!--Zero or more repetitions:-->
            <nat:parameter>
               <!--Optional:-->
               <nat:name>?</nat:name>
               <!--Optional:-->
               <nat:value>?</nat:value>
            </nat:parameter>
         </nat:parameters>
      </nat:SendIndex2>
   </soapenv:Body>
</soapenv:Envelope>]]></con:request><con:credentials><con:authType>Global HTTP Settings</con:authType></con:credentials><con:jmsConfig JMSDeliveryMode="PERSISTENT"/><con:jmsPropertyConfig/><con:wsaConfig mustUnderstand="NONE" version="200508" action="http://nationellpatientoversikt.se:SendIndex2"/><con:wsrmConfig version="1.2"/></con:call></con:operation><con:operation isOneWay="false" action="http://nationellpatientoversikt.se:SendSimpleIndex" name="SendSimpleIndex" bindingOperationName="SendSimpleIndex" type="Request-Response" inputName="" receivesAttachments="false" sendsAttachments="false" anonymous="optional"><con:settings/><con:call name="Request 1"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;xml-fragment/></con:setting></con:settings><con:encoding>UTF-8</con:encoding><con:endpoint>http://localhost:11000/npoadapter/npo</con:endpoint><con:request><![CDATA[<soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/" xmlns:nat="http://nationellpatientoversikt.se">
   <soapenv:Header/>
   <soapenv:Body>
      <nat:SendSimpleIndex>
         <!--Optional:-->
         <nat:subject_of_care_id>191212121212</nat:subject_of_care_id>
         <!--Optional:-->
         <nat:info_types>
            <!--Zero or more repetitions:-->
            <nat:info_type info_type_id="vko" exists="true"/>
         </nat:info_types>
         <!--Optional:-->
         <nat:parameters>
            <!--Zero or more repetitions:-->
            <nat:parameter>
               <!--Optional:-->
               <nat:name>hsa_id</nat:name>
               <!--Optional:-->
               <nat:value>VS-1</nat:value>
            </nat:parameter>
            <nat:parameter>
               <!--Optional:-->
               <nat:name>transaction_id</nat:name>
               <!--Optional:-->
               <nat:value>SE-1234</nat:value>
            </nat:parameter>
            <nat:parameter>
               <!--Optional:-->
               <nat:name>version</nat:name>
               <!--Optional:-->
               <nat:value>1.1</nat:value>
            </nat:parameter>
         </nat:parameters>
      </nat:SendSimpleIndex>
   </soapenv:Body>
</soapenv:Envelope>]]></con:request><con:credentials><con:authType>Global HTTP Settings</con:authType></con:credentials><con:jmsConfig JMSDeliveryMode="PERSISTENT"/><con:jmsPropertyConfig/><con:wsaConfig mustUnderstand="NONE" version="200508" action="http://nationellpatientoversikt.se:SendSimpleIndex"/><con:wsrmConfig version="1.2"/></con:call></con:operation></con:interface><con:interface xsi:type="con:WsdlInterface" wsaVersion="NONE" name="UpdateResponderBinding" type="wsdl" bindingName="{urn:riv:itintegration:engagementindex:Update:1:rivtabp21}UpdateResponderBinding" soapVersion="1_1" anonymous="optional" definition="http://localhost:11000/npoadapter/ei?wsdl" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"><con:settings/><con:definitionCache type="TEXT" rootPart="http://localhost:11000/npoadapter/ei?wsdl"><con:part><con:url>http://localhost:11000/npoadapter/ei?wsdl</con:url><con:content><![CDATA[<wsdl:definitions name="UpdateInteraction" targetNamespace="urn:riv:itintegration:engagementindex:Update:1:rivtabp21" xmlns:itr="urn:riv:itintegration:registry:1" xmlns:soap="http://schemas.xmlsoap.org/wsdl/soap/" xmlns:tjsi="urn:riv:itintegration:engagementindex:UpdateInitiator:1" xmlns:tjsr="urn:riv:itintegration:engagementindex:UpdateResponder:1" xmlns:tns="urn:riv:itintegration:engagementindex:Update:1:rivtabp21" xmlns:wsdl="http://schemas.xmlsoap.org/wsdl/" xmlns:xs="http://www.w3.org/2001/XMLSchema">
  <wsdl:types>
    <xs:schema targetNamespace="urn:riv:itintegration:engagementindex:Update:1:rivtabp21">
      <xs:import namespace="urn:riv:itintegration:engagementindex:UpdateResponder:1" schemaLocation="http://localhost:11000/npoadapter/ei?xsd=UpdateResponder_1.0.xsd"/>
      <xs:import namespace="urn:riv:itintegration:registry:1" schemaLocation="http://localhost:11000/npoadapter/ei?xsd=../../core_components/itintegration_registry_1.0.xsd"/>
    </xs:schema>
  </wsdl:types>
  <wsdl:message name="UpdateResponse">
    <wsdl:part element="tjsr:UpdateResponse" name="parameters"></wsdl:part>
  </wsdl:message>
  <wsdl:message name="UpdateRequest">
    <wsdl:part element="itr:LogicalAddress" name="LogicalAddress">
      <wsdl:documentation>The organisation number of the organization owning the targeted engagement index</wsdl:documentation>
    </wsdl:part>
    <wsdl:part element="tjsr:Update" name="parameters"></wsdl:part>
  </wsdl:message>
  <wsdl:portType name="UpdateResponderInterface">
    <wsdl:operation name="Update">
      <wsdl:input message="tns:UpdateRequest"></wsdl:input>
      <wsdl:output message="tns:UpdateResponse"></wsdl:output>
    </wsdl:operation>
  </wsdl:portType>
  <wsdl:binding name="UpdateResponderBinding" type="tns:UpdateResponderInterface">
    <soap:binding style="document" transport="http://schemas.xmlsoap.org/soap/http"/>
    <wsdl:operation name="Update">
      <soap:operation soapAction="urn:riv:itintegration:engagementindex:UpdateResponder:1:Update" style="document"/>
      <wsdl:input>
        <soap:header message="tns:UpdateRequest" part="LogicalAddress" use="literal"></soap:header>
        <soap:body parts="parameters" use="literal"/>
      </wsdl:input>
      <wsdl:output>
        <soap:body use="literal"/>
      </wsdl:output>
    </wsdl:operation>
  </wsdl:binding>
  <wsdl:service name="UpdateResponderService">
    <wsdl:port binding="tns:UpdateResponderBinding" name="UpdateResponderPort">
      <soap:address location="http://localhost:11000/npoadapter/ei"/>
    </wsdl:port>
  </wsdl:service>
  <xs:annotation>
    <xs:documentation>Tjänsteinteraktionens namn: UpdateInteraction
			 Beskrivning: 
			   Service for adding, updating and removing content to/from engagement index
			 Revisioner: 
			 Tjänstedomän: itintegration:engagementindex
			 Tjänsteinteraktionstyp: Fråga-Svar
			 WS-profil: RIVTABP21
			 Förvaltas av: Sveriges Kommuner och Landsting</xs:documentation>
  </xs:annotation>
</wsdl:definitions>]]></con:content><con:type>http://schemas.xmlsoap.org/wsdl/</con:type></con:part><con:part><con:url>http://localhost:11000/npoadapter/ei?xsd=UpdateResponder_1.0.xsd</con:url><con:content><![CDATA[<!--Licensed to the Apache Software Foundation (ASF) under one
 or more contributor license agreements. See the NOTICE file
 distributed with this work for additional information
 regarding copyright ownership. Sveriges Kommuner och Landsting licenses this file
 to you under the Apache License, Version 2.0 (the
 "License"); you may not use this file except in compliance
 with the License. You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing,
 software distributed under the License is distributed on an
 "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 KIND, either express or implied. See the License for the
 specific language governing permissions and limitations
 under the License.-->
<xs:schema attributeFormDefault="unqualified" elementFormDefault="qualified" targetNamespace="urn:riv:itintegration:engagementindex:UpdateResponder:1" version="1.0" xmlns:core="urn:riv:itintegration:engagementindex:1" xmlns:tns="urn:riv:itintegration:engagementindex:UpdateResponder:1" xmlns:xs="http://www.w3.org/2001/XMLSchema">
  <xs:import namespace="urn:riv:itintegration:engagementindex:1" schemaLocation="http://localhost:11000/npoadapter/ei?xsd=../../core_components/itintegration_engagementindex_1.0.xsd"/>
  <xs:element name="Update" type="tns:UpdateType"/>
  <xs:element name="UpdateResponse" type="tns:UpdateResponseType"/>
  <xs:complexType name="UpdateType">
    <xs:sequence>
      <xs:element maxOccurs="unbounded" name="engagementTransaction" type="core:EngagementTransactionType"/>
      <xs:any maxOccurs="unbounded" minOccurs="0" namespace="##other" processContents="lax"/>
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="UpdateResponseType">
    <xs:sequence>
      <xs:element name="ResultCode" type="core:ResultCodeEnum"/>
      <xs:element minOccurs="0" name="comment" type="xs:string"/>
      <xs:any maxOccurs="unbounded" minOccurs="0" namespace="##other" processContents="lax"/>
    </xs:sequence>
  </xs:complexType>
</xs:schema>]]></con:content><con:type>http://www.w3.org/2001/XMLSchema</con:type></con:part><con:part><con:url>http://localhost:11000/npoadapter/ei?xsd=../../core_components/itintegration_engagementindex_1.0.xsd</con:url><con:content><![CDATA[<!--Licensed to the Apache Software Foundation (ASF) under one
 or more contributor license agreements. See the NOTICE file
 distributed with this work for additional information
 regarding copyright ownership. Sveriges Kommuner och Landsting licenses this file
 to you under the Apache License, Version 2.0 (the
 "License"); you may not use this file except in compliance
 with the License. You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing,
 software distributed under the License is distributed on an
 "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 KIND, either express or implied. See the License for the
 specific language governing permissions and limitations
 under the License.-->
<xs:schema attributeFormDefault="unqualified" elementFormDefault="qualified" targetNamespace="urn:riv:itintegration:engagementindex:1" version="1.0" xmlns:tns="urn:riv:itintegration:engagementindex:1" xmlns:xs="http://www.w3.org/2001/XMLSchema">
  <xs:complexType name="EngagementTransactionType">
    <xs:sequence>
      <xs:element name="deleteFlag" type="xs:boolean"/>
      <xs:element name="engagement" type="tns:EngagementType"/>
      <xs:any maxOccurs="unbounded" minOccurs="0" namespace="##other" processContents="lax"/>
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="EngagementType">
    <xs:sequence>
      <xs:element name="registeredResidentIdentification" type="tns:RegisteredResidentIdentificationType"/>
      <xs:element name="serviceDomain" type="xs:anyURI"/>
      <xs:element name="categorization" type="xs:string"/>
      <xs:element name="logicalAddress" type="xs:string"/>
      <xs:element name="businessObjectInstanceIdentifier" type="xs:string"/>
      <xs:element minOccurs="1" name="clinicalProcessInterestId" type="tns:ClinicalProcessInterestIdType"/>
      <xs:element minOccurs="0" name="mostRecentContent" type="tns:TS"/>
      <xs:element name="sourceSystem" type="tns:HsaIdType"/>
      <xs:element minOccurs="0" name="creationTime" type="tns:TS"/>
      <xs:element minOccurs="0" name="updateTime" type="tns:TS"/>
      <xs:element name="dataController" type="tns:OrgNoType"/>
      <xs:element minOccurs="0" name="owner" type="tns:HsaIdType"/>
      <xs:any maxOccurs="unbounded" minOccurs="0" namespace="##other" processContents="lax"/>
    </xs:sequence>
  </xs:complexType>
  <xs:simpleType name="HsaIdType">
    <xs:restriction base="xs:string"/>
  </xs:simpleType>
  <xs:simpleType name="OrgNoType">
    <xs:restriction base="xs:string"/>
  </xs:simpleType>
  <xs:simpleType name="ClinicalProcessInterestIdType">
    <xs:restriction base="xs:string"/>
  </xs:simpleType>
  <xs:simpleType name="RegisteredResidentIdentificationType">
    <xs:restriction base="xs:string">
      <xs:pattern value="^[0-9]{8}[0-9pPtTfF][0-9]{3}$"/>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="TS">
    <xs:restriction base="xs:string">
      <xs:pattern value="[1-9]{1}[0-9]{3}(0[1-9]{1}|1[0-2]{1})([0-2]{1}[0-9]{1}|3[0-1]{1})([0-1]{1}[0-9]{1}|2[0-3]{1})[0-5]{1}[0-9]{1}[0-5]{1}[0-9]{1}"/>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="DT">
    <xs:restriction base="xs:string">
      <xs:pattern value="[1-9]{1}[0-9]{3}(0[1-9]{1}|1[0-2]{1})([0-2]{1}[0-9]{1}|3[0-1]{1})"/>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="ResultCodeEnum">
    <xs:restriction base="xs:string">
      <xs:enumeration value="OK"/>
      <xs:enumeration value="ERROR"/>
      <xs:enumeration value="INFO"/>
    </xs:restriction>
  </xs:simpleType>
</xs:schema>]]></con:content><con:type>http://www.w3.org/2001/XMLSchema</con:type></con:part><con:part><con:url>http://localhost:11000/npoadapter/ei?xsd=../../core_components/itintegration_registry_1.0.xsd</con:url><con:content><![CDATA[<xs:schema elementFormDefault="qualified" targetNamespace="urn:riv:itintegration:registry:1" version="1.0" xmlns="urn:riv:itintegration:registry:1" xmlns:xs="http://www.w3.org/2001/XMLSchema">
  <xs:annotation>
    <xs:documentation>Beskrivning: 	Grundläggande informationsobjekt för domänen itintegration:registry (adressering av tjänster)
			
			Revisionshistorik: 2011-06-27 Mats Ekhammar, Callista Enterprise AB
				Added ServiceContractType
			
			Datum:			2011-05-04
			Beskrivning:	Initial version
			Författare:		marcus.krantz@callistaenterprise.se</xs:documentation>
  </xs:annotation>
  <xs:element name="LogicalAddress" type="LogicalAddressType"/>
  <xs:element name="ServiceContract" type="ServiceContractType"/>
  <xs:simpleType name="LogicalAddressType">
    <xs:annotation>
      <xs:documentation>Defines the type for logical address according to national reference architecture.
				Superseeds wsa:To as type for logical address header in RIVTA 2.1.</xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:string"/>
  </xs:simpleType>
  <xs:complexType name="ServiceContractType">
    <xs:annotation>
      <xs:documentation>Type which describes a service contract. Used in interaction GetSupportedServiceContracts.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="ServiceContractNamespace" type="xs:anyURI"/>
      <xs:any maxOccurs="unbounded" minOccurs="0" namespace="##other" processContents="lax"/>
    </xs:sequence>
  </xs:complexType>
</xs:schema>]]></con:content><con:type>http://www.w3.org/2001/XMLSchema</con:type></con:part></con:definitionCache><con:endpoints><con:endpoint>http://localhost:11000/npoadapter/ei</con:endpoint></con:endpoints><con:operation isOneWay="false" action="urn:riv:itintegration:engagementindex:UpdateResponder:1:Update" name="Update" bindingOperationName="Update" type="Request-Response" inputName="" receivesAttachments="false" sendsAttachments="false" anonymous="optional"><con:settings/><con:call name="Request 1"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;xml-fragment/></con:setting></con:settings><con:encoding>UTF-8</con:encoding><con:endpoint>http://localhost:11000/npoadapter/update</con:endpoint><con:request><![CDATA[<soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/" xmlns:urn="urn:riv:itintegration:registry:1" xmlns:urn1="urn:riv:itintegration:engagementindex:UpdateResponder:1" xmlns:urn2="urn:riv:itintegration:engagementindex:1">
   <soapenv:Header>
      <urn:LogicalAddress>?</urn:LogicalAddress>
   </soapenv:Header>
   <soapenv:Body>
      <urn1:Update>
         <!--1 or more repetitions:-->
         <urn1:engagementTransaction>
            <urn2:deleteFlag>?</urn2:deleteFlag>
            <urn2:engagement>
               <urn2:registeredResidentIdentification>?</urn2:registeredResidentIdentification>
               <urn2:serviceDomain>?</urn2:serviceDomain>
               <urn2:categorization>voo</urn2:categorization>
               <urn2:logicalAddress>?</urn2:logicalAddress>
               <urn2:businessObjectInstanceIdentifier>?</urn2:businessObjectInstanceIdentifier>
               <urn2:clinicalProcessInterestId>?</urn2:clinicalProcessInterestId>
               <!--Optional:-->
               <urn2:mostRecentContent>?</urn2:mostRecentContent>
               <urn2:sourceSystem>?</urn2:sourceSystem>
               <!--Optional:-->
               <urn2:creationTime>?</urn2:creationTime>
               <!--Optional:-->
               <urn2:updateTime>?</urn2:updateTime>
               <urn2:dataController>?</urn2:dataController>
               <!--Optional:-->
               <urn2:owner>?</urn2:owner>
               <!--You may enter ANY elements at this point-->
            </urn2:engagement>
            <!--You may enter ANY elements at this point-->
         </urn1:engagementTransaction>
         <!--You may enter ANY elements at this point-->
      </urn1:Update>
   </soapenv:Body>
</soapenv:Envelope>]]></con:request><con:credentials><con:authType>Global HTTP Settings</con:authType></con:credentials><con:jmsConfig JMSDeliveryMode="PERSISTENT"/><con:jmsPropertyConfig/><con:wsaConfig mustUnderstand="NONE" version="200508" action="urn:riv:itintegration:engagementindex:UpdateResponder:1:Update"/><con:wsrmConfig version="1.2"/></con:call></con:operation></con:interface><con:interface xsi:type="con:WsdlInterface" wsaVersion="NONE" name="CSSoap" type="wsdl" bindingName="{http://nationellpatientoversikt.se}CSSoap" soapVersion="1_1" anonymous="optional" definition="http://localhost:11000/npoadapter/caresystem/stub?wsdl" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"><con:settings/><con:definitionCache type="TEXT" rootPart="http://localhost:11000/npoadapter/caresystem/stub?wsdl"><con:part><con:url>http://localhost:11000/npoadapter/caresystem/stub?wsdl</con:url><con:content><![CDATA[<definitions targetNamespace="http://nationellpatientoversikt.se" xmlns="http://schemas.xmlsoap.org/wsdl/" xmlns:SOAP-ENC="http://schemas.xmlsoap.org/soap/encoding/" xmlns:mime="http://schemas.xmlsoap.org/wsdl/mime/" xmlns:s="http://www.w3.org/2001/XMLSchema" xmlns:s0="http://nationellpatientoversikt.se" xmlns:soap="http://schemas.xmlsoap.org/wsdl/soap/" xmlns:wsdl="http://schemas.xmlsoap.org/wsdl/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
  <types>
    <s:schema elementFormDefault="qualified" targetNamespace="http://nationellpatientoversikt.se">
      <s:element name="CheckAlive">
        <s:complexType>
          <s:sequence>
            <s:element minOccurs="0" name="parameters" type="s0:ArrayOfparameternpoParameter_type"/>
          </s:sequence>
        </s:complexType>
      </s:element>
      <s:complexType name="ArrayOfparameternpoParameter_type">
        <s:sequence>
          <s:element maxOccurs="unbounded" minOccurs="0" name="parameter" nillable="true" type="s0:npoParameter_type"/>
        </s:sequence>
      </s:complexType>
      <s:complexType name="npoParameter_type">
        <s:sequence>
          <s:element minOccurs="0" name="name" type="s:string"/>
          <s:element minOccurs="0" name="value" type="s:string"/>
        </s:sequence>
      </s:complexType>
      <s:element name="CheckAliveResponse">
        <s:complexType>
          <s:sequence>
            <s:element minOccurs="0" name="success" type="s:boolean"/>
          </s:sequence>
        </s:complexType>
      </s:element>
      <s:element name="GetDeletions">
        <s:complexType>
          <s:sequence>
            <s:element minOccurs="0" name="subject_of_care_id" type="s:string"/>
            <s:element minOccurs="0" name="from_time" type="s:dateTime"/>
            <s:element minOccurs="0" name="to_time" type="s:dateTime"/>
            <s:element minOccurs="0" name="parameters" type="s0:ArrayOfparameternpoParameter_type"/>
          </s:sequence>
        </s:complexType>
      </s:element>
      <s:element name="GetDeletionsResponse">
        <s:complexType>
          <s:sequence>
            <s:element minOccurs="0" name="deletions" type="s0:ArrayOfdeletionDeletion_type"/>
            <s:element minOccurs="0" name="response_details" type="s0:ArrayOfresponse_detailnpoResponse_detail_type"/>
          </s:sequence>
        </s:complexType>
      </s:element>
      <s:complexType name="ArrayOfdeletionDeletion_type">
        <s:sequence>
          <s:element maxOccurs="unbounded" minOccurs="0" name="deletion" nillable="true" type="s0:Deletion_type"/>
        </s:sequence>
      </s:complexType>
      <s:complexType name="Deletion_type">
        <s:sequence>
          <s:element minOccurs="0" name="rc_id" type="s:string"/>
          <s:element minOccurs="0" name="registration_time" type="s:dateTime"/>
          <s:element minOccurs="0" name="info_type_id" type="s:string"/>
        </s:sequence>
      </s:complexType>
      <s:complexType name="ArrayOfresponse_detailnpoResponse_detail_type">
        <s:sequence>
          <s:element maxOccurs="unbounded" minOccurs="0" name="response_detail" nillable="true" type="s0:npoResponse_detail_type"/>
        </s:sequence>
      </s:complexType>
      <s:complexType name="npoResponse_detail_type">
        <s:simpleContent>
          <s:extension base="s:string">
            <s:attribute name="kind">
              <s:simpleType>
                <s:restriction base="s:string">
                  <s:maxLength value="1"/>
                  <s:enumeration value="E"/>
                  <s:enumeration value="W"/>
                  <s:enumeration value="I"/>
                </s:restriction>
              </s:simpleType>
            </s:attribute>
            <s:attribute name="code" type="s:string"/>
          </s:extension>
        </s:simpleContent>
      </s:complexType>
      <s:element name="GetIndex2">
        <s:complexType>
          <s:sequence>
            <s:element minOccurs="0" name="subject_of_care_id" type="s:string"/>
            <s:element minOccurs="0" name="from_time" type="s:dateTime"/>
            <s:element minOccurs="0" name="to_time" type="s:dateTime"/>
            <s:element minOccurs="0" name="parameters" type="s0:ArrayOfparameternpoParameter_type"/>
          </s:sequence>
        </s:complexType>
      </s:element>
      <s:element name="GetIndex2Response">
        <s:complexType>
          <s:sequence>
            <s:element minOccurs="0" name="index_updates" type="s0:ArrayOfindex_updateIndexUpdate_type"/>
            <s:element minOccurs="0" name="response_details" type="s0:ArrayOfresponse_detailnpoResponse_detail_type"/>
          </s:sequence>
        </s:complexType>
      </s:element>
      <s:complexType name="ArrayOfindex_updateIndexUpdate_type">
        <s:sequence>
          <s:element maxOccurs="unbounded" minOccurs="0" name="index_update" nillable="true" type="s0:IndexUpdate_type"/>
        </s:sequence>
      </s:complexType>
      <s:complexType name="IndexUpdate_type">
        <s:sequence>
          <s:element minOccurs="0" name="info_type_id" type="s:string"/>
          <s:element minOccurs="0" name="from_date" type="s:date"/>
          <s:element minOccurs="0" name="to_date" type="s:date"/>
          <s:element minOccurs="0" name="registration_time" type="s:dateTime"/>
          <s:element minOccurs="0" name="rc_id" type="s:string"/>
          <!--The following three elements are added in order to support VG/VE-->
          <s:element minOccurs="0" name="care_giver" type="s:string"/>
          <s:element minOccurs="0" name="care_unit" type="s:string"/>
          <s:element minOccurs="0" name="org_unit" type="s:string"/>
        </s:sequence>
        <s:attribute name="action">
          <s:simpleType>
            <s:restriction base="s:string">
              <s:maxLength value="1"/>
              <s:enumeration value="U"/>
              <s:enumeration value="D"/>
            </s:restriction>
          </s:simpleType>
        </s:attribute>
      </s:complexType>
      <s:element name="GetPatientList">
        <s:complexType>
          <s:sequence>
            <s:element minOccurs="0" name="purpose" type="s:string"/>
            <s:element minOccurs="0" name="info_type_ids" type="s0:ArrayOfinfo_type_idsItemString"/>
            <s:element minOccurs="0" name="parameters" type="s0:ArrayOfparameternpoParameter_type"/>
            <s:element minOccurs="0" name="from_time" type="s:dateTime"/>
          </s:sequence>
        </s:complexType>
      </s:element>
      <s:complexType name="ArrayOfinfo_type_idsItemString">
        <s:sequence>
          <s:element maxOccurs="unbounded" minOccurs="0" name="info_type_idsItem" nillable="true" type="s:string"/>
        </s:sequence>
      </s:complexType>
      <s:element name="GetPatientListResponse">
        <s:complexType>
          <s:sequence>
            <s:element minOccurs="0" name="subject_of_care_ids" type="s0:ArrayOfsubject_of_care_idString"/>
            <s:element minOccurs="0" name="from_time" type="s:dateTime"/>
            <s:element minOccurs="0" name="response_details" type="s0:ArrayOfresponse_detailnpoResponse_detail_type"/>
          </s:sequence>
        </s:complexType>
      </s:element>
      <s:complexType name="ArrayOfsubject_of_care_idString">
        <s:sequence>
          <s:element maxOccurs="unbounded" minOccurs="0" name="subject_of_care_id" nillable="true" type="s:string"/>
        </s:sequence>
      </s:complexType>
      <s:element name="GetSimpleIndex">
        <s:complexType>
          <s:sequence>
            <s:element minOccurs="0" name="parameters" type="s0:ArrayOfparameternpoParameter_type"/>
            <s:element minOccurs="0" name="from_time" type="s:dateTime"/>
          </s:sequence>
        </s:complexType>
      </s:element>
      <s:element name="GetSimpleIndexResponse">
        <s:complexType>
          <s:sequence>
            <s:element minOccurs="0" name="subject_of_care_info_types" type="s0:ArrayOfsubject_of_care_info_typeSubjectOfCareInfoTypes_type"/>
            <s:element minOccurs="0" name="from_time" type="s:dateTime"/>
            <s:element minOccurs="0" name="response_details" type="s0:ArrayOfresponse_detailnpoResponse_detail_type"/>
          </s:sequence>
        </s:complexType>
      </s:element>
      <s:complexType name="ArrayOfsubject_of_care_info_typeSubjectOfCareInfoTypes_type">
        <s:sequence>
          <s:element maxOccurs="unbounded" minOccurs="0" name="subject_of_care_info_type" nillable="true" type="s0:SubjectOfCareInfoTypes_type"/>
        </s:sequence>
      </s:complexType>
      <s:complexType name="SubjectOfCareInfoTypes_type">
        <s:sequence>
          <s:element minOccurs="0" name="subject_of_care_id" type="s:string"/>
          <s:element minOccurs="0" name="info_types" type="s0:ArrayOfinfo_typeInfoType_type"/>
        </s:sequence>
      </s:complexType>
      <s:complexType name="ArrayOfinfo_typeInfoType_type">
        <s:sequence>
          <s:element maxOccurs="unbounded" minOccurs="0" name="info_type" nillable="true" type="s0:InfoType_type"/>
        </s:sequence>
      </s:complexType>
      <s:complexType name="InfoType_type">
        <s:attribute name="info_type_id" type="s:string"/>
        <s:attribute name="exists" type="s:boolean"/>
      </s:complexType>
      <s:element name="SendStatus">
        <s:complexType>
          <s:sequence>
            <s:element minOccurs="0" name="parameters" type="s0:ArrayOfparameternpoParameter_type"/>
            <s:element minOccurs="0" name="response_details" type="s0:ArrayOfresponse_detailnpoResponse_detail_type"/>
          </s:sequence>
        </s:complexType>
      </s:element>
      <s:element name="SendStatusResponse">
        <s:complexType>
          <s:sequence>
            <s:element minOccurs="0" name="success" type="s:boolean"/>
          </s:sequence>
        </s:complexType>
      </s:element>
    </s:schema>
  </types>
  <message name="GetSimpleIndexSoapIn">
    <part element="s0:GetSimpleIndex" name="parameters"></part>
  </message>
  <message name="GetIndex2SoapOut">
    <part element="s0:GetIndex2Response" name="parameters"></part>
  </message>
  <message name="CheckAliveSoapOut">
    <part element="s0:CheckAliveResponse" name="parameters"></part>
  </message>
  <message name="GetPatientListSoapOut">
    <part element="s0:GetPatientListResponse" name="parameters"></part>
  </message>
  <message name="GetDeletionsSoapIn">
    <part element="s0:GetDeletions" name="parameters"></part>
  </message>
  <message name="CheckAliveSoapIn">
    <part element="s0:CheckAlive" name="parameters"></part>
  </message>
  <message name="SendStatusSoapOut">
    <part element="s0:SendStatusResponse" name="parameters"></part>
  </message>
  <message name="GetPatientListSoapIn">
    <part element="s0:GetPatientList" name="parameters"></part>
  </message>
  <message name="GetSimpleIndexSoapOut">
    <part element="s0:GetSimpleIndexResponse" name="parameters"></part>
  </message>
  <message name="GetIndex2SoapIn">
    <part element="s0:GetIndex2" name="parameters"></part>
  </message>
  <message name="GetDeletionsSoapOut">
    <part element="s0:GetDeletionsResponse" name="parameters"></part>
  </message>
  <message name="SendStatusSoapIn">
    <part element="s0:SendStatus" name="parameters"></part>
  </message>
  <portType name="CSSoap">
    <operation name="CheckAlive">
      <input message="s0:CheckAliveSoapIn"></input>
      <output message="s0:CheckAliveSoapOut"></output>
    </operation>
    <operation name="GetDeletions">
      <input message="s0:GetDeletionsSoapIn"></input>
      <output message="s0:GetDeletionsSoapOut"></output>
    </operation>
    <operation name="GetIndex2">
      <input message="s0:GetIndex2SoapIn"></input>
      <output message="s0:GetIndex2SoapOut"></output>
    </operation>
    <operation name="GetPatientList">
      <input message="s0:GetPatientListSoapIn"></input>
      <output message="s0:GetPatientListSoapOut"></output>
    </operation>
    <operation name="GetSimpleIndex">
      <input message="s0:GetSimpleIndexSoapIn"></input>
      <output message="s0:GetSimpleIndexSoapOut"></output>
    </operation>
    <operation name="SendStatus">
      <input message="s0:SendStatusSoapIn"></input>
      <output message="s0:SendStatusSoapOut"></output>
    </operation>
  </portType>
  <binding name="CSSoap" type="s0:CSSoap">
    <soap:binding style="document" transport="http://schemas.xmlsoap.org/soap/http"/>
    <operation name="CheckAlive">
      <soap:operation soapAction="http://nationellpatientoversikt.se:CheckAlive" style="document"/>
      <input>
        <soap:body use="literal"/>
      </input>
      <output>
        <soap:body use="literal"/>
      </output>
    </operation>
    <operation name="GetDeletions">
      <soap:operation soapAction="http://nationellpatientoversikt.se:GetDeletions" style="document"/>
      <input>
        <soap:body use="literal"/>
      </input>
      <output>
        <soap:body use="literal"/>
      </output>
    </operation>
    <operation name="GetIndex2">
      <soap:operation soapAction="http://nationellpatientoversikt.se:GetIndex2" style="document"/>
      <input>
        <soap:body use="literal"/>
      </input>
      <output>
        <soap:body use="literal"/>
      </output>
    </operation>
    <operation name="GetPatientList">
      <soap:operation soapAction="http://nationellpatientoversikt.se:GetPatientList" style="document"/>
      <input>
        <soap:body use="literal"/>
      </input>
      <output>
        <soap:body use="literal"/>
      </output>
    </operation>
    <operation name="GetSimpleIndex">
      <soap:operation soapAction="http://nationellpatientoversikt.se:GetSimpleIndex" style="document"/>
      <input>
        <soap:body use="literal"/>
      </input>
      <output>
        <soap:body use="literal"/>
      </output>
    </operation>
    <operation name="SendStatus">
      <soap:operation soapAction="http://nationellpatientoversikt.se:SendStatus" style="document"/>
      <input>
        <soap:body use="literal"/>
      </input>
      <output>
        <soap:body use="literal"/>
      </output>
    </operation>
  </binding>
  <service name="CS">
    <port binding="s0:CSSoap" name="CSSoap">
      <soap:address location="http://localhost:11000/npoadapter/caresystem/stub"/>
    </port>
  </service>
  <s:annotation>
    <s:documentation>-------------------------------------------------------------
		Hjalmar Jacobson
		Tieto
		
		Changes in CARE_SYSTEM_1.1.2.wsdl compared to CARE_SYSTEM_1.1.1.wsdl
		
		The service 'GetIndex' changed name to 'GetIndex2' (needed since the signature of the service
		changed in version 1.1.0 - the name should have been changed in that version).
    
    Version is 1.1.2
-------------------------------------------------------------
		Hjalmar Jacobson
		Tieto
		
		Changes in CARE_SYSTEM_1.1.1.wsdl compared to CARE_SYSTEM_1.1.0.wsdl
		
		There are no changes in CARE_SYSTEM_1.1.1.wsdl compared to CARE_SYSTEM_1.1.0.wsdl
    
    Version is 1.1.1
-------------------------------------------------------------
		Hjalmar Jacobson
		Tieto
		
		Changes in CARE_SYSTEM_1.1.0.wsdl compared to CARE_SYSTEM_1.0.0.wsdl
		
		Changes to support care giver (VG) and care unit (VE) - the change affects GetIndex
		  - The type IndexUpdate_type have three new elements: care_giver, care_unit and org_unit
    
    Version is 1.1.0
-------------------------------------------------------------</s:documentation>
  </s:annotation>
</definitions>]]></con:content><con:type>http://schemas.xmlsoap.org/wsdl/</con:type></con:part></con:definitionCache><con:endpoints><con:endpoint>http://localhost:11000/npoadapter/caresystem/stub</con:endpoint></con:endpoints><con:operation isOneWay="false" action="http://nationellpatientoversikt.se:CheckAlive" name="CheckAlive" bindingOperationName="CheckAlive" type="Request-Response" inputName="" receivesAttachments="false" sendsAttachments="false" anonymous="optional"><con:settings/><con:call name="Request 1"><con:settings/><con:encoding>UTF-8</con:encoding><con:endpoint>http://localhost:11000/npoadapter/caresystem/stub</con:endpoint><con:request><![CDATA[<soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/" xmlns:nat="http://nationellpatientoversikt.se">
   <soapenv:Header/>
   <soapenv:Body>
      <nat:CheckAlive>
         <!--Optional:-->
         <nat:parameters>
            <!--Zero or more repetitions:-->
            <nat:parameter>
               <!--Optional:-->
               <nat:name>?</nat:name>
               <!--Optional:-->
               <nat:value>?</nat:value>
            </nat:parameter>
         </nat:parameters>
      </nat:CheckAlive>
   </soapenv:Body>
</soapenv:Envelope>]]></con:request><con:wsaConfig mustUnderstand="NONE" version="200508" action="http://nationellpatientoversikt.se:CheckAlive"/></con:call></con:operation><con:operation isOneWay="false" action="http://nationellpatientoversikt.se:GetDeletions" name="GetDeletions" bindingOperationName="GetDeletions" type="Request-Response" inputName="" receivesAttachments="false" sendsAttachments="false" anonymous="optional"><con:settings/><con:call name="Request 1"><con:settings/><con:encoding>UTF-8</con:encoding><con:endpoint>http://localhost:11000/npoadapter/caresystem/stub</con:endpoint><con:request><![CDATA[<soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/" xmlns:nat="http://nationellpatientoversikt.se">
   <soapenv:Header/>
   <soapenv:Body>
      <nat:GetDeletions>
         <!--Optional:-->
         <nat:subject_of_care_id>?</nat:subject_of_care_id>
         <!--Optional:-->
         <nat:from_time>?</nat:from_time>
         <!--Optional:-->
         <nat:to_time>?</nat:to_time>
         <!--Optional:-->
         <nat:parameters>
            <!--Zero or more repetitions:-->
            <nat:parameter>
               <!--Optional:-->
               <nat:name>?</nat:name>
               <!--Optional:-->
               <nat:value>?</nat:value>
            </nat:parameter>
         </nat:parameters>
      </nat:GetDeletions>
   </soapenv:Body>
</soapenv:Envelope>]]></con:request><con:wsaConfig mustUnderstand="NONE" version="200508" action="http://nationellpatientoversikt.se:GetDeletions"/></con:call></con:operation><con:operation isOneWay="false" action="http://nationellpatientoversikt.se:GetIndex2" name="GetIndex2" bindingOperationName="GetIndex2" type="Request-Response" inputName="" receivesAttachments="false" sendsAttachments="false" anonymous="optional"><con:settings/><con:call name="Request 1"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;xml-fragment/></con:setting></con:settings><con:encoding>UTF-8</con:encoding><con:endpoint>http://localhost:11000/npoadapter/caresystem/stub</con:endpoint><con:request><![CDATA[<soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/" xmlns:nat="http://nationellpatientoversikt.se">
   <soapenv:Header/>
   <soapenv:Body>
      <nat:GetIndex2>
         <!--Optional:-->
         <nat:subject_of_care_id>?</nat:subject_of_care_id>
      </nat:GetIndex2>
   </soapenv:Body>
</soapenv:Envelope>]]></con:request><con:credentials><con:authType>Global HTTP Settings</con:authType></con:credentials><con:jmsConfig JMSDeliveryMode="PERSISTENT"/><con:jmsPropertyConfig/><con:wsaConfig mustUnderstand="NONE" version="200508" action="http://nationellpatientoversikt.se:GetIndex2"/><con:wsrmConfig version="1.2"/></con:call></con:operation><con:operation isOneWay="false" action="http://nationellpatientoversikt.se:GetPatientList" name="GetPatientList" bindingOperationName="GetPatientList" type="Request-Response" inputName="" receivesAttachments="false" sendsAttachments="false" anonymous="optional"><con:settings/><con:call name="Request 1"><con:settings/><con:encoding>UTF-8</con:encoding><con:endpoint>http://localhost:11000/npoadapter/caresystem/stub</con:endpoint><con:request><![CDATA[<soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/" xmlns:nat="http://nationellpatientoversikt.se">
   <soapenv:Header/>
   <soapenv:Body>
      <nat:GetPatientList>
         <!--Optional:-->
         <nat:purpose>?</nat:purpose>
         <!--Optional:-->
         <nat:info_type_ids>
            <!--Zero or more repetitions:-->
            <nat:info_type_idsItem>?</nat:info_type_idsItem>
         </nat:info_type_ids>
         <!--Optional:-->
         <nat:parameters>
            <!--Zero or more repetitions:-->
            <nat:parameter>
               <!--Optional:-->
               <nat:name>?</nat:name>
               <!--Optional:-->
               <nat:value>?</nat:value>
            </nat:parameter>
         </nat:parameters>
         <!--Optional:-->
         <nat:from_time>?</nat:from_time>
      </nat:GetPatientList>
   </soapenv:Body>
</soapenv:Envelope>]]></con:request><con:wsaConfig mustUnderstand="NONE" version="200508" action="http://nationellpatientoversikt.se:GetPatientList"/></con:call></con:operation><con:operation isOneWay="false" action="http://nationellpatientoversikt.se:GetSimpleIndex" name="GetSimpleIndex" bindingOperationName="GetSimpleIndex" type="Request-Response" inputName="" receivesAttachments="false" sendsAttachments="false" anonymous="optional"><con:settings/><con:call name="Request 1"><con:settings/><con:encoding>UTF-8</con:encoding><con:endpoint>http://localhost:11000/npoadapter/caresystem/stub</con:endpoint><con:request><![CDATA[<soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/" xmlns:nat="http://nationellpatientoversikt.se">
   <soapenv:Header/>
   <soapenv:Body>
      <nat:GetSimpleIndex>
         <!--Optional:-->
         <nat:parameters>
            <!--Zero or more repetitions:-->
            <nat:parameter>
               <!--Optional:-->
               <nat:name>?</nat:name>
               <!--Optional:-->
               <nat:value>?</nat:value>
            </nat:parameter>
         </nat:parameters>
         <!--Optional:-->
         <nat:from_time>?</nat:from_time>
      </nat:GetSimpleIndex>
   </soapenv:Body>
</soapenv:Envelope>]]></con:request><con:wsaConfig mustUnderstand="NONE" version="200508" action="http://nationellpatientoversikt.se:GetSimpleIndex"/></con:call></con:operation><con:operation isOneWay="false" action="http://nationellpatientoversikt.se:SendStatus" name="SendStatus" bindingOperationName="SendStatus" type="Request-Response" inputName="" receivesAttachments="false" sendsAttachments="false" anonymous="optional"><con:settings/><con:call name="Request 1"><con:settings><con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;xml-fragment/></con:setting></con:settings><con:encoding>UTF-8</con:encoding><con:endpoint>http://localhost:11000/npoadapter/caresystem/stub</con:endpoint><con:request><![CDATA[<soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/" xmlns:nat="http://nationellpatientoversikt.se">
   <soapenv:Header/>
   <soapenv:Body>
      <nat:SendStatus>
         <!--Optional:-->
         <nat:parameters>
            <!--Zero or more repetitions:-->
            <nat:parameter>
               <!--Optional:-->
               <nat:name>?</nat:name>
               <!--Optional:-->
               <nat:value>?</nat:value>
            </nat:parameter>
         </nat:parameters>
         <!--Optional:-->
         <nat:response_details>
            <!--Zero or more repetitions:-->
            <nat:response_detail kind="?" code="?">?</nat:response_detail>
         </nat:response_details>
      </nat:SendStatus>
   </soapenv:Body>
</soapenv:Envelope>]]></con:request><con:credentials><con:authType>Global HTTP Settings</con:authType></con:credentials><con:jmsConfig JMSDeliveryMode="PERSISTENT"/><con:jmsPropertyConfig/><con:wsaConfig mustUnderstand="NONE" version="200508" action="http://nationellpatientoversikt.se:SendStatus"/><con:wsrmConfig version="1.2"/></con:call></con:operation></con:interface><con:properties/><con:wssContainer/><con:sensitiveInformation/></con:soapui-project>